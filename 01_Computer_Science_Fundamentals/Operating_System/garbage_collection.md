# 垃圾回收機制

- **難度**: 6
- **重要程度**: 4
- **標籤**: `GC`, `標記清除`, `引用計數`, `分代回收`, `三色標記`

## 問題詳述

解釋垃圾回收的主要算法（引用計數、標記清除、標記整理、複製算法），分代回收策略，以及現代 GC 的優化（如 Go 的三色標記、Java 的 G1/ZGC）。

## 核心理論與詳解

### 1. 為什麼需要 GC

**手動內存管理的問題**：
- 忘記釋放 → 內存洩漏
- 過早釋放 → 懸空指針
- 重複釋放 → 程序崩潰

**GC 的優勢**：
- 自動回收不再使用的內存
- 避免內存安全問題
- 簡化程序開發

### 2. 引用計數（Reference Counting）

#### 原理

每個對象維護引用計數，計數為 0 時回收：

```
創建對象A：refcount = 1
B 引用 A：refcount = 2
C 引用 A：refcount = 3
B 釋放引用：refcount = 2
C 釋放引用：refcount = 1
原始引用釋放：refcount = 0 → 回收
```

#### 優缺點

**優點**：
- 實時回收（計數為0立即回收）
- 無停頓（不需要 STW）

**缺點**：
- 無法處理循環引用
- 每次引用變化都需要更新計數（開銷大）
- 多線程環境需要原子操作

#### 循環引用問題

```
對象A → 對象B
對象B → 對象A

兩者 refcount 都 ≥ 1
但外部無引用 → 內存洩漏
```

**解決方案**：
- 弱引用（Weak Reference）
- 結合標記清除（Python 的方案）

**應用**：Python（結合週期檢測）、Swift、Objective-C

### 3. 標記清除（Mark-Sweep）

#### 原理

```
兩階段：

1. 標記（Mark）:
   從根對象（棧、全局變量）開始
   遍歷可達對象，標記為存活

2. 清除（Sweep）:
   遍歷堆，回收未標記的對象
```

#### 示例

```
根集合: A, B

堆中對象: A → C → D
          B → E
          F (不可達)
          G (不可達)

標記階段:
A (標記) → C (標記) → D (標記)
B (標記) → E (標記)
F (未標記)
G (未標記)

清除階段:
回收 F 和 G
```

#### 優缺點

**優點**：
- 可處理循環引用
- 實現相對簡單

**缺點**：
- 需要 STW（Stop-The-World）
- 產生內存碎片
- 清除階段需要遍歷整個堆

### 4. 標記整理（Mark-Compact）

#### 原理

在標記清除的基礎上增加**整理（Compaction）**階段：

```
1. 標記存活對象
2. 整理：將存活對象移動到堆的一端
3. 清除：回收另一端的空間

標記整理前：
[A][X][B][X][X][C][X][D]
 ↑     ↑        ↑     ↑
存活  死 存活   死    存活  死

標記整理後：
[A][B][C][D][-------空閒-------]
```

#### 優缺點

**優點**：
- 無內存碎片
- 提高內存分配效率

**缺點**：
- 移動對象需要更新所有引用（開銷大）
- STW 時間更長

### 5. 複製算法（Copying）

#### 原理

將堆分為兩個區域（From、To），每次只使用一個：

```
1. 對象分配在 From 區
2. GC 時，將存活對象複製到 To 區
3. 清空 From 區
4. 交換 From 和 To

From 區：[A][X][B][X][C]
          ↓     ↓     ↓
To 區：  [A][B][C]-------

下次 GC 時角色互換
```

#### 優缺點

**優點**：
- 無碎片（對象緊密排列）
- 分配快（碰撞指針）

**缺點**：
- 空間利用率低（只能用一半）
- 對象複製開銷

**應用**：年輕代回收（對象少、存活率低）

### 6. 分代回收（Generational GC）

#### 分代假說

**弱分代假說**：大部分對象很快死亡
**強分代假說**：存活時間長的對象會存活更久

#### 分代策略

```
年輕代（Young Generation）：
├─ Eden 區：新對象分配
├─ Survivor 0
└─ Survivor 1

老年代（Old Generation）：
└─ 長期存活的對象

永久代/元空間（Metaspace）：
└─ 類元數據
```

#### Minor GC vs Major GC

```
Minor GC（年輕代）：
- 頻繁觸發
- 暫停時間短（幾毫秒）
- 使用複製算法

Major/Full GC（老年代）：
- 不頻繁
- 暫停時間長（數百毫秒）
- 使用標記清除/標記整理
```

### 7. Go 的三色標記法

#### 三色抽象

```
白色：未訪問
灰色：已訪問，但子對象未訪問
黑色：已訪問，且子對象已訪問

GC 流程：
1. 初始：所有對象白色
2. 從根集合開始，標記為灰色
3. 遍歷灰色對象:
   ├─ 標記自己為黑色
   └─ 子對象標記為灰色
4. 重複直到無灰色對象
5. 回收白色對象
```

#### 並發標記問題

**問題**：標記期間程序仍在運行，可能出現：
```
黑色對象 A（已掃描）→ 新對象 B（白色）
程序繼續執行，刪除 A → B 的引用
B 被錯誤回收！
```

**解決：寫屏障（Write Barrier）**
```
插入屏障（Insertion Barrier）：
- 新增引用時，將目標對象標記為灰色

刪除屏障（Deletion Barrier）：
- 刪除引用時，將原對象標記為灰色

Go 使用混合屏障（Hybrid Barrier）
```

#### Go GC 特點

- 並發標記（最小化 STW）
- 無分代（所有對象在一個堆）
- 目標：暫停時間 < 1ms

### 8. Java GC 演進

#### Serial GC
- 單線程
- 適合客戶端

#### Parallel GC
- 多線程並行
- 吞吐量優先

#### CMS（Concurrent Mark-Sweep）
- 並發標記清除
- 低延遲
- 有碎片化問題

#### G1（Garbage-First）
- 分區回收（Region）
- 可預測的暫停時間
- 標記整理

#### ZGC / Shenandoah
- 超低延遲（< 10ms）
- 並發整理
- 適合大堆（TB 級）

### 9. GC 調優

#### Go 調優

```bash
# 設置 GC 目標百分比
GOGC=100  # 默認，堆增長100%時觸發GC
GOGC=200  # 降低GC頻率，增加內存使用

# 查看 GC 統計
GODEBUG=gctrace=1 go run main.go
```

#### Java 調優

```bash
# 選擇 GC
-XX:+UseG1GC
-XX:+UseZGC

# 設置堆大小
-Xms2g -Xmx4g

# 暫停時間目標
-XX:MaxGCPauseMillis=200
```

## 實際應用場景

### 1. 高並發服務
- Go 的低延遲 GC
- 減少對象分配

### 2. 大數據處理
- Java G1/ZGC 處理大堆
- 對象復用減少 GC 壓力

### 3. 實時系統
- 避免 Full GC
- 使用對象池

## 總結

### 算法選擇

| 算法 | STW | 碎片 | 適用場景 |
|------|-----|------|----------|
| 引用計數 | ✗ | ✗ | 簡單場景 |
| 標記清除 | ✓ | ✓ | 通用 |
| 標記整理 | ✓ | ✗ | 老年代 |
| 複製 | ✓ | ✗ | 年輕代 |
| 分代 | ✓ | 部分 | 現代 GC |

### 資深工程師需掌握

- 理解不同 GC 算法的權衡
- 分析 GC 日誌和性能
- 調優 GC 參數
- 編寫 GC 友好的代碼
- 處理內存洩漏
