# 死鎖原理與預防

- **難度**: 7
- **重要程度**: 5
- **標籤**: `死鎖`, `銀行家算法`, `資源分配`, `避免死鎖`

## 問題詳述

解釋死鎖產生的四個必要條件，以及如何通過破壞這些條件或使用演算法（如銀行家算法）來預防和避免死鎖。

## 核心理論與詳解

### 1. 死鎖的定義

**死鎖（Deadlock）** 是指多個進程因爭奪資源而造成的互相等待現象，若無外力干涉，這些進程都將無法繼續執行。

#### 經典案例
```
進程 P1: 持有資源 A，等待資源 B
進程 P2: 持有資源 B，等待資源 A
→ 形成循環等待，產生死鎖
```

### 2. 死鎖產生的四個必要條件

死鎖必須**同時滿足**以下四個條件：

#### (1) 互斥條件 (Mutual Exclusion)
- 資源不能被多個進程同時使用
- 一次只能分配給一個進程
- 例如：打印機、數據庫鎖

#### (2) 持有並等待 (Hold and Wait)
- 進程已持有至少一個資源
- 同時又在等待獲取其他被佔用的資源
- 不釋放已持有的資源

#### (3) 不可搶占 (No Preemption)
- 資源不能被強制奪回
- 只能由持有者主動釋放
- 例如：不能強制進程釋放鎖

#### (4) 循環等待 (Circular Wait)
- 存在進程等待鏈：P1 → P2 → ... → Pn → P1
- 形成閉環等待關係
- 例如：P1 等 P2 的資源，P2 等 P1 的資源

### 3. 死鎖的處理策略

#### 策略對比

| 策略 | 說明 | 代價 | 適用場景 |
|------|------|------|----------|
| **預防 (Prevention)** | 破壞四個必要條件之一 | 資源利用率低 | 簡單系統 |
| **避免 (Avoidance)** | 動態檢查資源分配安全性 | 需要額外計算 | 已知資源需求 |
| **檢測與恢復 (Detection)** | 允許死鎖發生後處理 | 需要回滾機制 | 死鎖罕見場景 |
| **忽略 (Ignore)** | 不處理，由用戶重啟 | 最低 | 死鎖極少發生 |

### 4. 死鎖預防 (Prevention)

通過破壞四個必要條件之一來防止死鎖發生。

#### (1) 破壞互斥條件
- **方法**：讓資源可共享
- **侷限**：很多資源無法共享（如打印機）
- **應用**：只讀文件可被多個進程同時訪問

#### (2) 破壞持有並等待
- **方法 A**：進程一次性申請所有資源
  ```
  優點：實現簡單
  缺點：資源浪費嚴重，進程可能長時間無法啟動
  ```
  
- **方法 B**：進程申請新資源前必須釋放已持有的資源
  ```
  優點：提高資源利用率
  缺點：可能導致進程重複工作，增加上下文切換
  ```

#### (3) 破壞不可搶占
- **方法**：允許搶占資源
- **實現**：
  - 若進程申請資源失敗，釋放已持有的所有資源
  - 將資源分配給更高優先級的進程
- **侷限**：只適用於易保存和恢復狀態的資源（如 CPU、內存）
- **不適用**：打印機、鎖等資源

#### (4) 破壞循環等待
- **方法**：對所有資源類型進行全局編號
- **規則**：進程必須按遞增順序申請資源
- **示例**：
  ```
  資源編號：R1=1, R2=2, R3=3
  
  ✓ 允許：P1 申請 R1 → R2 → R3
  ✗ 禁止：P1 申請 R2 → R1 (違反遞增順序)
  ```
- **優點**：實現簡單，有效
- **缺點**：限制資源訪問順序，降低靈活性

### 5. 死鎖避免 (Avoidance) - 銀行家算法

避免死鎖的核心思想是在分配資源前進行**安全性檢查**，確保系統始終處於**安全狀態**。

#### 安全狀態與不安全狀態

- **安全狀態**：存在至少一個資源分配順序，使所有進程都能完成
- **不安全狀態**：可能導致死鎖（但不一定發生）

```
安全狀態 ⊂ 無死鎖狀態
不安全狀態 ⊃ 可能死鎖
```

#### 銀行家算法 (Banker's Algorithm)

由 Dijkstra 提出，模擬銀行貸款業務。

##### 數據結構

```
系統中有 n 個進程，m 種資源

Available[m]:     當前可用資源數量
Max[n][m]:        每個進程對各類資源的最大需求
Allocation[n][m]: 每個進程已分配的資源
Need[n][m]:       每個進程還需要的資源
                  Need[i][j] = Max[i][j] - Allocation[i][j]
```

##### 算法步驟

**步驟 1：檢查請求合法性**
```
if (Request[i] > Need[i]):
    return Error("請求超過最大需求")
    
if (Request[i] > Available):
    return Wait("資源不足，進程等待")
```

**步驟 2：試探性分配**
```
Available -= Request[i]
Allocation[i] += Request[i]
Need[i] -= Request[i]
```

**步驟 3：安全性檢查**
```
Work = Available  # 工作向量
Finish[n] = false # 標記進程是否完成

while (存在 Finish[i]=false 且 Need[i] <= Work):
    Work += Allocation[i]  # 進程完成後釋放資源
    Finish[i] = true

if (所有 Finish[i] == true):
    return "安全，批准分配"
else:
    return "不安全，拒絕分配並回滾"
```

##### 實例演算

```
系統狀態：
- 3 種資源：A(10), B(5), C(7)
- 5 個進程

進程  Max(A,B,C)  Allocation(A,B,C)  Need(A,B,C)
P0    (7,5,3)     (0,1,0)            (7,4,3)
P1    (3,2,2)     (2,0,0)            (1,2,2)
P2    (9,0,2)     (3,0,2)            (6,0,0)
P3    (2,2,2)     (2,1,1)            (0,1,1)
P4    (4,3,3)     (0,0,2)            (4,3,1)

Available = (3,3,2)

安全序列檢查：
1. P1: Need(1,2,2) <= Work(3,3,2) ✓ → Finish, Work=(5,3,2)
2. P3: Need(0,1,1) <= Work(5,3,2) ✓ → Finish, Work=(7,4,3)
3. P4: Need(4,3,1) <= Work(7,4,3) ✓ → Finish, Work=(7,4,5)
4. P2: Need(6,0,0) <= Work(7,4,5) ✓ → Finish, Work=(10,4,7)
5. P0: Need(7,4,3) <= Work(10,4,7) ✓ → Finish, Work=(10,5,7)

安全序列：<P1, P3, P4, P2, P0> → 系統安全
```

##### 銀行家算法的侷限

- **需要預知最大需求**：實際系統難以預測
- **進程數和資源數固定**：動態場景不適用
- **計算開銷**：每次分配都需要安全性檢查 O(m×n²)
- **保守策略**：可能拒絕安全的請求，降低並發度

### 6. 死鎖檢測與恢復

#### 檢測方法

**資源分配圖（RAG）**
- 進程和資源用節點表示
- 邊表示請求或分配關係
- 檢測圖中是否存在環

**檢測算法（類似銀行家安全性檢查）**
```go
// 死鎖檢測偽代碼
func detectDeadlock() bool {
    Work := Available
    Finish := make([]bool, numProcesses)
    
    for {
        found := false
        for i := 0; i < numProcesses; i++ {
            if !Finish[i] && Request[i] <= Work {
                Work += Allocation[i]
                Finish[i] = true
                found = true
            }
        }
        if !found {
            break
        }
    }
    
    // 若有進程 Finish[i] == false，則該進程陷入死鎖
    for i := 0; i < numProcesses; i++ {
        if !Finish[i] {
            return true  // 檢測到死鎖
        }
    }
    return false
}
```

#### 恢復策略

1. **終止進程**
   - 終止所有死鎖進程（代價大）
   - 逐個終止直到解除死鎖（需重複檢測）
   
2. **資源搶占**
   - 選擇受害者進程
   - 回滾進程到安全狀態
   - 重新執行進程

3. **選擇標準**
   - 進程優先級
   - 已執行時間
   - 已使用資源量
   - 完成所需資源
   - 進程類型（交互式 vs 批處理）

### 7. 實際應用場景

#### 數據庫死鎖
```sql
-- 事務 T1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- T2 開始執行
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 事務 T2
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
-- 等待 T1 釋放 id=2 的鎖
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
-- 等待 T1 釋放 id=1 的鎖 → 死鎖
COMMIT;
```

**數據庫的處理**：
- 自動檢測死鎖（超時或等待圖）
- 選擇代價小的事務回滾
- 應用層需要重試邏輯

**避免方法**：
- 按固定順序訪問資源（如按 ID 升序）
- 縮小事務範圍
- 使用樂觀鎖代替悲觀鎖

#### 分佈式系統死鎖
```
服務 A 呼叫服務 B (持有資源 R1)
服務 B 呼叫服務 A (持有資源 R2)
→ 分佈式死鎖
```

**避免策略**：
- 設置 RPC 超時
- 避免循環依賴
- 使用異步消息隊列解耦
- 實現請求取消機制

#### Go 中的死鎖檢測
```go
// Go runtime 會檢測所有 goroutine 都阻塞的情況
func main() {
    ch := make(chan int)
    ch <- 1  // 阻塞：沒有接收者
    // fatal error: all goroutines are asleep - deadlock!
}
```

### 8. 最佳實踐

#### 預防死鎖的設計原則

1. **避免嵌套鎖**
   ```go
   // ✗ 危險：嵌套鎖可能導致死鎖
   mu1.Lock()
   mu2.Lock()
   // ...
   mu2.Unlock()
   mu1.Unlock()
   ```

2. **按固定順序獲取鎖**
   ```go
   // ✓ 安全：為資源定義全局順序
   func transfer(from, to *Account, amount int) {
       first, second := from, to
       if from.ID > to.ID {
           first, second = to, from
       }
       first.mu.Lock()
       defer first.mu.Unlock()
       second.mu.Lock()
       defer second.mu.Unlock()
       // 執行轉帳
   }
   ```

3. **使用超時機制**
   ```go
   // ✓ 使用 TryLock 或 timeout
   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
   defer cancel()
   
   if !mu.TryLock() {
       return ErrLockTimeout
   }
   defer mu.Unlock()
   ```

4. **減少鎖的持有時間**
   ```go
   // ✓ 只在必要時持有鎖
   mu.Lock()
   data := criticalSection()
   mu.Unlock()
   
   // 長時間計算放在鎖外
   result := heavyComputation(data)
   ```

5. **使用無鎖數據結構**
   - atomic 操作
   - lock-free 隊列
   - CAS (Compare-And-Swap)

## 實際應用場景

### 1. 操作系統進程調度
- 使用資源分配圖檢測死鎖
- 通過進程優先級決定搶占策略

### 2. 數據庫事務管理
- 等待圖算法檢測死鎖
- 自動回滾代價最小的事務
- 應用層實現重試邏輯

### 3. 分佈式鎖服務
- 設置 TTL 防止永久死鎖
- 使用 fencing token 防止鎖失效問題
- 實現死鎖檢測服務

### 4. 併發程序設計
- 遵循鎖排序原則
- 使用 channel 代替共享內存
- 實現超時和取消機制

## 總結

### 關鍵要點

1. **四個必要條件**：互斥、持有並等待、不可搶占、循環等待
2. **預防**：破壞必要條件，代價是資源利用率下降
3. **避免**：銀行家算法保證安全狀態，但需預知需求
4. **檢測與恢復**：允許死鎖發生，事後處理
5. **實踐中**：多使用超時、鎖排序、避免嵌套鎖

### 資深工程師需掌握

- 識別代碼中的潛在死鎖
- 設計無死鎖的並發系統
- 在性能和安全性之間做出權衡
- 處理分佈式環境下的死鎖問題
- 實現有效的監控和告警機制
- 掌握實際應用場景
- 能夠進行效能優化
- 熟悉相關工具和除錯方法
