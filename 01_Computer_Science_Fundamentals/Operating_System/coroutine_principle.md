# 協程原理 (Coroutine Principle)

- **難度**: 7
- **重要程度**: 5
- **標籤**: `協程`, `Coroutine`, `Goroutine`, `并發`, `用戶態線程`, `調度`

## 問題詳述

協程（Coroutine）是一種**用戶態的輕量級並發單元**，能夠在不陷入核心態的情況下實現協作式或搶占式調度，是 Go、Python asyncio、Kotlin、Lua 等語言實現高並發的核心機制。

## 核心理論與詳解

### 協程 vs 線程 vs 進程

| 比較項目 | 進程 | 線程 | 協程 |
|---------|------|------|------|
| 切換級別 | 核心態（最重） | 核心態（較重） | **用戶態（極輕）** |
| 切換開銷 | 數 ms（µs 量級） | 10-100 µs | **100 ns 以下** |
| 記憶體佔用 | 數 MB 以上 | 1-8 MB 棧 | **數 KB（Go goroutine ~2KB）** |
| 調度者 | OS 核心 | OS 核心 | **用戶態調度器** |
| 并發數量 | 百 | 千 | **百萬級** |
| 阻塞影響 | 僅自身 | 僅自身（可能影響同組） | 阻塞需讓出，其他繼續 |

### 協程的本質：棧的切換

協程的切換本質是**保存和恢復執行上下文（Execution Context）**：

- **寄存器狀態**：PC（程序計數器）、SP（棧指針）、通用寄存器
- **協程棧**：每個協程有獨立的棧空間（比線程棧小得多）

切換時：
1. 將當前協程的寄存器狀態保存到協程控制塊（CCB）
2. 從下一個協程的 CCB 恢復寄存器狀態
3. 跳轉到下一個協程的 PC 繼續執行

整個過程**在用戶態完成**，無需 syscall，這是協程比線程輕的根本原因。

### 協作式 vs 搶占式調度

**協作式調度（Cooperative Scheduling）**：
- 協程**主動讓出**（yield）CPU
- 需要協程「誠實」配合，若某協程不讓出（如死循環），會阻塞整個線程
- 早期 Python asyncio（Python 3.4-）、早期 Go（1.13 之前部分場景）

**搶占式調度（Preemptive Scheduling）**：
- 調度器可在任意時刻**強制切換**協程
- 需要特殊機制（如信號、安全點 safepoint）
- Go 1.14+ 實現了基於信號的搶占式調度，防止 goroutine 永久占用線程

### Go 的 GMP 調度模型

Go 的 goroutine 是協程的典型工業實現，採用 **GMP 模型**：

- **G（Goroutine）**：協程，包含棧、狀態和任務函數。初始棧 2KB，動態增長（最大 1GB 預設）
- **M（Machine）**：OS 線程，是實際執行的載體。M 的數量通常等於 CPU 核數（`GOMAXPROCS`）
- **P（Processor）**：邏輯處理器，持有 goroutine 本地佇列（Local Run Queue）。P 的數量 = `GOMAXPROCS`

**調度流程**：
1. G 放入 P 的本地佇列（或全局佇列）
2. M 從其綁定的 P 的本地佇列取 G 執行
3. M 阻塞時（如系統調用），P 解綁並找其他 M 繼續執行
4. 本地佇列空時進行**work stealing**：從其他 P 的佇列偷取 G

**Work Stealing 的重要性**：確保 CPU 不空轉，達到最大並行度，是 GMP 高效率的關鍵。

### 協程阻塞處理

協程的核心優勢之一是「**看起來同步，實際異步**」：

- 當 goroutine 執行 I/O（網路、文件）時，Go runtime 將 I/O 操作轉化為**非阻塞 I/O + epoll**
- epoll 就緒後，runtime 將 goroutine 重新放入調度佇列
- 對 goroutine 程序員而言，寫的是**同步代碼**（`conn.Read()`），底層是異步 I/O

這與 Python asyncio 的 `async/await` 思想相同，但 Go 對用戶完全透明，無需手動加 `await`。

### 棧增長機制

Go goroutine 棧採用**分段棧（Segmented Stack，早期）→ 連續棧（現在）** 策略：
- 初始 2KB，按需增長，最大預設 1GB
- 棧增長時，複製整個棧到更大空間（連續棧方案），更好的 CPU 快取局部性
- 棧指針更新通過 GC 中的指針掃描配合完成

### 協程的適用場景

- ✅ **I/O 密集型**：大量並發網路請求（爬蟲、API 聚合）
- ✅ **高並發服務**：HTTP 服務器、RPC 框架（每個請求一個 goroutine）
- ❌ **CPU 密集型**：計算型任務受 GIL（Python）或 `GOMAXPROCS`（Go）限制，不如多進程/多線程
