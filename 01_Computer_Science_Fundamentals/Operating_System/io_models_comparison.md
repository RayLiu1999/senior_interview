# 五種 I/O 模型對比

- **難度**: 7
- **重要程度**: 5
- **標籤**: `阻塞`, `非阻塞`, `多路復用`, `異步I/O`, `事件驅動`

## 問題詳述

深入解釋 Unix/Linux 系統中的五種 I/O 模型（阻塞 I/O、非阻塞 I/O、I/O 多路復用、信號驅動 I/O、異步 I/O）的工作原理、各自的優缺點，以及在高並發場景下如何選擇合適的 I/O 模型。

## 核心理論與詳解

### 1. I/O 操作的兩個階段

任何 I/O 操作都包含兩個階段：

```
完整的 I/O 操作:
┌──────────────────────────────────┐
│  階段 1: 等待數據準備 (Waiting) │
│   - 等待數據從設備到達內核緩衝區 │
│   - 例如: 等待網路數據包到達     │
└──────────────────────────────────┘
              ↓
┌──────────────────────────────────┐
│  階段 2: 數據拷貝 (Copying)      │
│   - 將數據從內核拷貝到用戶空間   │
│   - 例如: 從內核緩衝區拷貝到應用 │
└──────────────────────────────────┘
```

**關鍵**: 不同 I/O 模型的差異主要在於**如何處理這兩個階段**。

### 2. 模型 1: 阻塞 I/O (Blocking I/O)

#### 工作流程

```
應用進程                  內核
   |                       |
   |  read()               |
   |──────────────────────>|
   |                       | 等待數據
   |   (阻塞等待)          | ...
   |                       | 數據到達
   |                       | 拷貝數據
   |   返回數據            | 到用戶空間
   |<──────────────────────|
   | 處理數據              |
```

#### 特點

- **完全阻塞**: 應用進程在調用 `read()` 後被阻塞，直到數據準備好並拷貝完成
- **簡單直觀**: 編程模型最簡單
- **低效**: 一個線程只能處理一個連接

#### 程式碼範例

```go
// 阻塞 I/O 示例
conn, _ := net.Dial("tcp", "example.com:80")

// read() 會阻塞，直到數據到達
buffer := make([]byte, 1024)
n, _ := conn.Read(buffer)  // ← 阻塞在這裡

fmt.Println("收到數據:", string(buffer[:n]))
```

#### 優缺點

**優點**:
- ✅ 編程簡單，易於理解
- ✅ 不需要輪詢，CPU 使用率低

**缺點**:
- ❌ 一個線程只能處理一個連接
- ❌ 高並發需要大量線程 (C10K 問題)
- ❌ 線程創建和切換開銷大

### 3. 模型 2: 非阻塞 I/O (Non-blocking I/O)

#### 工作流程

```
應用進程                  內核
   |                       |
   |  read()               |
   |──────────────────────>|
   |   返回 EWOULDBLOCK    | 數據未準備好
   |<──────────────────────|
   |                       |
   |  read() (輪詢)        |
   |──────────────────────>|
   |   返回 EWOULDBLOCK    | 數據仍未準備好
   |<──────────────────────|
   |                       |
   |  read() (輪詢)        |
   |──────────────────────>|
   |   返回數據            | 數據準備好了
   |<──────────────────────|
   | 處理數據              |
```

#### 特點

- **立即返回**: `read()` 不阻塞，立即返回 (EWOULDBLOCK 或數據)
- **需要輪詢**: 應用需要不斷調用 `read()` 檢查數據是否到達
- **忙等待**: CPU 使用率高

#### 程式碼範例

```go
// 設置非阻塞模式
file, _ := os.Open("/dev/some_device")
fd := file.Fd()
syscall.SetNonblock(int(fd), true)

// 輪詢讀取
for {
    buffer := make([]byte, 1024)
    n, err := file.Read(buffer)
    
    if err == syscall.EAGAIN || err == syscall.EWOULDBLOCK {
        // 數據未準備好，繼續輪詢
        time.Sleep(10 * time.Millisecond)
        continue
    }
    
    if n > 0 {
        fmt.Println("收到數據:", string(buffer[:n]))
        break
    }
}
```

#### 優缺點

**優點**:
- ✅ 不阻塞，可以處理多個連接

**缺點**:
- ❌ 需要不斷輪詢，CPU 使用率極高
- ❌ 輪詢間隔難以控制 (太短浪費 CPU，太長延遲高)
- ❌ 實際很少單獨使用

### 4. 模型 3: I/O 多路復用 (I/O Multiplexing)

#### 工作流程

```
應用進程                  內核
   |                       |
   |  select([fd1,fd2])    |
   |──────────────────────>|
   |   (阻塞等待)          | 監視多個 fd
   |                       | fd1 有數據了
   |   返回 fd1 可讀       |
   |<──────────────────────|
   |                       |
   |  read(fd1)            |
   |──────────────────────>|
   |   (可能短暫阻塞)      | 拷貝數據
   |   返回數據            |
   |<──────────────────────|
   | 處理數據              |
```

#### 主要系統調用

**select**:
```c
int select(int nfds, fd_set *readfds, fd_set *writefds, 
           fd_set *exceptfds, struct timeval *timeout);
```

**poll**:
```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

**epoll** (Linux):
```c
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

#### 特點

- **一個線程監控多個 fd**: 解決 C10K 問題
- **阻塞在 select/poll/epoll**: 而非單個 I/O 操作
- **事件驅動**: fd 就緒時通知應用

#### 程式碼範例 (Go 的 select)

```go
// Go 使用 channel 實現類似 I/O 多路復用的模式
ch1 := make(chan string)
ch2 := make(chan string)

go func() { ch1 <- "來自通道 1" }()
go func() { ch2 <- "來自通道 2" }()

select {
case msg1 := <-ch1:
    fmt.Println(msg1)
case msg2 := <-ch2:
    fmt.Println(msg2)
case <-time.After(time.Second):
    fmt.Println("超時")
}
```

#### 優缺點

**優點**:
- ✅ 一個線程處理多個連接
- ✅ 適合高並發場景
- ✅ 無需輪詢 (相比非阻塞 I/O)

**缺點**:
- ❌ 仍然需要兩次系統調用 (select + read)
- ❌ select/poll 有 fd 數量限制和線性掃描問題
- ❌ 編程複雜度較高

### 5. 模型 4: 信號驅動 I/O (Signal-driven I/O)

#### 工作流程

```
應用進程                  內核
   |                       |
   |  sigaction(SIGIO)     |
   |──────────────────────>|
   |   立即返回            | 註冊信號處理器
   |<──────────────────────|
   |                       |
   | 執行其他操作...       |
   |                       | 數據到達
   |   發送 SIGIO 信號     |
   |<──────────────────────|
   |                       |
   | 信號處理器執行        |
   |  read()               |
   |──────────────────────>|
   |   返回數據            |
   |<──────────────────────|
```

#### 特點

- **異步通知**: 數據準備好時內核發送信號
- **第一階段異步**: 等待數據不阻塞
- **第二階段同步**: 拷貝數據仍然阻塞

#### 優缺點

**優點**:
- ✅ 等待期間可執行其他任務

**缺點**:
- ❌ 信號處理複雜
- ❌ 信號可能丟失或合併
- ❌ 實際很少使用

### 6. 模型 5: 異步 I/O (Asynchronous I/O)

#### 工作流程

```
應用進程                  內核
   |                       |
   |  aio_read()           |
   |──────────────────────>|
   |   立即返回            | 等待數據
   |<──────────────────────| ...
   |                       | 數據到達
   | 執行其他操作...       | 拷貝數據
   |                       | 到用戶空間
   |   發送信號/回調       |
   |<──────────────────────|
   | 處理數據              |
```

#### 特點

- **真正的異步**: 兩個階段都不阻塞
- **內核完成所有工作**: 包括數據拷貝
- **完成後通知應用**: 通過信號或回調

#### 程式碼範例 (Go 的異步模式)

```go
// Go 使用 goroutine 實現異步模式
func readAsync(conn net.Conn, callback func([]byte, error)) {
    go func() {
        buffer := make([]byte, 1024)
        n, err := conn.Read(buffer)  // 在 goroutine 中阻塞
        callback(buffer[:n], err)     // 完成後回調
    }()
}

// 使用
conn, _ := net.Dial("tcp", "example.com:80")
readAsync(conn, func(data []byte, err error) {
    if err == nil {
        fmt.Println("收到數據:", string(data))
    }
})

// 主線程可以繼續執行其他任務
fmt.Println("可以執行其他操作...")
```

#### Linux AIO

```c
// Linux 原生 AIO
struct aiocb cb;
memset(&cb, 0, sizeof(cb));
cb.aio_fildes = fd;
cb.aio_buf = buffer;
cb.aio_nbytes = sizeof(buffer);

// 發起異步讀取
aio_read(&cb);

// 繼續執行其他操作...

// 檢查是否完成
while (aio_error(&cb) == EINPROGRESS) {
    // 執行其他任務
}

// 獲取結果
ssize_t ret = aio_return(&cb);
```

#### 優缺點

**優點**:
- ✅ 真正的異步，兩階段都不阻塞
- ✅ 最高效的 I/O 模型
- ✅ 適合高並發高吞吐場景

**缺點**:
- ❌ 實現複雜
- ❌ Linux AIO 支援有限 (主要針對文件 I/O)
- ❌ 跨平台支援不統一

### 7. 五種模型對比

| 模型 | 等待數據 | 拷貝數據 | 並發能力 | CPU 使用 | 編程複雜度 |
|-----|---------|---------|---------|---------|-----------|
| **阻塞 I/O** | 阻塞 | 阻塞 | ⭐ | 低 | 簡單 |
| **非阻塞 I/O** | 輪詢 | 阻塞 | ⭐⭐ | 極高 | 中等 |
| **I/O 多路復用** | 阻塞 (select/epoll) | 阻塞 | ⭐⭐⭐⭐⭐ | 低 | 中等 |
| **信號驅動 I/O** | 異步 (信號通知) | 阻塞 | ⭐⭐⭐ | 低 | 複雜 |
| **異步 I/O** | 異步 | 異步 | ⭐⭐⭐⭐⭐ | 低 | 複雜 |

### 8. 同步 vs 異步、阻塞 vs 非阻塞

#### 概念澄清

```
同步 vs 異步 (關注消息通信機制)
┌───────────────────────────────────┐
│ 同步: 調用者主動等待結果          │
│   - 阻塞 I/O                      │
│   - 非阻塞 I/O (輪詢)             │
│   - I/O 多路復用                  │
│                                   │
│ 異步: 被調用者通知結果            │
│   - 異步 I/O (真正異步)           │
│   - 信號驅動 I/O (部分異步)       │
└───────────────────────────────────┘

阻塞 vs 非阻塞 (關注調用時的狀態)
┌───────────────────────────────────┐
│ 阻塞: 調用時掛起，直到操作完成    │
│   - 阻塞 I/O                      │
│                                   │
│ 非阻塞: 調用立即返回              │
│   - 非阻塞 I/O                    │
│   - I/O 多路復用 (阻塞在 select)  │
│   - 異步 I/O                      │
└───────────────────────────────────┘
```

### 9. 實際應用場景

#### 高並發 Web 伺服器

**Nginx**: I/O 多路復用 (epoll)
```
單個 Worker 進程:
  epoll_wait 監聽數千個連接
  連接就緒 → 處理請求
  非阻塞 I/O → 繼續監聽其他連接
```

**Node.js**: 異步 I/O + 事件循環
```
單線程事件循環:
  發起異步 I/O (libuv)
  繼續處理其他事件
  I/O 完成 → 回調執行
```

#### 高性能數據庫

**Redis**: I/O 多路復用 (epoll)
```
單線程 + epoll:
  監聽多個客戶端連接
  命令就緒 → 處理命令
  快速返回，繼續監聽
```

#### 文件操作

**大文件讀寫**: 異步 I/O
```
發起 aio_read
處理其他任務
完成時獲取數據
```

### 10. Go 的 I/O 模型

Go 在底層使用 **I/O 多路復用 (epoll/kqueue)**，但對開發者提供**同步阻塞的編程接口**。

```go
// 看起來是同步阻塞
conn, _ := net.Dial("tcp", "example.com:80")
data, _ := ioutil.ReadAll(conn)  // "阻塞"

// 實際上:
// 1. Read 操作會將 goroutine 掛起
// 2. Go runtime 使用 epoll 監聽 fd
// 3. fd 就緒時喚醒 goroutine
// 4. 其他 goroutine 繼續執行
```

**優勢**:
- ✅ 同步編程模型 (易理解)
- ✅ 底層高效 I/O 多路復用
- ✅ 輕量級 goroutine (可創建百萬級)

### 11. 實務最佳實踐

#### 選擇 I/O 模型

**阻塞 I/O**:
- ✅ 簡單應用、低並發
- ❌ 高並發場景

**I/O 多路復用**:
- ✅ 高並發 (C10K+)
- ✅ 生產環境首選 (Nginx, Redis)

**異步 I/O**:
- ✅ 超高並發、低延遲要求
- ❌ 實現複雜，跨平台支援有限

#### 性能優化

1. **減少系統調用**:
   - 批量讀寫
   - 使用 writev/readv
   
2. **零拷貝**:
   - sendfile (Linux)
   - mmap + write

3. **邊緣觸發 vs 水平觸發**:
   - epoll ET (邊緣): 效率高，需一次讀完
   - epoll LT (水平): 簡單，可多次讀

## 總結

五種 I/O 模型是理解高性能網路編程的基礎：

1. **阻塞 I/O**: 最簡單，但並發能力差
2. **非阻塞 I/O**: 需要輪詢，CPU 浪費嚴重
3. **I/O 多路復用**: 高並發首選，實際最常用
4. **信號驅動 I/O**: 很少使用，實現複雜
5. **異步 I/O**: 真正異步，效率最高但支援有限

作為資深後端工程師，你需要：
- 深入理解每種 I/O 模型的工作原理
- 能夠根據場景選擇合適的模型
- 掌握 epoll/select/poll 的使用和優化
- 理解現代框架 (Go, Node.js) 的 I/O 機制
- 能夠設計和實現高並發系統
