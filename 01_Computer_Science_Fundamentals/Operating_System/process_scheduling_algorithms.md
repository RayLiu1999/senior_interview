# 進程調度算法

- **難度**: 6
- **重要程度**: 4
- **標籤**: `FCFS`, `SJF`, `優先級調度`, `時間片輪轉`, `多級反饋隊列`

## 問題詳述

解釋操作系統中的進程調度算法，包括先來先服務（FCFS）、最短作業優先（SJF）、優先級調度、時間片輪轉（RR）、多級反饋隊列（MLFQ），以及現代調度器（如 Linux CFS）的設計。

## 核心理論與詳解

### 1. 調度目標

不同系統的調度目標不同：

**批處理系統**：
- 吞吐量（Throughput）：單位時間完成的作業數
- 周轉時間（Turnaround Time）：作業提交到完成的時間
- CPU 利用率：盡量保持 CPU 忙碌

**交互式系統**：
- 響應時間（Response Time）：請求到首次響應的時間
- 公平性（Fairness）：所有進程獲得合理的 CPU 時間

**實時系統**：
- 截止時間（Deadline）：必須在規定時間內完成
- 可預測性（Predictability）：行為確定

### 2. 經典調度算法

#### (1) 先來先服務（FCFS - First-Come, First-Served）

**原理**：按進程到達順序執行，非搶占式

```
進程隊列：P1 → P2 → P3

時間軸：
|--- P1 ---|--- P2 ---|--- P3 ---|
0         10        15        20

P1: 到達0，執行10ms，周轉時間=10
P2: 到達0，執行5ms，周轉時間=15（等10ms）
P3: 到達0，執行5ms，周轉時間=20（等15ms）
平均周轉時間 = (10+15+20)/3 = 15ms
```

**優點**：
- 實現簡單
- 公平（先到先得）

**缺點**：
- 護航效應（Convoy Effect）：短作業等待長作業
- 平均周轉時間長
- 不適合交互式系統

#### (2) 最短作業優先（SJF - Shortest Job First）

**原理**：選擇執行時間最短的進程，非搶占式

```
進程：P1(10ms), P2(5ms), P3(2ms)

執行順序：P3 → P2 → P1

時間軸：
|-- P3 --|---- P2 ----|---------- P1 ----------|
0       2            7                        17

平均周轉時間 = (2+7+17)/3 = 8.67ms
（優於 FCFS 的 15ms）
```

**優點**：
- 最優化平均周轉時間（理論最優）
- 減少等待時間

**缺點**：
- 需預知執行時間（實際難以實現）
- 長作業可能飢餓

**變種：最短剩餘時間優先（SRTF）**
- 搶占式 SJF
- 新進程到達時，若剩餘時間更短則搶占

#### (3) 優先級調度（Priority Scheduling）

**原理**：每個進程有優先級，選擇優先級最高的執行

```
進程：P1(優先級3), P2(優先級1), P3(優先級4), P4(優先級2)

執行順序（數字越小優先級越高）：
P2 → P4 → P1 → P3
```

**靜態優先級**：
- 進程創建時確定，不再改變
- 簡單但不靈活

**動態優先級**：
- 根據行為調整（如等待時間、CPU 使用量）
- 避免飢餓問題

**優先級反轉問題**：
```
高優先級任務 H 等待低優先級任務 L 釋放資源
中優先級任務 M 搶占 L
→ H 被 M 間接阻塞

解決：優先級繼承（L 臨時繼承 H 的優先級）
```

#### (4) 時間片輪轉（RR - Round Robin）

**原理**：每個進程分配固定時間片，用完後放到隊列尾部

```
進程：P1(10ms), P2(5ms), P3(8ms)
時間片：4ms

執行序列：
P1(4) → P2(4) → P3(4) → P1(4) → P2(1) → P3(4) → P1(2)

時間軸：
|--P1--|--P2--|--P3--|--P1--|P2|--P3--|P1|
0     4     8    12    16  17   21   23
```

**時間片選擇**：
- 太大：退化為 FCFS
- 太小：上下文切換開銷大

**典型值**：10-100ms

**優點**：
- 公平
- 響應時間好（交互式系統）

**缺點**：
- 周轉時間較長
- 頻繁上下文切換

#### (5) 多級反饋隊列（MLFQ - Multi-Level Feedback Queue）

**原理**：多個隊列，不同優先級和時間片，進程根據行為在隊列間移動

```
優先級高 → 低，時間片小 → 大：

隊列 Q0: 優先級3，時間片 8ms   ← 新進程
隊列 Q1: 優先級2，時間片 16ms
隊列 Q2: 優先級1，FCFS

規則：
1. 新進程進入 Q0
2. 時間片用完 → 降級到下一隊列
3. I/O 等待後返回 → 提升優先級（可選）
4. 長時間未執行 → 提升優先級（防止飢餓）
```

**自適應特性**：
- I/O 密集型任務：頻繁等待 I/O，保持高優先級（低延遲）
- CPU 密集型任務：長時間使用 CPU，降到低優先級（大時間片）

**優點**：
- 平衡響應時間和周轉時間
- 自動適應進程行為
- 廣泛應用

**缺點**：
- 複雜
- 參數調優困難

### 3. 現代調度器

#### Linux CFS（Completely Fair Scheduler）

**核心思想**：理想情況下，每個進程獲得相等的 CPU 時間

**虛擬運行時間（vruntime）**：
```
vruntime = 實際運行時間 × (NICE_0_LOAD / 進程權重)

權重取決於 nice 值：
nice -20: 最高優先級，權重大
nice   0: 默認
nice +19: 最低優先級，權重小

總是選擇 vruntime 最小的進程運行
```

**紅黑樹實現**：
```
      [進程B: vruntime=150]
     /                    \
[進程A:100]           [進程C:200]

選擇最左節點（vruntime 最小）運行
插入/刪除：O(log n)
```

**時間片動態計算**：
```
時間片 = 調度週期 × (進程權重 / 所有進程權重總和)

示例：
調度週期 = 48ms
3個進程，權重相等
每個進程時間片 = 48/3 = 16ms
```

**優點**：
- 真正公平
- 響應快（選擇 O(log n)）
- 自動負載均衡（多核）

#### Go 調度器（GMP 模型）

```
G (Goroutine): 用戶態輕量級線程
M (Machine): 系統線程
P (Processor): 調度上下文（邏輯處理器）

每個 P 有本地隊列：
P1: [G1, G2, G3]
P2: [G4, G5]
全局隊列: [G6, G7, ...]

調度策略：
1. 優先從本地隊列取 G
2. 本地隊列空 → 檢查全局隊列
3. 全局隊列空 → 偷取其他 P 的 G（Work Stealing）
```

**搶占式調度**：
- Go 1.14+：基於信號的異步搶占
- 避免長時間運行的 goroutine 餓死其他

### 4. 實時調度

#### 速率單調（RM - Rate Monotonic）

- 靜態優先級
- 週期越短，優先級越高
- 最優靜態調度算法

#### 最早截止時間優先（EDF - Earliest Deadline First）

- 動態優先級
- 截止時間越近，優先級越高
- 最優動態調度算法

**可調度性判定**：
```
n個任務，執行時間 C_i，週期 T_i

CPU 利用率 U = Σ(C_i / T_i)

RM: U ≤ n(2^(1/n) - 1)
EDF: U ≤ 1
```

## 實際應用場景

### 1. 服務器負載均衡
- Nginx：多進程 + epoll
- HAProxy：事件驅動調度

### 2. 容器調度
- Kubernetes：優先級 + 資源配額
- Docker：CFS 或自定義 cgroups

### 3. 數據庫
- MySQL 線程池：優先級隊列
- PostgreSQL：進程模型 + 操作系統調度

## 總結

### 算法選擇

| 場景 | 推薦算法 |
|------|----------|
| 批處理 | SJF / SRTF |
| 交互式 | RR / MLFQ |
| 實時系統 | RM / EDF |
| 通用系統 | MLFQ / CFS |

### 關鍵指標

- **響應時間**：首次響應延遲（交互式關鍵）
- **周轉時間**：完成總時間（批處理關鍵）
- **吞吐量**：單位時間完成數（服務器關鍵）
- **公平性**：資源分配均衡

### 資深工程師需掌握

- 理解各調度算法的適用場景
- 分析系統瓶頸（CPU-bound vs I/O-bound）
- 調優調度參數（nice、cgroups、ionice）
- 設計應用層調度器（任務隊列、線程池）
- 理解多核調度和負載均衡
