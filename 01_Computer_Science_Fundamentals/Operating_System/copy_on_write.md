# Copy-on-Write (COW) 機制

- **難度**: 6
- **重要程度**: 4
- **標籤**: `Copy-on-Write`, `COW`, `Fork`, `記憶體優化`, `寫時複製`

## 問題詳述

Copy-on-Write（寫時複製，COW）是一種**延遲複製**的優化策略：多個調用者共享同一份資源，只有當某方嘗試**修改**時，才真正複製出一份私有副本。COW 廣泛應用於 OS 的進程 fork、Redis 的 RDB 快照，以及各種語言的字串和容器實現。

## 核心理論與詳解

### 核心思想

COW 的出發點是：**大多數情況下，共享的資料只讀不寫**。因此：
- **讀時**：直接共享同一份物理記憶體，無需複製（零成本）
- **寫時**：才真正複製出私有副本，然後修改副本（延遲至必要時）

這樣，若寫操作從未發生（或只有部分範圍被修改），整體記憶體和時間開銷大幅降低。

### OS 中的 COW：Fork 優化

這是 COW 最典型的應用場景。

**傳統 fork 的問題**：
- `fork()` 創建子進程時，需要複製父進程的整個地址空間（棧、堆、代碼段）
- 若父進程佔用 1GB 記憶體，複製操作本身就需要 1GB 時間和空間
- 但實際上 `fork()` 後通常緊接著 `exec()`（替換為新程序），複製的記憶體幾乎沒有被用到

**COW 的 fork 優化**：
1. `fork()` 時，不立即複製物理記憶體頁，只複製頁表（Page Table）
2. 父子進程共享同一份物理記憶體頁，頁表項標記為**只讀**
3. 當任一進程（父或子）試圖**寫入**某頁：
   - CPU 觸發**缺頁中斷（Page Fault）**
   - OS 捕獲中斷，複製該頁的物理記憶體
   - 更新寫入進程的頁表，指向新頁
   - 恢復寫操作

**效益**：
- `fork()` 的速度從 O(address_space_size) 降至 O(page_table_size)（通常快數百倍）
- 只有真正被修改的頁才會被複製（最優化）

### OS 中的 COW：Redis RDB 快照

Redis 在生成 RDB 持久化快照時大量依賴 Linux COW：

1. Redis 主進程調用 `fork()` 創建子進程（利用 COW，快速且低成本）
2. 子進程遍歷記憶體資料，將快照寫入磁碟（繼承父進程的記憶體頁，只讀訪問）
3. 父進程繼續處理用戶請求（正常寫操作）
4. 父進程修改某個 key 時，OS COW 機制為父進程複製出該頁的副本
5. 子進程始終看到 fork 時刻的「凍結」快照（原始頁未被修改）

**重要影響**：
- 在 RDB 生成期間，若 Redis 寫入量大，會有大量 COW 複製，導致記憶體倍增（最壞 2x）
- 這是 Redis 的 `rdb_last_cow_size` 指標需要監控的原因

### 語言層面的 COW

**Python 字串是不可變的，因此天然不需要 COW**（共享即安全）。

**Rust 的 `Cow<T>` 類型**：
```rust
// Borrowed（不複製）或 Owned（複製後擁有所有權）
use std::borrow::Cow;
fn process(input: Cow<str>) { /* ... */ }
```

**Linux 的 `tmpfs` 與 COW 文件系統**：
- `btrfs`、`ZFS` 使用 COW 實現**快照**（Snapshot）、**克隆**（Clone）功能
- 寫入不覆蓋原始塊，而是寫到新塊，指針更新後原始塊保留 → 快照幾乎零成本

### Docker 層與 COW

Docker 映像由多個**只讀層**疊加，容器啟動時在頂部加一個**可寫層**（COW 語意）：

```
容器可寫層（Container Layer）  ← 所有寫操作發生在此
映像層 N（Image Layer N）      ← 唯讀
映像層 N-1（Image Layer N-1）  ← 唯讀
...
基礎層（Base Layer）           ← 唯讀
```

當容器修改一個來自只讀層的文件：
1. 從只讀層複製文件到可寫層（Copy-up）
2. 在可寫層修改文件副本

**效益**：多個容器共享同一個映像的只讀層，節省大量磁碟空間和記憶體（頁快取可共享）。OverlayFS 是 Docker 的預設儲存驅動，實現了這一 COW 語意。

### COW 的限制與代價

- **頁錯誤開銷**：每次 COW 觸發一次缺頁中斷 + 頁複製（微秒級），密集寫入場景代價積累
- **記憶體峰值**：複製期間記憶體短暫翻倍（如 Redis RDB 期間）
- **假共享問題**：同一記憶體頁中不同字段被不同進程修改，導致整頁複製但實際只有小部分被修改
