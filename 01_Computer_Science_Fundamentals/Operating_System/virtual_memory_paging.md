# 虛擬內存與分頁機制

- **難度**: 6
- **重要程度**: 5
- **標籤**: `虛擬內存`, `分頁`, `TLB`, `缺頁中斷`, `頁表`

## 問題詳述

解釋虛擬內存的工作原理，包括地址轉換、分頁機制、TLB（轉換後備緩衝區）、缺頁中斷處理，以及為什麼虛擬內存對現代操作系統至關重要。

## 核心理論與詳解

### 1. 虛擬內存的概念與優勢

#### 什麼是虛擬內存

**虛擬內存（Virtual Memory）** 是一種內存管理技術，為每個進程提供獨立的、連續的虛擬地址空間，映射到物理內存（RAM）和磁盤（Swap）。

```
進程看到的虛擬地址空間 (連續的):
[0x00000000 - 0xFFFFFFFF]  (32位系統)

實際物理內存 (分散的):
RAM: [片段1][片段2]...[片段N]
Disk: [交換區]
```

#### 核心優勢

1. **進程隔離**
   - 每個進程有獨立的地址空間
   - 無法訪問其他進程的內存
   - 提高安全性和穩定性

2. **突破物理內存限制**
   - 虛擬地址空間 > 物理內存大小
   - 32位系統：4GB 虛擬空間（即使只有 512MB RAM）
   - 64位系統：理論上 16EB（實際受限於硬件）

3. **簡化內存管理**
   - 進程看到連續的地址空間
   - 底層可以是非連續的物理頁
   - 方便編譯器和開發者

4. **高效利用內存**
   - 只加載需要的部分（按需分頁）
   - 不常用的頁可交換到磁盤
   - 支持內存超額分配（Overcommit）

5. **共享內存**
   - 多個進程可映射同一物理頁
   - 共享庫只需一份物理拷貝
   - 寫時複製（COW）優化

### 2. 地址轉換機制

#### 虛擬地址 → 物理地址

```
虛擬地址 (Virtual Address)
    ↓
[MMU (內存管理單元)]
    ↓
物理地址 (Physical Address)
    ↓
實際訪問 RAM
```

#### 分頁式地址轉換

虛擬地址分為兩部分：
```
┌─────────────┬────────────┐
│ 頁號 (VPN)  │ 頁內偏移量  │
└─────────────┴────────────┘
   高位         低位

例如 (4KB 頁大小，32位地址):
32位地址 = 20位VPN + 12位偏移
```

**轉換步驟**：
1. 從虛擬地址中提取 **頁號 (VPN, Virtual Page Number)**
2. 查詢 **頁表 (Page Table)** 獲取 **物理頁框號 (PFN, Physical Frame Number)**
3. 將 PFN 與頁內偏移量組合成物理地址
4. 訪問物理內存

```
虛擬地址: 0x00012ABC
├─ VPN: 0x00012 (頁號)
└─ Offset: 0xABC (偏移)

查頁表: VPN 0x00012 → PFN 0x00045

物理地址: 0x00045ABC
├─ PFN: 0x00045
└─ Offset: 0xABC (不變)
```

### 3. 頁表結構

#### 單級頁表

```
虛擬頁號 (VPN)
     ↓
┌──────────────┐
│   頁表入口   │ → PFN + 權限位
│   (PTE)      │
└──────────────┘
```

**頁表入口（PTE, Page Table Entry）** 包含：
- **PFN (物理頁框號)**：指向實際物理頁
- **Valid 位**：頁是否在內存中
- **Present 位**：是否已分配
- **權限位**：R (讀) / W (寫) / X (執行)
- **Dirty 位**：頁是否被修改過
- **Accessed 位**：是否被訪問過

#### 多級頁表

單級頁表問題：
- 32位系統，4KB頁，需要 2^20 個 PTE
- 每個 PTE 4 字節 → 4MB 頁表
- 每個進程都需要 → 內存浪費嚴重

**解決方案：多級頁表（節省空間）**

以二級頁表為例：
```
虛擬地址分解:
┌────────┬────────┬──────────┐
│ Dir    │ Table  │  Offset  │
│ (10位) │ (10位) │  (12位)  │
└────────┴────────┴──────────┘

一級頁表 (頁目錄)
     ↓
二級頁表
     ↓
物理頁框
```

**優點**：
- 只為使用的地址空間分配頁表
- 大部分進程只使用少量虛擬空間
- 典型進程可能只需要幾個二級頁表

**x86-64 的四級頁表**：
```
48位虛擬地址 (實際使用)
┌───┬───┬───┬───┬────────┐
│PML4│PDP│PD │PT │ Offset │
│ 9位│9位│9位│9位│  12位  │
└───┴───┴───┴───┴────────┘

PML4: Page Map Level 4
PDP: Page Directory Pointer
PD: Page Directory
PT: Page Table
```

### 4. TLB (Translation Lookaside Buffer)

#### 為什麼需要 TLB

每次內存訪問都查頁表開銷太大：
```
訪問虛擬地址 0x12345678:
1. 訪問內存讀取頁表 (第1次內存訪問)
2. 訪問內存讀取實際數據 (第2次內存訪問)
→ 性能降低 50%

四級頁表更糟：需要 5 次內存訪問！
```

#### TLB 是什麼

**TLB** 是一個高速緩存，存儲最近使用的 VPN → PFN 映射。

```
CPU → TLB (硬件緩存) → 頁表 (內存) → 物理內存
       ↑ 命中：極快
              ↓ 未命中：需訪問頁表
```

#### TLB 工作流程

```
1. CPU 發出虛擬地址
2. 查詢 TLB
   ├─ 命中 (TLB Hit): 直接獲取 PFN → 訪問物理內存
   └─ 未命中 (TLB Miss): 
       ├─ 硬件 TLB 處理 (x86): MMU 自動查頁表並更新 TLB
       └─ 軟件 TLB 處理 (MIPS): 觸發異常，OS 查頁表
```

#### TLB 性能影響

**命中率示例**：
```
TLB 訪問時間: 1 個 cycle
內存訪問時間: 100 cycles
TLB 命中率: 95%

平均訪問時間 = 0.95 × 1 + 0.05 × (100 + 1) = 6 cycles
若無 TLB: 100 + 100 = 200 cycles

性能提升: ~33 倍
```

#### TLB 失效（Invalidation）

需要刷新 TLB 的情況：
- **上下文切換**：切換進程時（不同的虛擬地址空間）
- **頁表修改**：mprotect、munmap 等系統調用
- **顯式刷新**：invlpg 指令（x86）

**優化：ASID (Address Space Identifier)**
```
TLB 條目: [ASID | VPN | PFN | Flags]

無需刷新整個 TLB，每個進程有唯一 ASID
上下文切換時只需切換 ASID，避免 TLB 抖動
```

### 5. 缺頁中斷 (Page Fault)

#### 觸發條件

當訪問的虛擬頁不在物理內存中時：
1. **頁未分配**：訪問從未使用的地址
2. **頁被交換出去**：在 Swap 分區
3. **權限錯誤**：寫只讀頁
4. **訪問無效地址**：段錯誤 (Segmentation Fault)

#### 處理流程

```
1. CPU 檢測到缺頁 (PTE.Valid = 0)
   ↓
2. 觸發 Page Fault 異常
   ↓
3. 保存現場（寄存器、PC）
   ↓
4. 陷入內核態，執行缺頁中斷處理程序
   ↓
5. 判斷缺頁類型:
   ├─ 合法訪問：分配物理頁 / 從磁盤加載頁
   │   ├─ 選擇一個空閒頁框
   │   ├─ 若無空閒頁框 → 頁面置換 (Page Replacement)
   │   ├─ 從磁盤讀取頁內容 (若需要)
   │   └─ 更新頁表 (PTE.Valid = 1)
   └─ 非法訪問：發送 SIGSEGV 信號
   ↓
6. 恢復現場，重新執行觸發缺頁的指令
```

#### 缺頁類型

**Major Page Fault (重大缺頁)**：
- 需要從磁盤讀取數據
- 耗時長（毫秒級）
- 例如：首次訪問文件映射、Swap In

**Minor Page Fault (次要缺頁)**：
- 頁在內存中，只需調整頁表
- 耗時短（微秒級）
- 例如：Copy-on-Write、首次訪問已映射頁

### 6. 頁面置換算法

當內存不足時，需要選擇一個頁交換到磁盤。

#### FIFO (First-In-First-Out)

- 最簡單：淘汰最早加載的頁
- 問題：可能淘汰常用頁
- Belady 異常：增加頁框反而增加缺頁率

#### LRU (Least Recently Used)

- 淘汰最久未使用的頁
- 效果好，但實現代價高
- 需要記錄每次訪問時間

**近似 LRU：Clock 算法**
```
頁框組織成環形鏈表
每個頁有 Accessed 位

指針掃描頁框:
├─ Accessed = 1: 清零，繼續掃描
└─ Accessed = 0: 選中置換

硬件每次訪問時自動設置 Accessed = 1
```

#### LFU (Least Frequently Used)

- 淘汰訪問次數最少的頁
- 問題：早期頻繁訪問的頁難以淘汰

#### Working Set 算法

- 保留進程的工作集（近期使用的頁集合）
- 避免 Thrashing（顛簸）

### 7. Demand Paging (按需分頁)

#### 核心思想

**不預先加載，只在需要時加載頁**

```
進程啟動時:
[代碼] [數據] [堆] [棧]
   ↓      ↓     ↓    ↓
  未加載 未加載 未加載 未加載

執行過程中逐漸加載:
[已加載][未加載][已加載][已加載]
```

#### 優勢

- **快速啟動**：無需加載整個程序
- **節省內存**：只加載實際使用的部分
- **支持大程序**：程序大小可超過物理內存

#### Copy-on-Write (COW)

**fork() 優化**：
```
父進程 fork() 子進程:
┌────────┐           ┌────────┐
│ 父進程 │           │ 子進程 │
└────────┘           └────────┘
    ↓                    ↓
  [物理頁] ← 共享只讀映射
    
任一進程寫入時:
1. 觸發 Page Fault (寫只讀頁)
2. 複製物理頁
3. 修改頁表指向新頁
4. 設置為可寫
```

**優勢**：
- fork 時無需複製所有內存
- 只複製被修改的頁
- 大幅提升 fork 性能

### 8. 內存映射文件 (mmap)

#### 基本原理

將文件直接映射到進程虛擬地址空間：
```
int fd = open("file.txt", O_RDWR);
void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, 
                 MAP_SHARED, fd, 0);

// 直接通過指針訪問文件
ptr[0] = 'A';  // 修改文件內容

munmap(ptr, size);
```

#### 優勢

1. **高效 I/O**
   - 避免 read/write 的拷貝開銷
   - 直接通過 CPU cache 訪問

2. **共享內存**
   - 多進程可映射同一文件
   - MAP_SHARED 實現進程間通信

3. **Lazy Loading**
   - 按需加載文件內容（缺頁中斷觸發）
   - 適合大文件處理

#### 應用場景

- 數據庫系統（如 MongoDB 的 MMAPv1 引擎）
- 共享庫加載
- 進程間共享內存
- 大文件處理

### 9. Swapping (交換)

#### Swap 空間

當物理內存不足時，將不活躍的頁寫入磁盤：
```
RAM (物理內存):
[活躍頁][活躍頁][活躍頁]

Swap (磁盤):
[不活躍頁][不活躍頁][...]
```

#### Swap 策略

**kswapd (Linux 內核線程)**：
- 監控空閒內存
- 低於閾值時開始回收頁
- 優先回收 Page Cache
- 最後回收匿名頁（進程內存）

**Swappiness 參數**：
```bash
# 查看
cat /proc/sys/vm/swappiness

# 設置 (0-100)
echo 10 > /proc/sys/vm/swappiness

# 0: 盡量不 swap
# 100: 積極 swap
```

#### Thrashing (顛簸)

當系統頻繁 Swap In/Out，導致：
- CPU 時間主要用於頁面置換
- 程序幾乎無法執行
- 系統接近癱瘓

**解決方法**：
- 增加物理內存
- 減少並發進程數
- 優化程序內存使用
- 調整 Working Set 大小

### 10. Huge Pages (大頁)

#### 為什麼需要

標準頁大小 4KB 的問題：
- 大內存應用需要大量 PTE
- TLB 覆蓋範圍小（例如 64 個 TLB 條目 × 4KB = 256KB）
- TLB Miss 頻繁

#### Huge Pages 優勢

```
標準頁: 4KB
Huge Page: 2MB (x86-64)
Giant Page: 1GB

TLB 覆蓋範圍提升 512 倍！
```

**性能提升**：
- 數據庫（如 PostgreSQL、Oracle）
- 虛擬機（KVM）
- 大內存科學計算

#### 使用方式

**靜態 Huge Pages**：
```bash
# 配置
echo 1024 > /proc/sys/vm/nr_hugepages

# 掛載
mount -t hugetlbfs none /mnt/hugepages

# 程序申請
mmap(..., MAP_HUGETLB, ...);
```

**透明 Huge Pages (THP)**：
```bash
# 啟用
echo always > /sys/kernel/mm/transparent_hugepage/enabled

# 內核自動合併小頁為大頁
# 無需修改程序代碼
```

## 實際應用場景

### 1. 數據庫系統
- 使用 mmap 映射數據文件
- 啟用 Huge Pages 減少 TLB Miss
- 調整 Swappiness 避免 Swap

### 2. 容器技術
- 每個容器有獨立的虛擬地址空間
- 使用頁表實現內存隔離
- Copy-on-Write 優化鏡像存儲

### 3. Java 虛擬機
- 堆內存通過 mmap 分配
- G1 GC 使用分區管理（類似分頁）
- JIT 編譯器需要可執行頁（RWX 權限）

### 4. Redis
- 使用 fork + COW 實現 RDB 持久化
- 子進程快照父進程內存
- 父進程繼續處理寫請求

## 總結

### 關鍵概念

1. **虛擬內存提供抽象**：每個進程獨立的連續地址空間
2. **分頁實現映射**：虛擬頁 → 物理頁框
3. **TLB 加速轉換**：緩存最近的地址映射
4. **缺頁中斷處理**：按需加載頁、頁面置換
5. **Swap 擴展容量**：使用磁盤作為擴展內存

### 性能優化

- 提高 TLB 命中率（使用 Huge Pages）
- 減少缺頁中斷（預加載、優化訪問模式）
- 避免 Thrashing（控制進程數、增加內存）
- 使用 mmap 減少拷貝
- 合理配置 Swappiness

### 資深工程師需掌握

- 理解虛擬內存如何影響程序性能
- 分析內存訪問模式和缺頁行為
- 使用工具診斷內存問題（如 vmstat、/proc/pid/maps）
- 針對不同應用場景調優內存參數
- 理解容器和虛擬化中的內存管理
