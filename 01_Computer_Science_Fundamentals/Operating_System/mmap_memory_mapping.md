# mmap 記憶體映射 (Memory-Mapped Files)

- **難度**: 7
- **重要程度**: 4
- **標籤**: `mmap`, `記憶體映射`, `零拷貝`, `IPC`, `高效能I/O`

## 問題詳述

`mmap`（Memory Map）是一種將**文件或設備映射到進程虛擬地址空間**的機制，使得對文件的讀寫可以像訪問記憶體一樣直接進行指針操作，同時避免傳統 `read()/write()` 系統調用中的多次數據拷貝。

## 核心理論與詳解

### 傳統 I/O 的問題：多次拷貝

在傳統 `read()` 系統調用路徑中，數據需要多次拷貝：

```
磁碟
 ↓ DMA 拷貝
核心頁快取（Page Cache）
 ↓ CPU 拷貝（核心態→用戶態）
用戶緩衝區（User Buffer）
 ↓ CPU 拷貝（用戶態→核心態）
Socket 緩衝區
 ↓ DMA 拷貝
網卡
```

每次 `read()` / `write()` 都會：
1. 發生一次**系統調用**（用戶態↔核心態切換，昂貴）
2. 發生**記憶體拷貝**（核心頁快取 ↔ 用戶緩衝區）

### mmap 的工作原理

`mmap` 在進程虛擬地址空間中**保留一段地址範圍**，並與文件的頁快取（Page Cache）建立映射關係：

```
文件（磁碟）
 ↓ DMA（缺頁時按需加載）
核心頁快取（Page Cache）
 ↑↓ 直接映射（無拷貝！）
進程虛擬地址空間（mmap 區域）
```

1. 調用 `mmap()`：OS 在進程虛擬空間分配一段地址，建立與文件的映射（初始不加載數據）
2. 訪問該地址範圍：觸發**缺頁中斷（Page Fault）**，OS 從磁碟加載文件頁到 Page Cache
3. 讀/寫該地址 = 直接讀/寫 Page Cache，**無需拷貝到用戶緩衝區**
4. 修改的頁標記為 Dirty，由 OS 在適當時機flush回磁碟（或手動調用 `msync()`）

### mmap 的優勢

**① 減少拷貝次數（「零拷貝」的一種形式）**
- 傳統 read：磁碟 → Page Cache → 用戶 Buffer（2次拷貝）
- mmap：磁碟 → Page Cache（1次，用戶直接訪問 Page Cache）

**② 減少系統調用開銷**
- 傳統方式：每次 read/write 都是系統調用
- mmap 後：直接記憶體操作，只有缺頁中斷的開銷（且一旦頁加載後，後續訪問無中斷）

**③ 多進程共享記憶體（IPC）**
- 多個進程 mmap 同一文件時，OS 保證它們映射到**同一份物理 Page Cache**
- 一個進程的修改對另一個進程立刻可見（無需管道或消息佇列）

**④ 大文件隨機訪問**
- 只加載被訪問的頁，不需要將整個文件讀入記憶體
- 適合大型索引文件、資料庫文件

### 典型使用場景

| 場景 | 說明 |
|------|------|
| **資料庫儲存引擎** | MySQL InnoDB、RocksDB、LMDB 等使用 mmap 管理數據文件的讀取 |
| **共享記憶體 IPC** | `MAP_SHARED` 匿名映射實現進程間快速通信 |
| **動態庫加載** | OS 用 mmap 加載 `.so`/`.dll` 到進程空間，多個進程共享代碼段 |
| **Redis AOF** | 使用 mmap 配合 `msync` 持久化 |
| **Kafka 消息存儲** | 使用 Java `MappedByteBuffer`（底層 mmap）實現高效消息讀寫 |
| **大文件搜索** | `grep` 等工具對大文件 mmap 後直接搜索，避免讀入全部內容 |

### mmap 的局限性

- **缺頁中斷延遲**：首次訪問每個頁會觸發缺頁中斷，在隨機訪問大量頁時，延遲積累可能超過傳統 I/O
- **虛擬地址空間消耗**：32 位系統地址空間有限（4GB），映射大文件可能耗盡；64 位無此問題
- **文件大小固定困難**：映射建立後，文件大小不能縮小（否則出現 SIGBUS）
- **數據一致性**：`MAP_SHARED` 模式下，多進程修改需額外的同步機制（類似共享記憶體）
- **msync 開銷**：需要手動調用 `msync` 保證數據落磁碟，否則可能丟失修改

### sendfile 與零拷貝

`sendfile()` 是另一種零拷貝技術，適用於文件發送到 Socket 的場景：

```
磁碟 → Page Cache → 網卡（由內核直接傳輸，完全繞過用戶態）
```

Nginx 的靜態文件服務使用 `sendfile`，Kafka 的 Consumer 消費消息也使用 `sendfile` 實現高效傳輸。
