# 上下文切換開銷

- **難度**: 5
- **重要程度**: 4
- **標籤**: `上下文切換`, `寄存器`, `緩存失效`, `TLB`, `進程切換`

## 問題詳述

解釋進程/線程上下文切換的過程、開銷來源（寄存器保存/恢復、緩存失效、TLB 刷新），以及如何減少上下文切換對性能的影響。

## 核心理論與詳解

### 1. 什麼是上下文切換

**上下文（Context）**：CPU 執行進程所需的所有信息
- 寄存器狀態（PC、棧指針、通用寄存器）
- 進程狀態（運行、就緒、阻塞）
- 內存管理信息（頁表基址）
- 打開的文件描述符
- 信號處理信息

**上下文切換**：保存當前進程上下文，恢復下一個進程上下文

### 2. 切換流程

#### 進程切換

```
1. 保存進程 A 的上下文
   ├─ 通用寄存器 → PCB (Process Control Block)
   ├─ PC (程序計數器)
   ├─ 棧指針
   └─ 處理器狀態

2. 選擇下一個進程 B（調度器）

3. 切換地址空間
   ├─ 加載進程 B 的頁表基址到 CR3 寄存器
   └─ 刷新 TLB（Translation Lookaside Buffer）

4. 恢復進程 B 的上下文
   ├─ 從 PCB 加載寄存器
   └─ 跳轉到 B 的 PC

5. 進程 B 開始執行
```

#### 線程切換（同一進程內）

```
1. 保存線程 A 的上下文
   └─ 寄存器、棧指針

2. 恢復線程 B 的上下文
   └─ 寄存器、棧指針

3. 無需切換地址空間（共享地址空間）
   └─ 不刷新 TLB
```

**線程切換更快**：無需切換頁表和刷新 TLB

### 3. 開銷分析

#### 直接開銷

**1. 保存/恢復寄存器**
```
x86-64 需要保存約 20-30 個寄存器：
- 通用寄存器: rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8-r15
- 程序計數器: rip
- 標誌寄存器: rflags
- 段寄存器: cs, ss, ds, es, fs, gs

開銷：約 50-100 個 CPU 週期
```

**2. 內核處理**
```
調度器開銷：
- 選擇下一個進程（O(1) 或 O(log n)）
- 更新統計信息
- 處理信號

開銷：約 100-200 個 CPU 週期
```

**3. 地址空間切換（僅進程）**
```
- 更新頁表基址寄存器（CR3）
- 刷新 TLB

開銷：約 50-100 個 CPU 週期
```

**總計（進程切換）**：約 **1-5 微秒**（取決於 CPU 頻率）

#### 間接開銷（更顯著）

**1. CPU 緩存失效**
```
L1 緩存: 32-64KB，命中延遲 ~4 cycles
L2 緩存: 256KB-1MB，命中延遲 ~12 cycles
L3 緩存: 8-32MB，命中延遲 ~40 cycles
內存: 延遲 ~100-200 cycles

進程 A 的熱數據在緩存中：
[A的代碼][A的數據] ← 緩存命中率高

切換到進程 B：
[B的代碼][B的數據] ← 開始時大量緩存未命中

重新預熱緩存需要時間
```

**2. TLB 失效**
```
TLB 條目有限（~64-1024 個）

進程切換後：
- TLB 需要重新加載（或刷新）
- 虛擬地址轉換變慢
- 頁表遍歷增加內存訪問

預熱 TLB 需要時間
```

**3. 流水線中斷**
```
CPU 流水線正在執行進程 A 的指令序列
切換時：
- 刷新流水線
- 分支預測緩衝失效
- 指令預取失效
```

**間接開銷總計**：可達 **數十到數百微秒**

### 4. 測量上下文切換

#### 使用 lmbench

```bash
# 測量上下文切換時間
lat_ctx -s 0 2

# 結果示例
2 processes: 1.5 microseconds
```

#### 使用 vmstat

```bash
vmstat 1

procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 1024000  32000 512000    0    0     0     0 1000 5000  5  2 93  0  0
                                                              ↑
                                                        每秒上下文切換數
```

#### 使用 perf

```bash
# 記錄上下文切換
perf stat -e context-switches ./program

# 跟踪特定進程
perf record -e sched:sched_switch -p <pid>
```

### 5. 減少上下文切換

#### 應用層優化

**1. 減少線程數**
```go
// ✗ 過多線程導致頻繁切換
for i := 0; i < 10000; i++ {
    go processTask(i)
}

// ✓ 使用線程池/goroutine池
pool := NewWorkerPool(runtime.NumCPU())
for i := 0; i < 10000; i++ {
    pool.Submit(processTask(i))
}
```

**2. 使用異步 I/O**
```go
// ✗ 阻塞 I/O 導致線程切換
data := blockingRead()

// ✓ 異步 I/O
go func() {
    data := asyncRead()
    // 處理數據
}()
// 主線程繼續執行
```

**3. 批量處理**
```go
// ✗ 逐個處理（頻繁喚醒）
for item := range channel {
    process(item)
}

// ✓ 批量處理
batch := make([]Item, 0, 100)
for item := range channel {
    batch = append(batch, item)
    if len(batch) >= 100 {
        processBatch(batch)
        batch = batch[:0]
    }
}
```

**4. CPU 親和性（Affinity）**
```go
// 綁定進程到特定 CPU
runtime.LockOSThread()

// Linux
syscall.SchedSetaffinity(pid, cpuset)
```

**好處**：
- 保持緩存熱度
- 減少緩存失效

#### 系統層優化

**1. 調整調度器參數**
```bash
# 增加時間片（減少切換頻率）
# /proc/sys/kernel/sched_latency_ns

# CFS 調度器調優
sysctl kernel.sched_min_granularity_ns=10000000
```

**2. 使用實時優先級**
```go
// 設置實時優先級（需要權限）
syscall.Setpriority(syscall.PRIO_PROCESS, 0, -20)
```

**3. 禁用不必要的服務**
- 減少後台進程數
- 降低系統整體負載

### 6. 用戶態線程（協程）

**避免內核級上下文切換**：

```
內核線程切換：
- 陷入內核
- 調度器選擇
- 保存/恢復完整上下文
開銷：1-5 微秒

用戶態線程（如 Go goroutine）：
- 在用戶空間切換
- 只保存少量寄存器
- 無需陷入內核
開銷：< 0.2 微秒
```

**Go goroutine 切換**：
```go
// 極輕量級
go func() {
    // 只需保存 PC、SP、少量寄存器
}()

// 可以輕鬆創建數十萬個 goroutine
```

## 實際應用場景

### 1. 高性能服務器
- Nginx: 事件驅動，減少阻塞和切換
- Redis: 單線程事件循環

### 2. 數據庫
- 連接池: 復用線程，減少創建/銷毀開銷
- 異步 I/O: 避免阻塞等待

### 3. 實時系統
- 減少不確定性
- 使用實時調度策略

## 總結

### 開銷組成

```
直接開銷（微秒級）:
- 寄存器保存/恢復
- 內核處理
- 頁表切換

間接開銷（更大）:
- CPU 緩存失效
- TLB 失效
- 流水線中斷
```

### 優化原則

1. 減少不必要的線程
2. 使用異步 I/O
3. 批量處理任務
4. 使用用戶態線程（協程）
5. 綁定 CPU 親和性
6. 調優調度器參數

### 資深工程師需掌握

- 理解上下文切換的完整流程和開銷
- 使用工具測量和分析切換頻率
- 設計低切換開銷的並發模型
- 權衡線程數與切換開銷
- 理解不同語言的並發模型（線程 vs 協程）
