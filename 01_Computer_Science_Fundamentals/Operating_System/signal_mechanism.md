# 信號機制 (Signal Mechanism)

- **難度**: 5
- **重要程度**: 3
- **標籤**: `Signal`, `信號`, `進程通信`, `IPC`, `Unix`

## 問題詳述

信號（Signal）是 Unix/Linux 提供的一種**異步通知機制**，用於通知進程發生了某種事件。信號可以由核心、其他進程或進程自身發送，是進程間通信（IPC）和事件驅動編程的重要基礎。

## 核心理論與詳解

### 信號的本質

信號是一種**軟中斷**：當信號到達進程時，無論進程當前執行到哪裡，都會**異步打斷**當前執行流，轉而執行信號處理函數（Signal Handler）。

**信號的三要素**：
1. **信號名稱/編號**：如 `SIGTERM`（15）、`SIGKILL`（9）、`SIGSEGV`（11）
2. **信號發送者**：核心（硬體異常）、其他進程（`kill()` 調用）、進程自身（`raise()`）
3. **信號處理方式**：默認動作、自定義 Handler、忽略（SIG_IGN）

### 常見信號

| 信號 | 編號 | 觸發原因 | 默認動作 |
|------|------|---------|---------|
| `SIGTERM` | 15 | `kill <pid>` 命令，請求優雅終止 | 終止進程 |
| `SIGKILL` | 9 | `kill -9 <pid>`，強制殺死 | 終止進程（**不可捕獲/忽略**） |
| `SIGINT` | 2 | Ctrl+C | 終止進程 |
| `SIGQUIT` | 3 | Ctrl+\\ | 終止 + 生成 core dump |
| `SIGHUP` | 1 | 終端掛斷（或用於通知進程重載配置） | 終止進程 |
| `SIGSEGV` | 11 | 段錯誤（非法記憶體訪問） | 終止 + core dump |
| `SIGALRM` | 14 | `alarm()` 定時器超時 | 終止進程 |
| `SIGCHLD` | 17 | 子進程狀態改變（終止/停止） | 忽略 |
| `SIGUSR1/2` | 10/12 | 用戶自定義 | 終止進程 |
| `SIGPIPE` | 13 | 向已關閉的 Socket/管道寫入 | 終止進程 |

### 信號的處理方式

進程可以對每個信號選擇三種處理方式（除 SIGKILL 和 SIGSTOP 外）：

1. **默認動作（SIG_DFL）**：核心預定義的行為（終止、忽略、停止、core dump 等）
2. **自定義 Handler（Signal Handler）**：程序員指定的函數，信號到達時執行
3. **忽略（SIG_IGN）**：信號到達時什麼都不做

### 信號在後端的應用

**① 優雅退出（Graceful Shutdown）**

後端服務最常見的信號應用：

```
SystemD / Kubernetes / Docker
  ↓ 發送 SIGTERM
服務進程
  ↓ 捕獲 SIGTERM，執行：
     1. 停止接受新連接
     2. 等待現有請求處理完成
     3. 關閉資料庫連接池
     4. 刷新快取/日誌
     5. 正常退出（exit 0）
```

若超時（Kubernetes 預設 30 秒）仍未退出，則發送 **SIGKILL** 強制終止。

**② Nginx 的信號控制**

Nginx 使用信號實現無停服務重載：
- `SIGHUP`：重載配置文件（不停服）
- `SIGUSR1`：重新打開日誌文件（日誌切割）
- `SIGUSR2`：熱升級（啟動新 Nginx 進程，舊進程逐漸退出）

**③ 守護進程與 SIGHUP**

傳統 Unix 守護進程用 `SIGHUP` 表示「重新讀取配置」，因為守護進程與終端分離後，終端的 HUP 信號原本語意是「終端掛斷」，被重新賦予了「重載」的語義。

**④ SIGPIPE 防護**

後端服務向客戶端、下游服務寫數據時，若對端已關閉連接，write 操作會觸發 `SIGPIPE`，默認終止進程。通常需要：
- `signal(SIGPIPE, SIG_IGN)` 忽略此信號
- 通過 `errno = EPIPE` 在代碼中判斷並處理

### 信號安全注意事項

- **Signal Handler 的限制**：Signal Handler 可能在任意時刻打斷主程序，因此 Handler 中只能調用**異步信號安全（async-signal-safe）**的函數（如 `write()`，不是 `printf()`）
- **信號處理與線程**：多執行緒程序中，信號由哪個執行緒處理是複雜的（預設發送給進程組），通常使用 `sigwait()` 在專用執行緒中同步等待信號
- **Go 的信號處理**：Go 的 `os/signal` 包將信號轉化為 channel 消息，在 goroutine 中安全處理
