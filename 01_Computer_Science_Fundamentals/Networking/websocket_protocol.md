# WebSocket 協定與應用

- **難度**: 6
- **重要程度**: 4
- **標籤**: `WebSocket`, `雙向通信`, `即時通訊`, `長連接`, `全雙工`

## 問題詳述

解釋 WebSocket 協定的工作原理、與 HTTP 的區別、握手過程，以及在即時應用中的實際應用場景和最佳實踐。

## 核心理論與詳解

### 1. WebSocket 基本概念

**WebSocket** 是一種在單個 TCP 連接上進行 **全雙工通信** 的協定，允許伺服器主動向客戶端推送資料。

#### 核心特性

- **雙向通信**: 客戶端和伺服器可同時發送資料
- **長連接**: 連接建立後保持開啟，無需重複握手
- **低延遲**: 無 HTTP 輪詢開銷，實時性更好
- **輕量級**: 資料幀頭部小（2-14 bytes），傳輸效率高
- **基於事件**: 事件驅動模型，易於處理異步通信

### 2. WebSocket vs HTTP

#### 傳統 HTTP 的限制

**問題 1: 單向請求-回應模型**
```
客戶端                           伺服器
  |  ──── HTTP Request ───────> |
  |  <─── HTTP Response ──────  |
  |  (連接關閉)                  |
  |                              |
  |  若需新資料，必須重新發起請求 |
```

**問題 2: 輪詢 (Polling) 的低效**
```
客戶端每隔 N 秒發送請求
  |  ──── 有新資料嗎？ ───────> |
  |  <─── 沒有 ────────────────  |
  |  (1 秒後)                    |
  |  ──── 有新資料嗎？ ───────> |
  |  <─── 沒有 ────────────────  |
  |  (1 秒後)                    |
  |  ──── 有新資料嗎？ ───────> |
  |  <─── 有！這是資料 ─────────  |
```

**缺點**:
- 大量無效請求浪費資源
- 延遲高 (取決於輪詢間隔)
- 伺服器負載大

**問題 3: 長輪詢 (Long Polling) 的複雜性**
```
客戶端                           伺服器
  |  ──── 有新資料嗎？ ───────> |
  |                              | (伺服器保持連接)
  |                              | (等待新資料...)
  |                              | (有資料了！)
  |  <─── 有！這是資料 ─────────  |
  |  (立即發起新請求)            |
  |  ──── 有新資料嗎？ ───────> |
```

**改進**: 減少無效請求，但仍有開銷
- 每次回應後需重新建立連接
- 頭部開銷仍然存在
- 實現複雜度高

#### WebSocket 的優勢

```
客戶端                           伺服器
  |  ──── WebSocket Handshake ─> |
  |  <─── 握手成功 ──────────────  |
  | ════════ 連接建立 ═══════════ |
  |                              |
  |  <─── 推送資料 ────────────  | (伺服器主動推送)
  |  ──── 發送資料 ───────────> |
  |  <─── 推送資料 ────────────  |
  |  ──── 發送資料 ───────────> |
  | ════════ 持續開啟 ═══════════ |
```

**優勢總結**:

| 特性 | HTTP 輪詢 | HTTP 長輪詢 | WebSocket |
|-----|----------|------------|-----------|
| **實時性** | 低 (秒級) | 中 (近實時) | **高 (毫秒級)** |
| **伺服器負載** | 極高 | 高 | **低** |
| **頭部開銷** | 極大 (每次請求) | 大 (每次重連) | **極小 (握手後)** |
| **雙向通信** | 否 | 否 | **是** |
| **連接數** | 大量短連接 | 大量長連接 | **單一持久連接** |
| **實現複雜度** | 簡單 | 中等 | 中等 |

### 3. WebSocket 握手過程

WebSocket 基於 HTTP 進行握手，隨後升級為 WebSocket 協定。

#### 第一步: 客戶端發起握手 (HTTP Upgrade)

```http
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: https://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Extensions: permessage-deflate
```

**關鍵欄位**:

1. **Upgrade: websocket**
   - 請求升級到 WebSocket 協定

2. **Connection: Upgrade**
   - 表明這是一個升級請求

3. **Sec-WebSocket-Key**
   - 隨機生成的 Base64 編碼字串 (16 bytes)
   - 防止快取代理誤認為是普通 HTTP 請求

4. **Sec-WebSocket-Version: 13**
   - WebSocket 協定版本 (目前標準是 13)

5. **Origin**
   - 發起請求的網頁來源
   - 伺服器可用於同源策略檢查

6. **Sec-WebSocket-Protocol** (可選)
   - 客戶端支援的子協定列表
   - 如: `chat`, `mqtt`, `stomp`

7. **Sec-WebSocket-Extensions** (可選)
   - 請求的擴充功能
   - 如: `permessage-deflate` (訊息壓縮)

#### 第二步: 伺服器回應握手

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
Sec-WebSocket-Extensions: permessage-deflate
```

**關鍵欄位**:

1. **HTTP/1.1 101 Switching Protocols**
   - 狀態碼 101 表示協定切換成功

2. **Sec-WebSocket-Accept**
   - 伺服器驗證值，計算方式：
   ```
   Base64(SHA-1(Sec-WebSocket-Key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))
   ```
   - 客戶端驗證此值以確認伺服器理解 WebSocket

3. **Sec-WebSocket-Protocol** (可選)
   - 伺服器選擇的子協定

4. **Sec-WebSocket-Extensions** (可選)
   - 伺服器同意的擴充功能

#### 第三步: 連接建立，開始資料傳輸

握手成功後，HTTP 連接升級為 WebSocket 連接，雙方可開始發送 WebSocket 幀。

### 4. WebSocket 資料幀格式

WebSocket 使用輕量級的二進制幀格式，而非 HTTP 文字協定。

#### 幀結構 (Frame Structure)

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               | Masking-key, if MASK set to 1 |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

#### 欄位說明

1. **FIN (1 bit)**
   - `1`: 這是訊息的最後一個片段
   - `0`: 後續還有片段

2. **RSV1, RSV2, RSV3 (各 1 bit)**
   - 保留位元，用於擴充功能
   - 通常為 0

3. **Opcode (4 bits)**
   - 定義幀的類型：
     - `0x0`: 後續幀 (Continuation)
     - `0x1`: 文字幀 (UTF-8)
     - `0x2`: 二進制幀
     - `0x8`: 連接關閉
     - `0x9`: Ping
     - `0xA`: Pong

4. **MASK (1 bit)**
   - `1`: Payload 已被遮罩 (客戶端發送**必須**設為 1)
   - `0`: Payload 未遮罩 (伺服器發送**必須**設為 0)

5. **Payload Length (7 bits, 7+16 bits, or 7+64 bits)**
   - `0-125`: 實際長度
   - `126`: 後續 2 bytes 為實際長度 (16-bit unsigned)
   - `127`: 後續 8 bytes 為實際長度 (64-bit unsigned)

6. **Masking-key (0 or 4 bytes)**
   - 如果 MASK=1，包含 4 bytes 的遮罩金鑰

7. **Payload Data**
   - 實際傳輸的資料

#### 為什麼客戶端必須遮罩？

**目的**: 防止快取中毒攻擊 (Cache Poisoning)

**問題場景**:
1. 惡意網頁建立 WebSocket 連接到代理伺服器
2. 構造看似 HTTP 回應的 WebSocket 訊息
3. 代理伺服器可能誤將其當作 HTTP 快取

**解決**: 強制遮罩確保訊息無法被誤認為 HTTP

### 5. WebSocket 連接管理

#### 心跳機制 (Ping/Pong)

**目的**: 保持連接活躍，檢測連接狀態

```
客戶端                           伺服器
  |                              |
  |  ──── Ping Frame ─────────> |
  |                              |
  |  <─── Pong Frame ──────────  |
  |                              |
```

**實現方式**:
1. **主動 Ping**: 定期發送 Ping 幀 (如每 30 秒)
2. **被動 Pong**: 收到 Ping 後必須回覆 Pong
3. **超時檢測**: 若長時間未收到 Pong，視為連接斷開

**應用層心跳 vs WebSocket Ping**:
- **WebSocket Ping**: 協定層實現，無應用邏輯
- **應用層心跳**: 可攜帶業務資訊，如用戶線上狀態

#### 連接關閉

**正常關閉流程**:

```
客戶端                           伺服器
  |                              |
  |  ──── Close Frame (1000) ─> |
  |       (關閉原因: 正常關閉)    |
  |                              |
  |  <─── Close Frame (1000) ──  |
  |                              |
  | ════════ TCP 連接關閉 ═══════ |
```

**關閉狀態碼**:

| 狀態碼 | 名稱 | 描述 |
|-------|------|------|
| **1000** | Normal Closure | 正常關閉 |
| **1001** | Going Away | 伺服器關機或瀏覽器導航離開 |
| **1002** | Protocol Error | 協定錯誤 |
| **1003** | Unsupported Data | 收到不支援的資料類型 |
| **1005** | No Status Rcvd | 保留，不應在幀中發送 |
| **1006** | Abnormal Closure | 保留，異常關閉 (如無 Close 幀) |
| **1007** | Invalid Payload | 資料不一致 (如 UTF-8 錯誤) |
| **1008** | Policy Violation | 違反策略 |
| **1009** | Message Too Big | 訊息過大 |
| **1010** | Mandatory Extension | 必需的擴充未協商 |
| **1011** | Internal Error | 伺服器內部錯誤 |
| **1012** | Service Restart | 伺服器重啟 |
| **1013** | Try Again Later | 臨時性錯誤 |
| **1015** | TLS Handshake | TLS 握手失敗 (保留) |

#### 斷線重連策略

**指數退避 (Exponential Backoff)**:

```
第 1 次重連: 立即
第 2 次重連: 1 秒後
第 3 次重連: 2 秒後
第 4 次重連: 4 秒後
第 5 次重連: 8 秒後
...
最大間隔: 60 秒
```

**連接狀態管理**:

```
連接狀態:
  CONNECTING (0) → 正在建立連接
  OPEN (1)       → 連接已開啟，可通信
  CLOSING (2)    → 連接正在關閉
  CLOSED (3)     → 連接已關閉
```

### 6. 應用場景

#### 場景 1: 即時聊天

**需求**:
- 訊息即時推送
- 線上狀態同步
- 輸入狀態提示

**優勢**:
- 低延遲訊息傳遞
- 伺服器主動推送
- 單一連接處理所有通信

#### 場景 2: 協作編輯

**需求**:
- 多人同時編輯
- 操作即時同步
- 衝突解決

**實現**:
- WebSocket 傳輸操作指令
- Operational Transformation (OT)
- 或 CRDT (Conflict-free Replicated Data Types)

#### 場景 3: 即時通知

**需求**:
- 系統通知推送
- 用戶動態更新
- 活動提醒

**優勢**:
- 無需輪詢
- 節省伺服器資源
- 即時性好

#### 場景 4: 線上遊戲

**需求**:
- 低延遲
- 高頻率狀態同步
- 雙向通信

**挑戰**:
- 頻寬管理
- 狀態一致性
- 作弊防護

#### 場景 5: 金融交易

**需求**:
- 實時行情推送
- 訂單狀態更新
- 交易確認

**要求**:
- 可靠性高
- 延遲低
- 安全性強

#### 場景 6: 物聯網 (IoT)

**需求**:
- 裝置狀態監控
- 遠端控制
- 資料上傳

**考量**:
- 裝置資源有限
- 網路不穩定
- 大量連接

### 7. WebSocket 安全

#### 使用 WSS (WebSocket Secure)

**問題**: WS (ws://) 使用明文傳輸，可被竊聽和竄改

**解決**: 使用 WSS (wss://)，類似 HTTPS 的 TLS 加密

```
ws://example.com/chat   → 明文 (不安全)
wss://example.com/chat  → 加密 (安全)
```

#### 跨站 WebSocket 劫持 (CSWSH)

**攻擊手法**:
1. 攻擊者誘騙用戶訪問惡意網站
2. 惡意網站建立 WebSocket 連接到目標網站
3. 利用用戶的 Cookie 進行未授權操作

**防護措施**:

1. **驗證 Origin 頭部**
   ```go
   allowedOrigins := []string{"https://example.com", "https://app.example.com"}
   
   if !contains(allowedOrigins, request.Header.Get("Origin")) {
       return errors.New("invalid origin")
   }
   ```

2. **使用 CSRF Token**
   - 在握手時驗證 token
   - 確保請求來自合法頁面

3. **檢查身份驗證**
   - 不僅依賴 Cookie
   - 驗證 WebSocket 特定的授權令牌

#### 訊息注入攻擊

**問題**: 惡意客戶端發送構造的訊息

**防護**:
1. **輸入驗證**: 嚴格驗證訊息格式和內容
2. **訊息大小限制**: 防止過大訊息攻擊
3. **速率限制**: 防止訊息洪水
4. **內容過濾**: 過濾惡意腳本和指令

#### 拒絕服務 (DoS)

**攻擊手法**:
- 大量建立連接耗盡伺服器資源
- 發送大量小訊息
- 發送巨大訊息

**防護**:
1. **連接數限制**: 每個 IP/用戶的最大連接數
2. **訊息大小限制**: 拒絕超大訊息
3. **速率限制**: 限制訊息頻率
4. **資源監控**: 及時發現異常流量

### 8. 效能優化

#### 訊息壓縮

**擴充**: `permessage-deflate`

```
客戶端握手請求:
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits

伺服器握手回應:
Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15
```

**優勢**:
- 減少傳輸資料量 (可達 70%+)
- 降低頻寬成本

**權衡**:
- 增加 CPU 開銷
- 壓縮/解壓縮延遲
- 適合文字類訊息，二進制資料效果有限

#### 訊息批次處理

**問題**: 高頻小訊息增加幀開銷

**解決**: 在應用層批次聚合訊息

```
每 100ms 批次發送:
  單一訊息包含多個業務事件
  [事件1, 事件2, 事件3, ...]
```

**優勢**:
- 減少幀數量
- 降低協定開銷
- 提高吞吐量

**權衡**:
- 增加延遲 (批次間隔)
- 增加訊息大小

#### 二進制格式

**問題**: JSON 文字格式冗餘大

**解決**: 使用高效的二進制序列化

- **Protocol Buffers (Protobuf)**
- **MessagePack**
- **CBOR**
- **FlatBuffers**

**優勢**:
- 體積更小 (30-50% 減少)
- 解析更快
- 強型別

#### 連接復用

**策略**: 單一 WebSocket 連接處理多個邏輯通道

```
訊息格式:
{
  "channel": "chat",
  "data": {...}
}

{
  "channel": "notifications",
  "data": {...}
}
```

**優勢**:
- 減少連接數
- 降低握手開銷
- 簡化客戶端管理

### 9. 可靠性設計

#### 訊息確認機制

**問題**: WebSocket 基於 TCP，但應用層需額外確認

**實現**:

```
客戶端發送:
{
  "id": "msg-12345",
  "type": "chat",
  "content": "Hello"
}

伺服器確認:
{
  "ack": "msg-12345",
  "status": "received"
}
```

#### 訊息序號與去重

**目的**: 防止重複處理和亂序

```
每條訊息攜帶序號:
{
  "seq": 1001,
  "data": {...}
}

接收方檢查:
- 序號是否連續
- 是否已處理過
- 是否需要重排序
```

#### 斷線緩衝

**問題**: 斷線期間的訊息丟失

**解決**:

1. **伺服器端緩衝**
   - 暫存用戶離線時的訊息
   - 重連後推送未送達訊息

2. **客戶端緩衝**
   - 本地暫存待發送訊息
   - 重連後重新發送

3. **訊息持久化**
   - 關鍵訊息寫入資料庫
   - 支援歷史訊息查詢

### 10. 替代方案

#### Server-Sent Events (SSE)

**特性**:
- 單向推送 (伺服器 → 客戶端)
- 基於 HTTP
- 自動重連
- 文字格式

**適用場景**:
- 只需伺服器推送
- 無需雙向通信
- 簡單實現

**對比 WebSocket**:
- ✅ 實現更簡單
- ✅ 更好的 HTTP 相容性
- ❌ 只支援單向推送
- ❌ 只支援文字資料

#### HTTP/2 Server Push

**特性**:
- 伺服器主動推送資源
- 多路復用
- 頭部壓縮

**限制**:
- 主要用於靜態資源推送
- 不適合雙向即時通信
- 瀏覽器支援有限

#### gRPC Streaming

**特性**:
- 基於 HTTP/2
- 支援雙向串流
- Protocol Buffers 序列化

**適用場景**:
- 微服務間通信
- 需要強型別
- 高效能要求

### 11. 實務最佳實踐

#### 連接管理清單

- [ ] 實現心跳機制 (30-60 秒間隔)
- [ ] 實現自動重連 (指數退避)
- [ ] 優雅關閉處理
- [ ] 連接狀態監控
- [ ] 超時檢測與清理
- [ ] 最大連接數限制

#### 安全加固清單

- [ ] 強制使用 WSS (wss://)
- [ ] 驗證 Origin 頭部
- [ ] 實施身份驗證與授權
- [ ] 輸入驗證與過濾
- [ ] 訊息大小限制
- [ ] 速率限制
- [ ] 防止 CSWSH 攻擊
- [ ] 記錄與監控異常行為

#### 效能優化清單

- [ ] 啟用訊息壓縮 (permessage-deflate)
- [ ] 使用二進制序列化格式
- [ ] 實施訊息批次處理
- [ ] 連接復用 (多通道)
- [ ] 負載均衡與水平擴展
- [ ] 監控連接數與訊息量
- [ ] 優化訊息大小

#### 可靠性清單

- [ ] 訊息確認機制
- [ ] 訊息序號與去重
- [ ] 斷線緩衝
- [ ] 關鍵訊息持久化
- [ ] 錯誤處理與重試
- [ ] 降級方案 (如 HTTP 長輪詢)
- [ ] 監控與告警

## 總結

WebSocket 是現代即時應用的基石：

1. **全雙工通信**: 真正的雙向即時通信，無輪詢開銷
2. **輕量級協定**: 最小化頭部開銷，提高傳輸效率
3. **安全第一**: 必須使用 WSS，防範 CSWSH 等攻擊
4. **可靠性設計**: 心跳、重連、訊息確認缺一不可
5. **效能優化**: 壓縮、批次、二進制格式顯著提升效能

作為資深後端工程師，你需要：
- 深入理解 WebSocket 協定細節和資料幀格式
- 能夠設計可靠的 WebSocket 架構
- 掌握安全最佳實踐，防範常見攻擊
- 在不同場景下選擇合適的即時通信方案
- 實施監控和優化，確保生產環境穩定高效
