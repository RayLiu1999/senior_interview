# 陣列與動態陣列

- **難度**: 3
- **重要程度**: 5
- **標籤**: `陣列`, `動態擴容`, `時間複雜度`, `記憶體管理`

## 問題詳述

陣列是最基礎且最重要的資料結構，靜態陣列大小固定，而動態陣列（如 Go 的 slice、Java 的 ArrayList、Python 的 list）能自動擴容。理解陣列的底層原理和擴容機制對於效能優化至關重要。

## 核心理論與詳解

### 1. 靜態陣列 (Static Array)

#### 核心特性

- **連續記憶體空間**: 元素在記憶體中連續存放
- **固定大小**: 宣告時大小確定，無法動態改變
- **隨機存取**: 透過索引直接計算記憶體位址，時間複雜度 O(1)
- **快取友善**: 連續記憶體提高 CPU 快取命中率

#### 記憶體位址計算

```
元素位址 = 陣列起始位址 + (索引 × 元素大小)
```

#### 優缺點

**優點**:
- **存取快速**: O(1) 隨機存取
- **記憶體效率高**: 無額外開銷
- **快取友善**: 空間局部性好

**缺點**:
- **大小固定**: 無法動態調整
- **插入/刪除慢**: 需要移動元素，O(n)
- **記憶體浪費**: 預分配過大會浪費空間

### 2. 動態陣列 (Dynamic Array)

#### 核心原理

動態陣列底層仍是靜態陣列，但透過**自動擴容機制**實現動態增長：

1. **初始容量**: 分配初始大小的底層陣列
2. **追加元素**: 如果容量足夠，直接加入
3. **觸發擴容**: 當元素數量達到容量上限時
4. **重新分配**: 分配更大的新陣列（通常 1.5x 或 2x）
5. **複製資料**: 將舊陣列資料複製到新陣列
6. **釋放舊陣列**: 回收舊陣列記憶體

#### 擴容策略

**常見擴容倍數**:

| 語言/函式庫 | 擴容倍數 | 原因 |
|-----------|---------|------|
| **Go slice** | 2x (小容量), 1.25x (大容量) | 平衡記憶體與效能 |
| **Java ArrayList** | 1.5x | 減少記憶體浪費 |
| **Python list** | ~1.125x | 降低大陣列記憶體壓力 |
| **C++ vector** | 2x | 最佳化效能 |

**為什麼不是固定增量**？
- 固定增量（如每次 +100）會導致頻繁擴容
- 倍數增長保證**均攤時間複雜度** O(1)

### 3. 時間與空間複雜度

#### 時間複雜度

| 操作 | 靜態陣列 | 動態陣列 | 說明 |
|-----|---------|---------|------|
| **隨機存取** | O(1) | O(1) | 透過索引直接計算位址 |
| **尾部插入** | - | O(1) 均攤 | 大部分情況 O(1)，偶爾擴容 O(n) |
| **頭部插入** | O(n) | O(n) | 需要移動所有元素 |
| **中間插入** | O(n) | O(n) | 需要移動後續元素 |
| **刪除** | O(n) | O(n) | 需要移動後續元素 |
| **查找** | O(n) | O(n) | 未排序需線性搜尋 |

#### 空間複雜度

- **靜態陣列**: O(n) - 精確分配
- **動態陣列**: O(n) - 但實際分配容量 > 元素數量

#### 均攤分析 (Amortized Analysis)

以 2x 擴容為例，插入 n 個元素：

```
擴容次數: log₂(n)
總複製成本: 1 + 2 + 4 + 8 + ... + n = 2n - 1
均攤成本: (2n - 1) / n ≈ 2 = O(1)
```

因此尾部插入的**均攤時間複雜度**為 O(1)。

### 4. Go 語言實現細節

#### Slice 結構

```go
type slice struct {
    array unsafe.Pointer  // 指向底層陣列
    len   int             // 當前長度
    cap   int             // 容量
}
```

#### 容量計算規則

```
- cap < 256: newcap = oldcap * 2
- cap >= 256: newcap = oldcap + (oldcap + 3*256) / 4
```

#### 使用技巧

```go
// 1. 預分配容量避免多次擴容
nums := make([]int, 0, 100)  // len=0, cap=100

// 2. 避免切片陷阱（共用底層陣列）
a := []int{1, 2, 3, 4, 5}
b := a[1:3]  // b 和 a 共用底層陣列
b[0] = 999   // a[1] 也變成 999

// 3. 完全複製
b := make([]int, len(a))
copy(b, a)

// 4. 刪除元素（保持順序）
nums = append(nums[:i], nums[i+1:]...)

// 5. 刪除元素（不保持順序，更快）
nums[i] = nums[len(nums)-1]
nums = nums[:len(nums)-1]
```

### 5. 實際應用場景

#### 後端系統中的應用

**1. 批次處理資料**
```go
// 批次查詢使用者資訊
userIDs := make([]int64, 0, 100)
for _, order := range orders {
    userIDs = append(userIDs, order.UserID)
}
users := batchGetUsers(userIDs)
```

**2. 分頁查詢結果**
```go
// 預分配容量提升效能
results := make([]Product, 0, pageSize)
for rows.Next() {
    var p Product
    rows.Scan(&p)
    results = append(results, p)
}
```

**3. 日誌緩衝**
```go
// 累積日誌批次寫入
logBuffer := make([]LogEntry, 0, 1000)
if len(logBuffer) >= 1000 {
    flushLogs(logBuffer)
    logBuffer = logBuffer[:0]  // 重用底層陣列
}
```

**4. 限流滑動視窗**
```go
// 記錄最近請求時間戳
type RateLimiter struct {
    timestamps []int64
    limit      int
    window     int64
}
```

### 6. 效能優化建議

#### 預分配容量

```go
// ❌ 不好：多次擴容
nums := []int{}
for i := 0; i < 10000; i++ {
    nums = append(nums, i)
}

// ✅ 好：預分配
nums := make([]int, 0, 10000)
for i := 0; i < 10000; i++ {
    nums = append(nums, i)
}
```

#### 重用切片

```go
// ❌ 不好：頻繁分配
for {
    buffer := make([]byte, 4096)
    n, _ := reader.Read(buffer)
    process(buffer[:n])
}

// ✅ 好：重用緩衝區
buffer := make([]byte, 4096)
for {
    n, _ := reader.Read(buffer)
    process(buffer[:n])
}
```

#### 避免記憶體洩漏

```go
// ❌ 危險：保留大陣列引用
func getFirst10(data []int) []int {
    return data[:10]  // 仍引用整個底層陣列
}

// ✅ 安全：複製資料
func getFirst10(data []int) []int {
    result := make([]int, 10)
    copy(result, data[:10])
    return result
}
```

## 常見面試題

### Q1: 為什麼陣列查找是 O(n) 而不是 O(1)？

**答**: O(1) 是**透過索引隨機存取**，O(n) 是**線性搜尋值**。兩者不同：
- `arr[5]` → O(1)
- 查找值為 10 的元素 → O(n)

### Q2: 動態陣列擴容為什麼選擇 2x 或 1.5x？

**答**:
- **太小（1.25x）**: 擴容頻繁，複製開銷大
- **太大（3x）**: 記憶體浪費嚴重
- **2x**: 平衡效能與記憶體，均攤 O(1)
- **1.5x**: Go/Java 在大容量時使用，減少記憶體壓力

### Q3: 如何避免切片陷阱？

**答**: 理解三個關鍵點：
1. **切片共用底層陣列**: `b := a[1:3]` 與 `a` 共用
2. **append 可能重新分配**: 超過 cap 會建立新陣列
3. **明確複製**: 使用 `copy()` 或重新 `make()`

## 總結

### 核心要點

1. **陣列是最基礎的資料結構**: 連續記憶體，O(1) 隨機存取
2. **動態陣列自動擴容**: 倍數增長保證均攤 O(1)
3. **預分配容量**: 避免多次擴容提升效能
4. **注意切片陷阱**: 理解底層陣列共用機制
5. **選擇合適的資料結構**: 頻繁插入/刪除考慮鏈結串列

### 作為資深後端工程師，你需要

- ✅ 理解陣列的底層記憶體布局和存取原理
- ✅ 掌握動態陣列的擴容機制和均攤分析
- ✅ 能夠根據場景選擇預分配容量
- ✅ 避免切片共用底層陣列的陷阱
- ✅ 在批次處理、分頁查詢等場景中高效使用陣列
