# B 樹與 B+ 樹（MySQL 索引原理）

- **難度**: 7
- **重要程度**: 5
- **標籤**: `B-Tree`, `B+Tree`, `MySQL Index`, `Database`

## 問題詳述

B 樹和 B+ 樹是**多路平衡查找樹**，專為**磁碟存儲系統**設計。MySQL 的 InnoDB 引擎使用 **B+ 樹**作為索引結構，理解其原理對於資料庫優化至關重要。

## 核心理論與詳解

### 1. 為什麼需要 B 樹/B+ 樹？

#### 1.1 二元搜尋樹的問題

**問題**：
- AVL 樹、紅黑樹雖然平衡，但**樹高 O(log n)**
- 對於百萬級數據，樹高約 20 層
- 每層查詢需要**一次磁碟 I/O**
- 磁碟 I/O 是記憶體訪問的 **10 萬倍**慢

**例子**：
```
100 萬筆記錄，紅黑樹高度 ≈ 20
查詢一筆記錄 = 20 次磁碟 I/O ≈ 200ms
```

#### 1.2 B 樹的設計思想

**核心目標**：**減少磁碟 I/O 次數**

**解決方案**：
1. **增加樹的分叉數（度）**：從 2 叉變成 M 叉（M >> 2）
2. **降低樹高**：M 越大，樹高越低
3. **一次讀取一整頁**：利用磁碟預讀特性

**效果**：
```
100 萬筆記錄，B+ 樹（M=1000）高度 ≈ 3
查詢一筆記錄 = 3 次磁碟 I/O ≈ 30ms
性能提升 6-7 倍！
```

---

### 2. B 樹（B-Tree）

#### 2.1 B 樹的定義

**B 樹是一棵 M 階多路平衡查找樹**，滿足以下性質：

1. **每個節點最多有 M 個子節點**
2. **每個非葉子節點（除根）至少有 ⌈M/2⌉ 個子節點**
3. **根節點至少有 2 個子節點**（除非是葉子節點）
4. **所有葉子節點在同一層**
5. **節點內的關鍵字有序**

**節點結構**：
```
[ P0 | K1 | P1 | K2 | P2 | ... | Kn | Pn ]

- Ki：關鍵字（Key），有序
- Pi：指向子樹的指針
- P0 指向的子樹：所有 Key < K1
- Pi 指向的子樹：Ki < Key < Ki+1
```

**圖解**：
```
3 階 B 樹（M=3）：

           [10, 20]
          /    |    \
     [5, 8]  [15]  [25, 30]
    /  |  \   / \   /  |  \
  [3] [7] [9][13][17][23][28][35]
```

#### 2.2 B 樹的查找

**查找 Key = 15**：
```
1. 從根節點 [10, 20] 開始
   15 在 10 和 20 之間 → 走中間指針
   
2. 到達 [15]
   找到！
```

**時間複雜度**：O(log_M N)
- M 是階數，N 是關鍵字總數

#### 2.3 B 樹的插入

**插入 Key = 12**：

**步驟 1**：查找插入位置
- 應該插入到 [15] 節點

**步驟 2**：插入關鍵字
- [15] 變成 [12, 15]

**步驟 3**：檢查溢出
- 如果節點關鍵字數 > M-1，需要**分裂**

**分裂過程**：
```
假設 M=3，插入後節點變成 [10, 15, 20]（超過 M-1=2）

分裂：
1. 取中間關鍵字 15 上移到父節點
2. 左邊 [10]，右邊 [20]
3. 父節點增加一個關鍵字和指針
```

#### 2.4 B 樹的刪除

**刪除分三種情況**：

1. **葉子節點**：直接刪除
2. **非葉子節點**：用前驅/後繼替換
3. **關鍵字不足**：合併或借關鍵字

---

### 3. B+ 樹（B+Tree）

#### 3.1 B+ 樹與 B 樹的區別

**核心差異**：

| 特性 | B 樹 | B+ 樹 |
|------|------|-------|
| **數據存儲** | 所有節點都存數據 | 只有葉子節點存數據 |
| **內部節點** | 存儲 Key + Data | 只存儲 Key（索引） |
| **葉子節點** | 不連接 | **連接成鏈表** |
| **範圍查詢** | 需要中序遍歷 | **直接遍歷葉子鏈表** |

**B+ 樹結構**：
```
           [10, 20]
          /    |    \
     [5, 8]  [15]  [25, 30]
    /         |          \
葉子層（數據層）：
[3,data] → [5,data] → [7,data] → [8,data] → ...
   ↑           ↑                      ↑
雙向鏈表連接
```

#### 3.2 為什麼 MySQL 選擇 B+ 樹？

**原因 1：範圍查詢效率高**

**B 樹**：
```sql
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
```
- 需要中序遍歷整棵樹
- 隨機 I/O

**B+ 樹**：
```sql
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
```
- 找到起點後，**順序遍歷葉子鏈表**
- 順序 I/O（快 10 倍）

---

**原因 2：單次查詢 I/O 次數更少**

**B 樹（M=3，每個節點 4KB）**：
```
內部節點：
- Key (8 bytes) + Data (100 bytes) + Pointer (8 bytes) = 116 bytes
- 每頁可存：4096 / 116 ≈ 35 個 Key
- 3 層高度可存：35³ ≈ 42,875 筆

磁碟 I/O：3 次
```

**B+ 樹（M=3，每個節點 4KB）**：
```
內部節點：
- Key (8 bytes) + Pointer (8 bytes) = 16 bytes
- 每頁可存：4096 / 16 = 256 個 Key
- 3 層高度可存：256³ ≈ 1677 萬筆

磁碟 I/O：3 次
```

**結論**：B+ 樹能用更少的層數存儲更多數據

---

**原因 3：更穩定的查詢性能**

**B 樹**：
- 查詢時間不穩定
- 根節點：1 次 I/O
- 葉子節點：h 次 I/O（h 是樹高）

**B+ 樹**：
- **所有查詢都到葉子節點**
- 查詢時間穩定，都是 h 次 I/O

---

#### 3.3 InnoDB 的 B+ 樹實現

**聚簇索引（Clustered Index）**：
```
          [10, 20, 30]
         /    |    |    \
    [5,8]  [15,18] [25,28] [35,40]
   /                              \
葉子節點（完整行數據）：
[id=5, name="Alice", age=25, ...] → [id=8, ...] → ...
```

**特點**：
- 葉子節點存儲**完整的行數據**
- 主鍵即索引
- 數據和索引存儲在一起

---

**二級索引（Secondary Index）**：
```
按 age 建立索引：

          [20, 30]
         /    |    \
    [18,19]  [25,28] [35,40]
   /                         \
葉子節點（只存主鍵）：
[age=18, id=3] → [age=19, id=7] → [age=25, id=5] → ...
```

**特點**：
- 葉子節點只存儲**主鍵值**
- 需要**回表查詢**（根據主鍵再查一次聚簇索引）

**查詢過程**：
```sql
SELECT * FROM users WHERE age = 25;
```

1. 在 age 索引的 B+ 樹中查找 age=25 → 得到 id=5
2. 回表：在主鍵索引的 B+ 樹中查找 id=5 → 得到完整數據

---

### 4. 索引優化實踐

#### 4.1 索引覆蓋（Index Covering）

**問題**：回表查詢浪費一次 I/O

**解決方案**：讓索引包含所有需要的列

```sql
-- ❌ 需要回表
SELECT name, age FROM users WHERE age = 25;

-- ✅ 建立覆蓋索引
CREATE INDEX idx_age_name ON users(age, name);
-- 二級索引葉子節點：[age=25, name="Alice", id=5]
-- 不需要回表！
```

#### 4.2 最左前綴原則

**聯合索引**：`INDEX(a, b, c)`

**B+ 樹結構**：
```
按 (a, b, c) 排序：
(1,2,3) → (1,2,4) → (1,3,1) → (2,1,1) → ...
```

**使用規則**：
```sql
-- ✅ 可以使用索引
WHERE a = 1
WHERE a = 1 AND b = 2
WHERE a = 1 AND b = 2 AND c = 3

-- ❌ 不能使用索引
WHERE b = 2
WHERE c = 3
WHERE b = 2 AND c = 3

-- ⚠️ 部分使用索引
WHERE a = 1 AND c = 3  -- 只用到 a
```

#### 4.3 索引下推（Index Condition Pushdown）

**問題**：
```sql
-- 聯合索引 (age, name)
SELECT * FROM users WHERE age > 20 AND name LIKE 'A%';
```

**MySQL 5.6 之前**：
1. 在索引中找出 age > 20 的所有記錄
2. 回表取出完整數據
3. 在 Server 層過濾 name LIKE 'A%'

**MySQL 5.6+ 索引下推**：
1. 在索引中找出 age > 20 的記錄
2. **在索引層直接過濾 name LIKE 'A%'**
3. 只對符合條件的記錄回表

**效果**：大幅減少回表次數

---

## 實際應用場景

### 1. MySQL 索引設計

**場景 1：高頻查詢優化**
```sql
-- 原始查詢：全表掃描
SELECT * FROM orders 
WHERE user_id = 123 AND status = 'pending' 
ORDER BY created_at DESC 
LIMIT 10;

-- 優化：建立聯合索引
CREATE INDEX idx_user_status_time 
ON orders(user_id, status, created_at);
```

**場景 2：避免回表**
```sql
-- 需求：只查詢少數幾個列
SELECT id, user_id, total_amount 
FROM orders 
WHERE user_id = 123;

-- 優化：覆蓋索引
CREATE INDEX idx_user_id_amount 
ON orders(user_id, total_amount);
```

### 2. 分頁查詢優化

**問題**：
```sql
-- 深度分頁很慢
SELECT * FROM orders ORDER BY id LIMIT 1000000, 20;
```
- MySQL 需要掃描 1000020 條記錄
- 拋棄前 1000000 條

**優化方案 1：子查詢**
```sql
SELECT * FROM orders 
WHERE id >= (
    SELECT id FROM orders ORDER BY id LIMIT 1000000, 1
) 
LIMIT 20;
```

**優化方案 2：記錄上次位置**
```sql
SELECT * FROM orders 
WHERE id > 上次最後一個ID 
ORDER BY id 
LIMIT 20;
```

### 3. 文件系統的 B+ 樹

**ext4 文件系統**：
- 使用 **HTree**（Hash Tree，基於 B+ 樹）
- 存儲目錄項

**為什麼用 B+ 樹？**
- 目錄可能包含大量文件
- 需要快速查找文件名
- 支持高效的範圍掃描（ls 命令）

---

## 面試技巧與常見陷阱

### 1. 為什麼不用紅黑樹/哈希表？

| 數據結構 | 優點 | 缺點 | 適用場景 |
|---------|------|------|---------|
| **紅黑樹** | 查詢 O(log n) | 樹高 log n，I/O 多 | 內存數據結構 |
| **哈希表** | 查詢 O(1) | ❌ 不支持範圍查詢 | KV 存儲 |
| **B+ 樹** | 樹高低，I/O 少 | 實現複雜 | 磁碟數據結構 |

### 2. 為什麼 InnoDB 頁大小是 16KB？

**權衡考慮**：
- 太小（4KB）：需要更多層，增加 I/O
- 太大（64KB）：浪費空間，讀取慢

**16KB 的好處**：
- 與操作系統頁大小（4KB）的倍數
- 平衡了 I/O 次數和空間利用率

### 3. 為什麼主鍵建議自增？

**UUID 作為主鍵的問題**：
```
插入順序：
UUID: 550e8400-..., 3f8b7c92-..., 8e4d5a2c-...
       ↓              ↓              ↓
B+ 樹：需要不斷分裂和重組
```

**自增 ID 的優勢**：
```
插入順序：
ID: 1, 2, 3, 4, 5, ...
    ↓
B+ 樹：總是在最右邊插入，不需要分裂
```

**效果**：
- ✅ 插入效率高
- ✅ 頁分裂少
- ✅ 空間利用率高

---

## 複雜度分析

| 操作 | B 樹 | B+ 樹 | 說明 |
|------|------|-------|------|
| 查詢 | O(log_M N) | O(log_M N) | M 是階數 |
| 插入 | O(log_M N) | O(log_M N) | 包含分裂 |
| 刪除 | O(log_M N) | O(log_M N) | 包含合併 |
| 範圍查詢 | O(log_M N + K) | O(log_M N + K/M) | B+ 更快 |
| 空間 | O(N) | O(N) | B+ 葉子層更大 |

**實際性能**：
- MySQL InnoDB：M ≈ 1200（16KB 頁）
- 3 層 B+ 樹可存：1200³ ≈ 17 億條記錄
- 查詢任意記錄：3 次磁碟 I/O

---

## 延伸閱讀

- **MySQL 官方文檔**：[InnoDB Index Structure](https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html)
- **經典書籍**：《高性能 MySQL》第 5 章 - 索引
- **進階主題**：索引統計信息、索引碎片整理、自適應哈希索引
