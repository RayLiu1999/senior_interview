# Data Structures and Algorithms (資料結構與算法)

資料結構與算法是後端工程師的核心基礎，不僅是面試必考，更是實際工作中優化系統效能的關鍵。本章節聚焦於**面試高頻題目**和**實際後端應用場景**。

## 📋 題目索引

### 核心資料結構 (Data Structures)

#### 線性結構

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [陣列與動態陣列](./array_and_dynamic_array.md) | 3 | 5 | `陣列`, `動態擴容`, `時間複雜度` |
| [鏈結串列經典問題](./linked_list_problems.md) | 5 | 5 | `鏈結串列`, `快慢指針`, `反轉`, `環檢測` |
| [堆疊與佇列應用](./stack_and_queue_applications.md) | 4 | 5 | `堆疊`, `佇列`, `單調堆疊`, `優先佇列` |

#### 樹結構

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [二元搜尋樹 (BST) 原理](./binary_search_tree.md) | 5 | 5 | `BST`, `平衡樹`, `紅黑樹`, `AVL` |
| [B 樹與 B+ 樹詳解](./b_tree_and_b_plus_tree.md) | 7 | 5 | `B樹`, `B+樹`, `資料庫索引`, `MySQL` |
| [字典樹 (Trie) 應用](./trie_applications.md) | 6 | 4 | `Trie`, `前綴樹`, `自動補全`, `敏感詞過濾` |
| [二元樹遍歷與應用](./binary_tree_traversal.md) | 4 | 5 | `前序`, `中序`, `後序`, `層序遍歷` |

#### 雜湊結構

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [雜湊表原理與實現](./hash_table_implementation.md) | 6 | 5 | `雜湊函數`, `碰撞解決`, `一致性雜湊` |
| [布隆過濾器 (Bloom Filter)](./bloom_filter.md) | 6 | 5 | `布隆過濾器`, `Redis`, `去重`, `快取穿透` |
| [跳躍表 (Skip List)](./skip_list.md) | 7 | 4 | `跳躍表`, `Redis ZSet`, `有序集合` |

#### 堆與優先佇列

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [堆的實現與應用](./heap_implementation.md) | 6 | 5 | `最大堆`, `最小堆`, `堆排序`, `Top K` |
| [優先佇列實戰](./priority_queue_practice.md) | 5 | 4 | `優先佇列`, `任務調度`, `事件處理` |

#### 圖論

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [圖的表示與遍歷](./graph_representation_traversal.md) | 6 | 4 | `鄰接表`, `鄰接矩陣`, `BFS`, `DFS` |
| [最短路徑算法](./shortest_path_algorithms.md) | 7 | 4 | `Dijkstra`, `Bellman-Ford`, `Floyd` |
| [拓撲排序與依賴關係](./topological_sort.md) | 6 | 4 | `拓撲排序`, `DAG`, `任務依賴` |

### 核心算法 (Algorithms)

#### 排序算法

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [排序算法全解析](./sorting_algorithms_comparison.md) | 5 | 5 | `快排`, `歸併`, `堆排序`, `穩定性` |
| [排序算法實際應用](./sorting_practical_applications.md) | 6 | 4 | `外部排序`, `分散式排序`, `TopK` |

#### 搜尋算法

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [二分搜尋及其變體](./binary_search_variants.md) | 5 | 5 | `二分搜尋`, `查找邊界`, `旋轉陣列` |
| [深度優先搜尋 (DFS)](./depth_first_search.md) | 6 | 5 | `DFS`, `回溯`, `排列組合`, `路徑搜尋` |
| [廣度優先搜尋 (BFS)](./breadth_first_search.md) | 6 | 5 | `BFS`, `最短路徑`, `層級遍歷` |

#### 動態規劃

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [動態規劃基礎與套路](./dynamic_programming_basics.md) | 7 | 5 | `DP`, `狀態轉移`, `背包問題`, `最長子序列` |
| [動態規劃進階題型](./dynamic_programming_advanced.md) | 8 | 4 | `區間DP`, `狀態壓縮`, `樹形DP` |

#### 貪心算法

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [貪心算法原理與應用](./greedy_algorithm.md) | 6 | 4 | `貪心`, `區間問題`, `霍夫曼編碼` |

#### 雙指針與滑動窗口

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [雙指針技巧總結](./two_pointers_technique.md) | 5 | 5 | `雙指針`, `快慢指針`, `對撞指針` |
| [滑動窗口算法](./sliding_window_algorithm.md) | 6 | 5 | `滑動窗口`, `子串問題`, `最值問題` |

#### 位運算

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [位運算技巧與應用](./bit_manipulation.md) | 5 | 4 | `位運算`, `權限管理`, `狀態壓縮` |

### 實際應用場景 (Real-world Applications)

| 題目 | 難度 | 重要程度 | 標籤 |
|------|------|----------|------|
| [LRU 快取實現](./lru_cache_implementation.md) | 6 | 5 | `LRU`, `快取`, `雙向鏈結串列`, `HashMap` |
| [一致性雜湊在分散式系統中的應用](./consistent_hashing.md) | 7 | 5 | `一致性雜湊`, `負載均衡`, `分散式快取` |
| [限流算法實現](./rate_limiting_algorithms.md) | 6 | 5 | `令牌桶`, `漏桶`, `滑動窗口`, `限流` |
| [分散式 ID 生成算法](./distributed_id_generation.md) | 7 | 5 | `Snowflake`, `UUID`, `分散式ID` |
| [延遲佇列實現](./delayed_queue_implementation.md) | 7 | 4 | `延遲佇列`, `時間輪`, `定時任務` |
| [海量資料處理](./big_data_processing.md) | 8 | 4 | `bitmap`, `外部排序`, `分治`, `MapReduce` |

## 🎯 學習路徑建議

### 初級階段 (1-2 個月)

**目標**: 掌握基礎資料結構和常見算法

1. **基礎資料結構**
   - 陣列、鏈結串列、堆疊、佇列
   - 雜湊表基本概念
   - 二元樹基礎

2. **基礎算法**
   - 排序算法 (快排、歸併)
   - 二分搜尋
   - 雙指針技巧

3. **LeetCode 練習**
   - Easy: 50-100 題
   - 每天 2-3 題

**時間分配**: 理論學習 30% + 刷題實踐 70%

### 中級階段 (2-4 個月)

**目標**: 深入理解高級資料結構和算法思維

1. **高級資料結構**
   - 二元搜尋樹、紅黑樹
   - B 樹、B+ 樹 (資料庫索引)
   - 堆、優先佇列
   - 字典樹 (Trie)

2. **算法進階**
   - DFS/BFS
   - 動態規劃基礎
   - 滑動窗口
   - 貪心算法

3. **實際應用**
   - LRU 快取實現
   - 布隆過濾器
   - 一致性雜湊

4. **LeetCode 練習**
   - Medium: 100-200 題
   - 按類型刷題 (鏈結串列、樹、DP)

**時間分配**: 理論 20% + 刷題 50% + 實際應用 30%

### 高級階段 (4-6 個月)

**目標**: 精通複雜算法和系統設計

1. **高級算法**
   - 動態規劃進階
   - 圖論算法
   - 線段樹、樹狀陣列

2. **系統設計相關**
   - 限流算法
   - 分散式 ID 生成
   - 延遲佇列
   - 海量資料處理

3. **LeetCode 練習**
   - Hard: 50-100 題
   - 系統設計題
   - 競賽題目

**時間分配**: 算法深入 30% + 系統設計 40% + 刷題 30%

## 💡 核心知識點

### 1. 時間與空間複雜度

```
常見複雜度 (從優到劣):
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)

實際應用:
- O(1): 雜湊表查找、陣列索引
- O(log n): 二分搜尋、平衡樹操作
- O(n): 遍歷、線性搜尋
- O(n log n): 快排、歸併、堆排序
- O(n²): 冒泡排序、插入排序
```

### 2. 資料結構選擇

| 需求 | 推薦資料結構 | 時間複雜度 |
|-----|------------|-----------|
| 快速查找 | 雜湊表 | O(1) 平均 |
| 有序資料 | 紅黑樹、跳躍表 | O(log n) |
| 範圍查詢 | B+ 樹 | O(log n) |
| Top K | 堆 | O(n log k) |
| 快取淘汰 | LRU (鏈結串列+雜湊表) | O(1) |
| 去重檢測 | 布隆過濾器 | O(k) k=雜湊函數數量 |

### 3. 演算法模式

**滑動窗口**:
- 適用: 子串、子陣列問題
- 範例: 最長無重複子串、最小覆蓋子串

**雙指針**:
- 適用: 有序陣列、鏈結串列
- 範例: 兩數之和、移除重複元素

**DFS (深度優先)**:
- 適用: 排列組合、路徑問題
- 範例: 全排列、N 皇后、島嶼數量

**BFS (廣度優先)**:
- 適用: 最短路徑、層級遍歷
- 範例: 二元樹層序遍歷、最短路徑

**動態規劃**:
- 適用: 最優化問題、計數問題
- 範例: 背包問題、最長遞增子序列

### 4. 後端實際應用

**Redis 資料結構**:
- String: 簡單鍵值對
- Hash: 物件儲存
- List: 訊息佇列
- Set: 去重、交集運算
- ZSet: 排行榜 (跳躍表實現)

**MySQL 索引**:
- B+ 樹: InnoDB 主鍵索引
- 雜湊索引: Memory 引擎
- 全文索引: 倒排索引

**分散式系統**:
- 一致性雜湊: 負載均衡、快取分片
- 布隆過濾器: 快取穿透防護
- 限流算法: API 限流、防刷

## 📚 推薦資源

### 書籍

- 《算法導論》(CLRS) - 理論基礎聖經
- 《算法第4版》- Java 實現，易懂
- 《劍指 Offer》- 面試必讀
- 《LeetCode 101》- LeetCode 刷題指南

### 線上資源

- [LeetCode](https://leetcode.com/) - 刷題平台
- [LeetCode 中文](https://leetcode.cn/) - 中文版
- [代碼隨想錄](https://programmercarl.com/) - 系統學習路線
- [visualgo](https://visualgo.net/) - 算法視覺化

### 刷題策略

1. **按類型刷題** (推薦)
   - 先集中刷同類型 (如鏈結串列 20 題)
   - 總結套路和模板
   - 再換下一類型

2. **按難度刷題**
   - Easy → Medium → Hard
   - 循序漸進

3. **模擬面試**
   - 使用計時器 (30-45 分鐘)
   - 寫完整程式碼 (不只思路)
   - 考慮邊界情況

## 🔗 相關章節

- [作業系統](../Operating_System/) - 記憶體管理、程序調度
- [資料庫](../../02_Backend_Development/Databases/) - 索引結構、查詢優化
- [系統設計](../../03_System_Design_and_Architecture/) - 快取、限流、分散式

## 🎓 面試技巧

### 解題步驟

1. **理解題意** (2-3 分鐘)
   - 確認輸入輸出
   - 詢問邊界情況
   - 舉例說明

2. **思考方案** (5-10 分鐘)
   - 暴力解法
   - 優化思路
   - 權衡時空複雜度

3. **編寫程式碼** (15-20 分鐘)
   - 先寫框架
   - 再填細節
   - 邊寫邊解釋

4. **測試驗證** (5-10 分鐘)
   - 正常情況
   - 邊界情況
   - 錯誤情況

### 常見錯誤

- ❌ 不溝通直接寫程式碼
- ❌ 忽略邊界情況
- ❌ 程式碼格式混亂
- ❌ 不考慮時空複雜度
- ❌ 測試用例不全面

### 加分項

- ✅ 清晰的思路表達
- ✅ 多種解法對比
- ✅ 時空複雜度分析
- ✅ 考慮實際應用場景
- ✅ 程式碼可讀性高

## 🔧 Go 語言實現技巧

```go
// 1. 切片 (動態陣列)
nums := make([]int, 0, 10)  // 長度0，容量10
nums = append(nums, 1)

// 2. 雜湊表
m := make(map[string]int)
m["key"] = value
val, exists := m["key"]

// 3. 堆 (使用 container/heap)
type IntHeap []int
func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) }
func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

// 4. 排序
sort.Ints(nums)                          // 升序
sort.Slice(nums, func(i, j int) bool {   // 自訂排序
    return nums[i] > nums[j]
})

// 5. 二分搜尋
idx := sort.SearchInts(nums, target)
```

---

> **提示**: 資料結構與算法的學習需要**大量練習**。建議每天至少刷 2-3 題 LeetCode，持續 3-6 個月。重點不是刷題數量，而是**總結套路、形成模板、舉一反三**。結合實際後端場景 (Redis、MySQL、分散式系統) 理解資料結構的應用。
