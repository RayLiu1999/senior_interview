# TDD vs. BDD

- **難度**: 7
- **重要性**: 4
- **標籤**: `Testing`, `TDD`, `BDD`, `Methodology`

## 問題詳述

請解釋測試驅動開發 (Test-Driven Development, TDD) 和行為驅動開發 (Behavior-Driven Development, BDD) 分別是什麼。它們的核心思想和工作流程有何不同？BDD 是如何作為 TDD 的一種演進和補充而出現的？

## 核心理論與詳解

TDD 和 BDD 都是敏捷開發中重要的軟體開發方法論，它們都強調在編寫功能程式碼之前先編寫測試。然而，它們的關注點、協作方式和語言風格有著顯著的區別。BDD 通常被視為 TDD 的一種演進，旨在解決 TDD 在團隊協作和需求理解上的一些痛點。

---

### 測試驅動開發 (Test-Driven Development, TDD)

TDD 是一種**開發實踐**，它將軟體開發的順序顛倒過來。開發者不再是「先寫程式碼，再寫測試」，而是遵循一個簡短、重複的循環。

**TDD 的核心循環（紅-綠-重構）**:

1.  **紅色 (Red)**: **編寫一個失敗的測試**。
    -   首先，為一個即將開發的新功能或修復的 Bug 編寫一個自動化測試。因為功能程式碼還不存在，所以這個測試理所當然地會失敗（顯示為紅色）。
    -   這一步強迫開發者從「使用者」的角度思考：這個函式應該如何被呼叫？它的預期輸出是什麼？

2.  **綠色 (Green)**: **編寫最簡單的程式碼讓測試通過**。
    -   開發者的目標是盡快讓測試條變綠。在此階段，允許使用最簡單、最直接、甚至看起來有點「醜陋」的程式碼來滿足測試的要求。重點是快速通過測試，而不是追求完美的程式碼。

3.  **重構 (Refactor)**: **在測試保護下改進程式碼**。
    -   現在測試已經通過（變綠），開發者有了一個安全網。可以放心地重構剛剛編寫的程式碼，以及系統中其他相關的程式碼，以提高可讀性、消除重複、改善設計。
    -   每次重構後，都再次運行測試，確保沒有破壞任何現有功能。

**TDD 的關注點**:
-   **開發者中心**: TDD 主要是一種面向開發者的技術實踐。測試通常是用程式設計語言編寫的（例如，`assert.Equal(t, expected, actual)`），描述的是函式或方法的技術行為。
-   **單元正確性**: TDD 的焦點在於確保系統的**單元**（函式、類別）是正確且健壯的。

**TDD 的優點**:
-   產生高覆蓋率的單元測試。
-   提供快速回饋，降低除錯成本。
-   作為一個安全網，鼓勵開發者進行重構。
-   驅使產生更鬆耦合、更易於測試的設計。

---

### 行為驅動開發 (Behavior-Driven Development, BDD)

BDD 是 TDD 的一種**演進和擴展**。它繼承了 TDD「測試先行」的核心思想，但將焦點從「測試程式碼的技術實現」轉移到了「**驗證軟體的業務行為**」。

BDD 旨在彌合業務人員（如產品經理、分析師）、測試人員（QA）和開發人員之間的溝通鴻溝。

**BDD 的核心思想**:
-   **統一語言**: BDD 鼓勵團隊使用一種通用的、半格式化的自然語言來描述系統的行為。這種語言通常遵循 **Gherkin** 語法（`Given-When-Then`）。
-   **協作為中心**: BDD 是一種團隊協作方法。它鼓勵在開發開始前，由業務、測試和開發三方（通常稱為 "Three Amigos"）共同討論並定義出期望的系統行為。
-   **從外向內**: BDD 通常採用「從外向內」(Outside-In) 的開發方式。團隊首先定義高層次的、使用者可感知的行為（通常是驗收測試），然後逐步向內實現細節。

**BDD 的工作流程**:

1.  **發現 (Discover)**: 團隊共同討論一個使用者故事 (User Story)，並透過具體的範例來闡明其需求。
2.  **定義 (Define)**: 將這些範例寫成 **Gherkin** 格式的場景 (Scenarios)。
    ```gherkin
    Feature: 使用者登入

      Scenario: 成功登入
        Given 我是一個已註冊的使用者
        And 我在登入頁面
        When 我輸入正確的使用者名稱和密碼
        And 我點擊 "登入" 按鈕
        Then 我應該被重新導向到我的儀表板頁面
    ```
3.  **自動化 (Automate)**: 開發者將這些 Gherkin 步驟與實際的測試程式碼「黏合」起來。此時，由於功能尚未實現，測試會失敗。
4.  **實現 (Implement)**: 開發者編寫功能程式碼，直到之前失敗的行為測試通過。
5.  **驗證 (Verify)**: 測試通過，證明系統的行為符合業務期望。

**BDD 的關注點**:
-   **業務行為**: BDD 關注的是系統在特定場景下應該**做什麼 (what)**，而不是**如何做 (how)**。
-   **溝通與協作**: BDD 的核心價值在於促進團隊成員對需求的共同理解。

### TDD vs. BDD 的關鍵區別

| 特性 | TDD | BDD |
| :--- | :--- | :--- |
| **目的** | 驗證程式碼單元的正確性 | 驗證軟體是否滿足業務行為期望 |
| **協作者** | 主要是開發者 | 業務、測試、開發 (Three Amigos) |
| **語言** | 技術性語言 (程式碼) | 業務性、領域特定的自然語言 (Gherkin) |
| **焦點** | 函式/方法的實現 | 使用者故事/功能的行為 |
| **驅動力** | 測試 (Test) | 行為 (Behavior) / 範例 (Example) |
| **產出** | 一套健壯的單元測試 | 一套可執行的、活的系統規格文件 |

### BDD 作為 TDD 的演進

BDD 並不是要取代 TDD，而是對其的補充和完善。可以這樣理解它們的關係：
-   **BDD 解決了「測試什麼」的問題**: TDD 告訴你如何測試，但沒有明確指出你應該測試哪些東西。BDD 透過 `Given-When-Then` 的場景，為開發者提供了清晰的、來自業務需求的測試目標。
-   **BDD 是高層次的 TDD**: BDD 的場景通常作為高層次的驗收測試。在實現這些高層次行為的過程中，開發者仍然可以在更低的層級上使用傳統的 TDD 循環來開發各個具體的函式和類別。
-   **BDD 讓測試更具可讀性**: BDD 的測試描述了業務行為，即使非技術人員也能讀懂，這使得測試本身成為了團隊溝通的橋樑和系統的「活文件」。

### 結論

TDD 是一種強大的**開發技巧**，它透過「紅-綠-重構」的循環來驅動出高品質、高覆蓋率的程式碼。而 BDD 是一種更高層次的**團隊協作方法論**，它透過統一的語言和協作過程，確保團隊開發出真正滿足業務需求的軟體。

在實踐中，兩者可以完美結合：
-   使用 **BDD** 的原則和工具來進行高層次的**驗收測試**，確保軟體行為符合業務期望。
-   在實現 BDD 場景的過程中，使用 **TDD** 的循環來開發底層的**單元測試**，確保程式碼的健壯性和正確性。