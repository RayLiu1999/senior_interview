# 契約測試 (Contract Testing)

- **難度**: 7
- **重要程度**: 4
- **標籤**: `Testing`, `Microservices`, `API`, `Contract Testing`

## 問題詳述

什麼是契約測試？它與整合測試有何不同？在微服務架構中，契約測試如何幫助團隊獨立開發和部署服務，同時確保服務間的通訊不會中斷？

## 核心理論與詳解

契約測試是一種用於驗證**服務間交互**是否符合預期“契約”的測試方法。在微服務架構中，服務之間通過 API（如 REST 或 gRPC）進行通訊。契約測試確保服務的提供方（Provider）和消費方（Consumer）都遵守一個共享的契約，即使它們是獨立開發、測試和部署的。

### 核心概念

1. **契約 (Contract)**：
    - 契約是一個定義服務間交互期望的文件。它不是一個正式的法律文件，而是一個機器可讀的規範。
    - 對於 REST API，契約通常定義了：
        - 請求的 HTTP 方法、路徑、標頭和查詢參數。
        - 請求體的結構和數據類型。
        - 響應的狀態碼。
        - 響應體的結構和數據類型。
    - 常用的契約測試框架如 Pact 會自動生成和管理這些契約文件。

2. **消費方 (Consumer)**：
    - 發起請求並依賴其他服務的服務。例如，一個前端應用或另一個後端服務。

3. **提供方 (Provider)**：
    - 接收請求並提供響應的服務。

### 契約測試的工作流程

契約測試分為兩個主要階段：

1. **消費方驅動的契約生成 (Consumer-Driven Contract Testing)**：
    - **步驟 1：定義期望**：在消費方的單元測試中，開發者定義它期望從提供方獲得的響應。這會使用一個模擬（Mock）的提供方服務。
    - **步驟 2：運行測試並生成契約**：運行消費方的測試。當測試通過時，契約測試框架（如 Pact）會記錄下消費方與模擬提供方之間的交互，並生成一個契約文件（通常是 JSON 格式）。
    - **步驟 3：發布契約**：消費方將生成的契約文件發布到一個共享的中心位置，稱為 **Pact Broker**。

2. **提供方驗證契約**：
    - **步驟 1：獲取契約**：提供方服務從 Pact Broker 下載與其相關的所有契約。
    - **步驟 2：驗證契約**：提供方針對每個契約運行驗證測試。框架會根據契約中的請求，向正在運行的提供方服務發送真實的請求，並斷言其響應是否與契約中定義的響應匹配。
    - **步驟 3：發布驗證結果**：提供方將驗證結果發布回 Pact Broker。

### 契約測試 vs. 整合測試

| 特性 | 契約測試 | 傳統整合測試 |
| :--- | :--- | :--- |
| **目標** | 驗證服務間的**交互**是否符合契約 | 驗證整個系統或多個服務**端到端**的功能是否正常 |
| **耦合度** | **低**。服務可以獨立測試，無需同時運行所有依賴服務。 | **高**。需要部署和配置所有相關的服務，環境複雜。 |
| **執行速度** | **快**。類似於單元測試，可以在開發者的本地機器上快速運行。 | **慢**。涉及網路通訊和多個服務的啟動，耗時較長。 |
| **反饋循環** | **短**。提供方可以立即知道自己的變更是否破壞了消費方的期望。 | **長**。問題通常在 CI/CD 的後期階段才被發現，修復成本高。 |
| **錯誤定位** | **精確**。可以準確地定位到是哪個服務的哪個 API 破壞了契約。 | **困難**。端到端失敗時，難以快速確定是哪個服務出了問題。 |

### 為什麼在微服務中如此重要？

1. **實現獨立部署**：契約測試提供了一種信心，讓團隊可以獨立修改和部署自己的服務，而不用擔心會意外地破壞依賴它的其他服務。只要契約驗證通過，就意味著向後兼容性得到了保證。
2. **快速反饋**：開發者在本地就能快速驗證 API 的兼容性，無需等待漫長的整合測試流程。
3. **減少對複雜環境的依賴**：避免了搭建和維護一個包含所有微服務的龐大測試環境的開銷。

## 程式碼範例 (可選)

由於契約測試涉及框架和多個服務的交互，這裡提供一個基於 Pact 的概念性 Go 範例。

**消費方 (Consumer) 測試：**

```go
// consumer_test.go
func TestGetUser(t *testing.T) {
    // 1. 設置 Pact Mock Server
    pact := &dsl.Pact{ Consumer: "MyConsumer", Provider: "MyProvider" }
    pact.AddInteraction().
        Given("User with ID 1 exists"). // 設置提供方的狀態
        UponReceiving("A request to get user 1").
        WithRequest(dsl.Request{
            Method: "GET",
            Path:   dsl.String("/users/1"),
        }).
        WillRespondWith(dsl.Response{
            Status: 200,
            Body: dsl.Match(&User{}), // 期望響應體匹配 User 結構
        })

    // 2. 運行測試，Pact 會啟動一個模擬伺服器
    pact.Verify(t, func() error {
        // 3. 你的客戶端代碼，向模擬伺服器發送請求
        user, err := GetUserFromAPI("http://localhost:" + pact.Server.Port, 1)
        // ... 斷言 user 和 err
        return err
    })

    // 4. 測試通過後，會在 pacts/myconsumer-myprovider.json 生成契約文件
}
```

**提供方 (Provider) 驗證：**

提供方會運行一個驗證任務，該任務會：
1.  啟動提供方服務。
2.  從 Pact Broker 或本地文件讀取契約。
3.  Pact 框架根據契約向提供方服務發送請求。
4.  驗證實際響應是否符合契約中的期望。

這種方式確保了即使 Consumer 和 Provider 團隊在不同時間、不同地點工作，他們之間的 API 整合也能保持穩定可靠。
