# 變異測試 (Mutation Testing)

- **難度**: 8
- **重要程度**: 3
- **標籤**: `Testing`, `Mutation Testing`, `Test Quality`

## 問題詳述

什麼是變異測試？它與傳統的程式碼覆蓋率 (Code Coverage) 有何不同？變異測試如何幫助我們評估和提高測試套件的質量，以及它的主要挑戰是什麼？

## 核心理論與詳解

變異測試是一種用來評估**測試套件質量**的強大技術。它的核心思想是：如果你的測試寫得足夠好，那麼當產品代碼發生微小但關鍵的變異（即引入一個 bug）時，至少應該有一個測試會失敗。如果沒有任何測試失敗，就說明你的測試套件可能存在盲點，無法捕捉到這類錯誤。

### 變異測試的工作流程

變異測試的過程聽起來有些像科幻小說，它通過以下步驟進行：

1. **生成變異體 (Mutants)**：
    - 變異測試工具會自動地、系統性地修改你的源代碼，以生成大量的“變異體”。
    - 每個變異體都與原始代碼只有微小的差別。這些修改是基於一組預定義的“變異運算符 (Mutation Operators)”來完成的，例如：
        - **條件邊界變異**：將 `>` 變為 `>=`。
        - **邏輯運算符替換**：將 `&&` 變為 `||`。
        - **刪除語句**：刪除一行代碼（例如，`delete(myMap, "key")`）。
        - **返回值變異**：將 `return true` 變為 `return false`。
2. **運行測試**：
    - 針對每一個生成的變異體，工具會完整地運行你的整個測試套件。
3. **分析結果**：
    - 對於每個變異體，可能會出現以下三種結果：
        - **被殺死 (Killed)**：至少有一個測試因為代碼的變異而失敗。這是**我們期望的結果**，說明我們的測試套件成功地“捕捉”到了這個 bug。
        - **存活 (Survived)**：所有的測試都通過了，儘管代碼已經被修改。這是一個**壞信號**，意味著我們的測試套件沒有能力檢測到這種特定類型的錯誤。這暴露了測試的弱點。
        - **等價 (Equivalent)**：變異後的代碼在功能上與原始代碼完全等價（例如，將 `i = i + 1` 變為 `i++`）。這種變異體是無法被任何測試殺死的，需要手動識別並忽略。
4. **計算變異得分 (Mutation Score)**：
    - 變異得分是衡量測試套件質量的指標，計算公式為：
        $$
        \text{Mutation Score} = \frac{\text{Killed Mutants}}{\text{Total Mutants} - \text{Equivalent Mutants}} \times 100\%
        $$
    *   一個高的變異得分（例如 > 80%）通常意味著一個高質量的測試套件。

### 變異測試 vs. 程式碼覆蓋率

程式碼覆蓋率（如行覆蓋率、分支覆蓋率）是衡量測試質量的常用指標，但它存在一個致命的缺陷：**它只告訴你哪些代碼被執行了，而沒有告訴你這些代碼是否被有效地驗證了。**

看一個例子：

```go
func isPositive(num int) bool {
    if num >= 0 { // Bug: 應該是 num > 0
        return true
    }
    return false
}
```

一個簡單的測試：
```go
func TestIsPositive(t *testing.T) {
    isPositive(5) // 沒有斷言！
}
```

- **程式碼覆蓋率**：這個測試會達到 100% 的行覆蓋率和分支覆蓋率，因為代碼的每一行都被執行了。這給人一種虛假的安全感。
- **變異測試**：
    - 變異測試工具會將 `num >= 0` 變異為 `num > 0`。
    - 當運行 `TestIsPositive` 時，由於測試中沒有任何斷言 (Assertion)，測試仍然會通過。
    - 因此，這個變異體**存活**了下來。
    - 變異測試的結果告訴我們：你的測試只是“路過”了這段代碼，但並沒有真正地“測試”它。你需要添加一個斷言，如 `assert.True(t, isPositive(5))`，來殺死這個變異體。

**結論**：100% 的程式碼覆蓋率並不意味著你的測試是完美的，但 100% 的變異得分幾乎可以證明你的測試套件非常健壯。

### 挑戰與實踐

1. **計算成本高**：
    - 變異測試的主要缺點是執行速度非常慢。如果一個項目有 1000 個變異體和 1000 個測試，它可能需要運行一百萬次測試。
    - **解決方案**：
        - 不在每次 CI 中運行，而是在夜間或每週運行。
        - 只對新代碼或修改過的代碼進行變異測試。
        - 使用更智能的測試選擇算法。
2. **等價變異體問題**：
    - 識別和標記等價變異體通常需要手動介入，這會增加維護成本。

儘管存在挑戰，變異測試仍然是評估和提升測試質量的黃金標準。對於那些對可靠性要求極高的核心模組或函式庫，引入變異測試是非常有價值的投資。

**常用工具**：
- **Go**: `go-mutesting`
- **Java**: `Pitest`
- **JavaScript**: `Stryker`
