# 分散式交易與 Saga 模式

- **難度**: 9
- **重要性**: 5
- **標籤**: `Microservices`, `Distributed Systems`, `Saga Pattern`, `2PC`

## 問題詳述

在微服務架構中，單體應用中的 ACID 交易不再適用。請解釋為什麼，並詳細闡述兩種解決跨服務資料一致性問題的方案：兩階段提交 (2PC) 和 Saga 模式。請比較它們的優缺點。

## 核心理論與詳解

在微服務架構中，每個服務通常都有自己獨立的資料庫。這遵循了「關注點分離」和「鬆耦合」的原則。然而，當一個業務流程需要跨越多個服務時（例如，在電商系統中，「下訂單」操作需要同時更新 `訂單服務`、扣減 `庫存服務`、並通知 `物流服務`），我們就面臨了**分散式交易**的挑戰。

傳統的單體應用可以在單一資料庫內使用 ACID 交易來保證操作的原子性。但在微服務中，由於資料分散在不同的資料庫中，單一資料庫的交易機制無法跨越服務邊界，因此我們需要新的策略來保證資料的最終一致性。

---

### 兩階段提交 (Two-Phase Commit, 2PC)

2PC 是一種經典的、旨在實現**強一致性**的分散式交易協議。它引入了一個**交易協調者 (Coordinator)** 的角色來管理所有參與交易的服務（稱為 **參與者 (Participants)**）。

#### 運作流程

1.  **準備階段 (Prepare Phase)**:
    -   協調者向所有參與者發送一個「準備」請求，詢問它們是否可以執行交易。
    -   每個參與者會檢查自己是否能完成操作（例如，庫存是否足夠）。如果可以，它會鎖定相關資源，執行本地交易（但不提交），然後向協調者回覆「準備就緒」。如果不行，則回覆「否」。

2.  **提交階段 (Commit Phase)**:
    -   **情況一：所有參與者都回覆「準備就緒」**
        -   協調者向所有參與者發送「提交」請求。
        -   參與者收到提交請求後，完成本地交易（正式提交），釋放鎖定的資源，並向協調者回覆「完成」。
    -   **情況二：任何一個參與者回覆「否」或超時**
        -   協調者向所有參與者發送「回滾」請求。
        -   參與者收到回滾請求後，中止本地交易，釋放資源，並向協調者回覆「已回滾」。

#### 優缺點

-   **優點**:
    -   **強一致性**: 2PC 試圖實現原子性，保證所有參與者的操作要麼全部成功，要麼全部失敗。
    -   **原理簡單**: 相對來說，協議的邏輯比較直觀。

-   **缺點**:
    -   **同步阻塞**: 在整個交易過程中，所有參與者都需要鎖定資源，等待協調者的最終指令。這會導致系統吞吐量大幅下降，效能極差。
    -   **單點故障**: 協調者是整個系統的單點故障。如果協調者在提交階段崩潰，所有參與者都會被阻塞，不知道該提交還是回滾。
    -   **資料不一致風險**: 如果協調者在發送部分「提交」請求後崩潰，會導致只有一部分參與者提交了交易，造成資料不一致。
    -   **不適用於微服務**: 由於其同步阻塞和對網路可靠性的高要求，2PC 在強調高效能和鬆耦合的微服務架構中**極少被使用**。

---

### Saga 模式

Saga 是一種為了解決分散式交易所設計的模式，它放棄了強一致性，轉而追求**最終一致性 (Eventual Consistency)**。一個 Saga 由一系列的**本地交易 (Local Transaction)** 組成，每個本地交易都在單一服務內完成。

核心思想是：如果一個本地交易失敗，Saga 會執行一系列的**補償交易 (Compensating Transaction)** 來撤銷之前已經成功完成的本地交易。

#### 實現方式

有兩種主要的 Saga 協調方式：

##### 1. 編排 (Choreography)

-   **原理**: **去中心化**的協調方式。每個服務在完成自己的本地交易後，會發布一個**事件 (Event)**。其他服務會監聽這些事件，並觸發自己的本地交易。
-   **流程 (下訂單範例)**:
    1.  `訂單服務` 創建一個狀態為 `PENDING` 的訂單，然後發布 `ORDER_CREATED` 事件。
    2.  `庫存服務` 監聽到 `ORDER_CREATED` 事件，嘗試扣減庫存。
        -   **成功**: 發布 `INVENTORY_DEDUCTED` 事件。
        -   **失敗**: 發布 `INVENTORY_DEDUCTION_FAILED` 事件。
    3.  `支付服務` 監聽到 `INVENTORY_DEDUCTED` 事件，嘗試處理支付...
    4.  ...以此類推。
-   **補償流程**: 如果 `庫存服務` 失敗並發布 `INVENTORY_DEDUCTION_FAILED` 事件，`訂單服務` 會監聽到這個失敗事件，並執行自己的補償交易（例如，將訂單狀態改為 `CANCELLED`）。

-   **優點**:
    -   **鬆耦合**: 服務之間沒有直接調用，只需關心事件。
    -   **簡單直觀**: 對於簡單的業務流程，實現起來很直接。

-   **缺點**:
    -   **難以追蹤**: 業務流程分散在各個服務的事件監聽器中，很難直觀地看出完整的交易流程。
    -   **循環依賴風險**: 服務之間可能形成複雜的循環事件依賴。
    -   **測試困難**: 端到端測試需要啟動所有相關服務。

##### 2. 協同 (Orchestration)

-   **原理**: **中心化**的協調方式。引入一個**Saga 協同器 (Orchestrator)**，它負責集中管理整個 Saga 的流程。
-   **流程 (下訂單範例)**:
    1.  客戶端請求 `Saga 協同器` 開始「下訂單」流程。
    2.  協同器向 `訂單服務` 發送一個命令 `CreateOrder`。
    3.  `訂單服務` 完成後，回覆協同器。
    4.  協同器接著向 `庫存服務` 發送命令 `DeductInventory`。
        -   **成功**: `庫存服務` 回覆成功，協同器繼續下一步。
        -   **失敗**: `庫存服務` 回覆失敗。協同器會向 `訂單服務` 發送一個**補償命令** `CancelOrder`。
    5.  協同器負責調度所有正向交易和補償交易。

-   **優點**:
    -   **集中管理**: 業務流程的定義是集中的，易於理解和維護。
    -   **避免循環依賴**: 服務之間沒有直接的事件依賴，只與協同器通訊。
    -   **易於測試和監控**: 可以更容易地監控和調試 Saga 的狀態。

-   **缺點**:
    -   **引入額外組件**: 需要設計和維護協同器本身。
    -   **耦合風險**: 協同器與參與者之間存在一定的耦合。

### 2PC vs. Saga 總結

| 特性 | 兩階段提交 (2PC) | Saga 模式 |
| :--- | :--- | :--- |
| **一致性模型** | 強一致性 (ACID) | 最終一致性 (BASE) |
| **協調方式** | 同步阻塞 | 非同步 |
| **資源鎖定** | 長時間鎖定資源 | 短時間本地交易，無長期鎖定 |
| **效能** | 差，吞吐量低 | 好，吞吐量高 |
| **複雜性** | 協議本身有風險 | 補償邏輯和狀態管理較複雜 |
| **適用場景** | 極少用於現代微服務 | 絕大多數需要跨服務一致性的場景 |

### 結論

在微服務架構中，由於對效能、擴展性和服務自治性的要求，我們通常會選擇**放棄強一致性，轉而擁抱最終一致性**。**Saga 模式**正是實現最終一致性的關鍵設計模式。與笨重且問題多多的 2PC 相比，Saga 提供了更高的吞吐量和更好的系統韌性。在協同 (Orchestration) 和編排 (Choreography) 之間，協同模式由於其清晰的流程管理和可維護性，在複雜的業務場景中更受青睞。
