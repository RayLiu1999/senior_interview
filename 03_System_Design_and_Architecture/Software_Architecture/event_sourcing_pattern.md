# 事件溯源 (Event Sourcing)

- **難度**: 9
- **重要性**: 4
- **標籤**: `Software Architecture`, `Event Sourcing`, `CQRS`, `System Design`

## 問題詳述

請解釋什麼是事件溯源 (Event Sourcing) 模式。它的核心思想是什麼？與傳統的狀態儲存 (State-Oriented Persistence) 相比，事件溯源有哪些獨特的優點和挑戰？

## 核心理論與詳解

事件溯源是一種截然不同的資料持久化模式。在傳統的**狀態儲存**模型中，我們通常只關心實體的**當前狀態**。例如，在資料庫中，一個 `Product` 表的一行只記錄了該產品目前的價格、庫存等資訊。當價格更新時，舊的價格就被覆蓋掉了。

而**事件溯源 (Event Sourcing)** 的核心思想是：**不儲存實體的當前狀態，而是儲存導致該狀態變更的所有事件的序列**。系統的當前狀態是透過從頭到尾重放 (replay) 這些事件計算得出的。

每一個事件都代表了系統中發生過的一個不可變的事實。例如：
-   `ProductCreated` (品名: "蘋果", 初始庫存: 100)
-   `ProductPriceAdjusted` (新價格: 10.5)
-   `InventoryReceived` (入庫數量: 50)
-   `ProductSold` (售出數量: 10)

這些事件被依序儲存在一個僅能附加 (append-only) 的事件儲存 (Event Store) 中。

---

### 事件溯源的工作流程

1.  **命令處理**: 當系統接收到一個命令（例如，`AdjustPriceCommand`）時，命令處理器會驗證該命令。
2.  **產生事件**: 如果命令有效，它會產生一個或多個代表狀態變更的事件（例如，`ProductPriceAdjusted`）。
3.  **儲存事件**: 這些事件被持久化到事件儲存中。**這是唯一的寫入操作**。
4.  **狀態重建**: 要獲取一個實體（例如，某個產品）的當前狀態，系統會從事件儲存中讀取該實體的所有歷史事件，並在一個空白的實體物件上依序應用它們。
    -   `Product p = new Product()`
    -   `p.apply(ProductCreated)` -> `p.stock = 100`
    -   `p.apply(ProductPriceAdjusted)` -> `p.price = 10.5`
    -   `p.apply(InventoryReceived)` -> `p.stock = 150`
    -   `p.apply(ProductSold)` -> `p.stock = 140`
    -   最終得到 `p` 的當前狀態。

---

### 優點

1.  **完整的審計日誌 (Complete Audit Log)**:
    -   由於儲存了所有歷史事件，事件溯源天然地提供了一份完整的、不可變的審計日誌。你可以準確地知道系統在任何時間點的狀態，以及它是如何達到那個狀態的。這對於除錯、業務分析和合規性要求非常有價值。

2.  **時間旅行 (Temporal Querying)**:
    -   你可以輕易地重建出系統在**過去任何時間點**的狀態，只需重放該時間點之前的所有事件即可。這對於分析歷史趨勢、重現 Bug 等場景極為有用。

3.  **簡化寫入模型**:
    -   寫入操作變得極其簡單和高效：只需向事件儲存附加一個新的事件即可。這避免了複雜的 `UPDATE` 操作和資料庫鎖。

4.  **與 CQRS 的完美結合**:
    -   事件溯源是 CQRS 模式中**寫入端**的理想實現。事件儲存中的事件流可以作為一個可靠的**事件匯流排 (Event Bus)**，將狀態變更非同步地發布給**讀取端**。
    -   讀取端可以訂閱這些事件，並根據需要構建任意多個、任意結構的**讀取模型 (Read Models / Projections)**。例如，一個事件流可以同時更新一個關聯式資料庫、一個 Elasticsearch 索引和一個快取。

5.  **靈活的未來視角**:
    -   如果未來出現了新的業務需求，需要一個全新的資料視圖，你不需要進行複雜的資料遷移。你只需創建一個新的投影 (Projection)，然後從頭開始重放所有歷史事件，就能生成這個新的讀取模型。

### 缺點與挑戰

1.  **查詢複雜性**:
    -   事件儲存本身是為寫入優化的，不適合直接查詢。你**不能**直接查詢「所有庫存大於 100 的產品」。
    -   這幾乎**強制**你必須結合 **CQRS** 模式，創建專門的讀取模型來滿足查詢需求。因此，事件溯源和 CQRS 通常是相伴而生的。

2.  **最終一致性**:
    -   與 CQRS 結合時，從事件產生到讀取模型更新之間存在延遲，系統是最終一致性的。

3.  **事件結構的演進 (Schema Evolution)**:
    -   事件一旦被儲存，就是不可變的。如果未來你需要修改某個事件的結構（例如，為 `ProductCreated` 事件新增一個 `category` 欄位），這會變得很棘手。
    -   通常需要引入版本控制機制，並在重放事件時處理不同版本的事件，這增加了複雜性。

4.  **學習曲線陡峭**:
    -   事件溯源是一種與傳統思維方式截然不同的模式。開發人員需要時間來適應這種基於事件的思考方式。

5.  **快照 (Snapshotting)**:
    -   對於生命週期很長、事件數量極多的實體，每次都從頭重放所有事件會導致效能問題。
    -   為了解決這個問題，需要引入**快照**機制：定期將實體的某個狀態版本儲存起來。當需要重建狀態時，只需從最近的快照開始，然後重放該快照之後的事件即可。這也增加了系統的複雜性。

### 結論

事件溯源是一個非常強大的模式，它透過儲存事件而非狀態，為系統帶來了前所未有的審計能力、時間旅行功能和架構靈活性。然而，它的這些優點是以更高的架構複雜性、陡峭的學習曲線以及必須處理最終一致性為代價的。

它通常不適用於簡單的 CRUD 應用。但在業務邏輯複雜、需要完整追溯歷史、並且對未來擴展性有高要求的領域（如金融、保險、電子商務核心系統），事件溯源與 CQRS 的組合拳能夠構建出極其健壯和靈活的系統。
