# 如何設計即時通訊系統？

- **難度**: 8
- **重要程度**: 5
- **標籤**: `System Design`, `Instant Messaging`, `WebSocket`, `Real-time`

## 問題詳述

即時通訊系統（如 WhatsApp、Telegram、微信）需要支援億級用戶的實時消息傳遞、群組聊天、多媒體分享等功能。請設計一個高可用、低延遲的即時通訊系統，需要考慮：

1. **核心功能**：如何實現一對一聊天、群組聊天、消息送達確認？
2. **實時通訊**：如何建立長連接並保持在線狀態？
3. **消息可靠性**：如何確保消息不丟失、不重複、有序送達？
4. **離線消息**：如何處理用戶離線時的消息推送？
5. **擴展性**：如何支撐億級用戶和百萬級併發連接？

## 核心理論與詳解

即時通訊系統是一個對實時性、可靠性要求極高的分散式系統，需要處理長連接管理、消息路由、狀態同步等複雜問題。

### 1. 核心功能架構

#### 基本消息流程

- **一對一聊天**：
  1. 用戶 A 發送消息到 IM 服務器
  2. 服務器驗證身份和權限
  3. 消息持久化到資料庫
  4. 查找用戶 B 的連接所在服務器
  5. 將消息推送給用戶 B
  6. 用戶 B 收到消息後返回 ACK 確認
  7. 服務器通知用戶 A 消息已送達

- **群組聊天**：
  1. 用戶 A 發送消息到群組
  2. 服務器查詢群組成員列表
  3. 消息持久化並為每個成員創建一份推送任務
  4. 並行推送給所有在線成員
  5. 離線成員的消息標記為待推送

#### 消息狀態

消息在系統中有多種狀態：

- **已發送（Sent）**：客戶端成功發送到服務器
- **已送達（Delivered）**：服務器成功推送到接收方客戶端
- **已讀（Read）**：接收方已讀消息
- **失敗（Failed）**：發送失敗（網路錯誤、對方不存在等）

### 2. 長連接管理

#### WebSocket vs TCP

- **WebSocket**：
  - 基於 HTTP 升級，瀏覽器原生支援
  - 適合 Web 端和跨平台應用
  - 防火牆友好（使用 80/443 端口）
  - 有一定的協議開銷

- **自定義 TCP 協議**：
  - 客戶端 App 可以使用自定義二進制協議
  - 更高效，開銷更小
  - 需要自行實現心跳、斷線重連等機制
  - WhatsApp 使用 XMPP 協議，微信使用自研協議

#### 連接服務器（Gateway）

- **職責**：
  - 維護客戶端的長連接
  - 處理心跳保活
  - 消息的接收和推送
  - 連接狀態管理

- **無狀態設計**：
  - Gateway 服務器本身無狀態
  - 連接狀態儲存在 Redis（用戶 ID → Gateway 地址）
  - 便於水平擴展和故障轉移

- **心跳機制**：
  - 客戶端定期發送心跳包（如每 30 秒）
  - 服務器超時未收到心跳則認為連接斷開
  - 使用 TCP Keepalive 或應用層心跳

#### 斷線重連

- **客戶端策略**：
  - 檢測到連接斷開後自動重連
  - 使用指數退避策略（1s, 2s, 4s, 8s...）
  - 重連成功後拉取離線消息

- **消息同步**：
  - 客戶端記錄最後收到的消息 ID
  - 重連後請求該 ID 之後的所有消息
  - 確保消息不丟失

### 3. 消息路由與推送

#### 路由策略

當用戶 A 向用戶 B 發送消息時，系統需要找到用戶 B 連接的 Gateway 服務器。

- **連接狀態表**：
  - 使用 Redis 儲存：`user:{user_id} → {gateway_ip, gateway_port}`
  - 用戶上線時寫入，下線時刪除
  - 使用 Redis Pub/Sub 或消息隊列通知 Gateway

- **路由過程**：
  1. 用戶 A 的消息到達 Gateway-1
  2. Gateway-1 查詢 Redis，發現用戶 B 在 Gateway-2
  3. Gateway-1 透過 RPC 或消息隊列發送消息到 Gateway-2
  4. Gateway-2 推送消息給用戶 B

#### 群組消息推送

群組消息的推送是一個複雜的問題，特別是大群（數千人以上）。

- **小群（< 100 人）**：
  - 直接並行推送給所有在線成員
  - 在業務服務器層面展開推送

- **大群（100-1000 人）**：
  - 使用寫擴散模式
  - 為每個成員的收件箱寫入一份消息副本
  - 客戶端拉取各自收件箱的消息

- **超大群（> 1000 人）**：
  - 使用讀擴散模式
  - 消息只儲存一份，記錄在群組時間線
  - 客戶端主動拉取群組時間線
  - 減少寫入壓力

#### 在線狀態廣播

- **朋友在線狀態**：
  - 用戶上線時，通知其所有好友
  - 使用批量推送優化（合併多個用戶的狀態變更）
  - 大量好友時使用延遲廣播（如 5 秒內的變更合併）

- **群組在線狀態**：
  - 超大群不廣播成員在線狀態（成本太高）
  - 僅在用戶主動查詢時返回

### 4. 消息可靠性保證

#### 消息去重

- **冪等性保證**：
  - 每條消息分配全域唯一 ID（message_id）
  - 客戶端使用 UUID 或雪花算法生成
  - 服務器收到消息時檢查 message_id 是否已處理

- **重複檢測**：
  - 使用 Redis 或 Bloom Filter 快速檢測重複
  - 設置過期時間（如 7 天），自動清理舊記錄

#### 消息順序性

- **單聊順序**：
  - 使用遞增的消息序列號（sequence）
  - 客戶端按序列號排序展示
  - 檢測到序列號跳躍時主動拉取缺失消息

- **群聊順序**：
  - 使用時間戳 + 服務器序列號
  - 客戶端根據時間戳排序
  - 時間戳相同時使用序列號

#### ACK 確認機制

三次握手確認機制：

1. **Client → Server ACK**：
   - 客戶端發送消息後等待服務器 ACK
   - 超時未收到則重試

2. **Server → Receiver ACK**：
   - 服務器推送給接收方後等待 ACK
   - 確認接收方已收到消息

3. **Read Receipt**：
   - 接收方閱讀消息後發送已讀回執
   - 發送方顯示"已讀"狀態

### 5. 離線消息處理

#### 離線消息存儲

- **個人收件箱**：
  - 為每個用戶維護一個離線消息隊列
  - 使用 Redis List 或 Kafka Topic
  - 消息按時間順序儲存

- **持久化策略**：
  - 熱數據（最近 7 天）存在 Redis
  - 冷數據存在 MySQL 或 HBase
  - 客戶端上線後拉取離線消息

#### 推送通知（Push Notification）

當用戶離線時，通過系統推送通知用戶。

- **推送服務整合**：
  - iOS：APNs（Apple Push Notification service）
  - Android：FCM（Firebase Cloud Messaging）、廠商推送（華為、小米等）
  - Web：Web Push API

- **推送策略**：
  - 重要消息（好友消息）立即推送
  - 群組消息合併推送（避免打擾）
  - 用戶可自定義推送偏好

- **推送內容**：
  - 敏感內容不直接推送（僅顯示"你有新消息"）
  - 推送後端到端加密的消息摘要
  - 點擊推送後拉取完整消息

### 6. 多媒體消息處理

#### 圖片和檔案傳輸

- **上傳流程**：
  1. 客戶端先上傳圖片到對象儲存（S3、OSS）
  2. 獲得圖片 URL 後發送包含 URL 的消息
  3. 接收方下載圖片並展示

- **縮圖優化**：
  - 自動生成多種尺寸的縮圖
  - 聊天列表顯示小圖，點擊查看大圖
  - 使用 WebP 格式減少流量

- **斷點續傳**：
  - 大檔案支援分片上傳和斷點續傳
  - 使用 Range 請求下載部分內容

#### 語音和視頻消息

- **壓縮編碼**：
  - 語音使用 Opus 或 AAC 編碼
  - 視頻使用 H.264 編碼
  - 平衡品質和檔案大小

- **實時語音/視頻通話**：
  - 使用 WebRTC 建立 P2P 連接
  - 使用 TURN 服務器中繼（無法 P2P 時）
  - 支援多人視頻會議（使用 SFU 架構）

### 7. 資料庫設計

#### 消息表設計

- **分表策略**：
  - 按用戶 ID 或會話 ID 分表
  - 單表數據量控制在千萬級別
  - 歷史消息歸檔到冷儲存

- **核心欄位**：
  - `message_id`：全域唯一消息 ID
  - `conversation_id`：會話 ID（單聊或群聊）
  - `sender_id`：發送者 ID
  - `content`：消息內容（可加密）
  - `type`：消息類型（文字、圖片、語音等）
  - `timestamp`：發送時間
  - `status`：消息狀態

#### 會話表設計

- **最近會話列表**：
  - 每個用戶維護一個會話列表
  - 包含最後一條消息、未讀數、置頂狀態
  - 使用 Redis 快取熱數據

- **未讀計數**：
  - 使用 Redis 計數器：`unread:{user_id}:{conversation_id}`
  - 讀取消息後歸零
  - 定期同步到資料庫

### 8. 安全與隱私

#### 端到端加密（E2EE）

- **Signal 協議**：
  - WhatsApp、Signal 使用的加密協議
  - 只有通訊雙方能解密消息內容
  - 服務器無法讀取消息

- **密鑰交換**：
  - 使用 Diffie-Hellman 密鑰交換
  - 每個會話使用獨立的會話密鑰
  - 支援完美前向保密（PFS）

#### 防垃圾消息

- **頻率限制**：
  - 限制單個用戶的消息發送頻率
  - 新用戶有更嚴格的限制

- **內容審核**：
  - 使用 AI 識別垃圾消息和違規內容
  - 用戶舉報機制
  - 違規用戶封禁

### 9. 高可用架構

#### 多機房部署

- **跨地域部署**：
  - 在多個地理位置部署機房
  - 用戶連接到最近的機房
  - 機房之間消息同步

- **故障切換**：
  - Gateway 故障時，客戶端自動重連到其他 Gateway
  - 使用健康檢查和負載均衡器
  - Redis 使用 Sentinel 或 Cluster 模式

#### 數據一致性

- **最終一致性**：
  - 跨機房的消息同步使用最終一致性模型
  - 使用消息隊列（Kafka）進行跨機房同步
  - 接受短暫的延遲（通常 < 1 秒）

- **衝突解決**：
  - 使用時間戳或向量時鐘解決衝突
  - Last-Write-Wins 策略

### 10. 性能優化

#### 連接優化

- **連接池復用**：
  - Gateway 之間使用連接池
  - 減少 TCP 握手開銷

- **批量操作**：
  - 合併多個小消息一次性推送
  - 減少網路 I/O 次數

#### 快取策略

- **多級快取**：
  - 本地快取（Gateway 記憶體）：用戶基本資訊
  - 分散式快取（Redis）：會話列表、在線狀態
  - 資料庫：持久化數據

- **快取預熱**：
  - 用戶上線時預載入常用數據
  - 熱點數據常駐快取

#### 資料庫優化

- **讀寫分離**：
  - 寫操作走主庫
  - 讀操作走從庫（如查詢歷史消息）

- **索引優化**：
  - 在 `conversation_id + timestamp` 上建立複合索引
  - 加速歷史消息查詢

## 架構總結

一個完整的即時通訊系統架構包含：

1. **接入層**：Gateway 服務器（WebSocket/TCP 長連接）
2. **業務層**：消息服務、會話服務、用戶服務
3. **路由層**：消息路由、在線狀態管理（Redis）
4. **儲存層**：消息資料庫（分表）、對象儲存（多媒體）
5. **推送層**：離線推送服務（APNs、FCM）
6. **通話層**：WebRTC 信令服務器、TURN 服務器
7. **監控層**：消息送達率、延遲監控、連接數監控

透過合理的架構設計和技術選型，即時通訊系統可以支撐億級用戶的實時通訊需求，提供低延遲、高可靠的消息傳遞體驗。
