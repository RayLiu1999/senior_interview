# 使用 Pub/Sub 建立可靠的聊天系統

- **難度**: 8
- **重要性**: 4
- **標籤**: `System Design`, `Chat`, `Redis`, `Pub/Sub`, `Architecture`

## 問題詳述

很多人說 Redis 的 Pub/Sub 適合用來做聊天室，但 Pub/Sub 本身是「發後不理」的，會導致訊息丟失。如何設計一個既能利用 Pub/Sub 的即時性，又能保證訊息不丟失的**可靠**聊天系統？

## 核心理論與詳解

這個問題非常好，它直接觸及了系統設計中的一個核心議題：**如何組合不同的技術來揚長避短**。單純使用 Pub/Sub 確實無法建立一個可靠的聊天系統，因為它不負責持久化。一個健壯的聊天系統，必須採用**混合架構 (Hybrid Architecture)**，將 Pub/Sub 的「快」和另一個持久化系統的「穩」結合起來。

在這個架構中，不同的元件扮演不同的角色：
- **Pub/Sub (如 Redis Pub/Sub, NATS)**: 扮演**「快遞員」**的角色，負責將新訊息**即時**派送給所有**在線**的用戶。它的優點是快、廣播能力強。
- **持久化儲存 (如 Redis Stream, Kafka, 資料庫)**: 扮演**「倉庫」**的角色，負責儲存**所有**的訊息備份。無論用戶是否在線，訊息都會在這裡保管，確保萬無一失。

---

### 系統工作流程設計

下面是一個典型的可靠聊天系統的工作流程，它結合了 WebSocket、應用伺服器、Pub/Sub 和持久化儲存。

#### 場景一：用戶 A 發送訊息

1.  **客戶端發送 (Client Sends)**:
    - 用戶 A 在客戶端（Web 或 App）輸入訊息 "Hello"。
    - 客戶端透過一個持久的 **WebSocket** 連線，將訊息發送到應用伺服器。

2.  **伺服器處理 (Server Processes)**:
    - 應用伺服器接收到訊息。
    - **步驟 1 (持久化 - 最重要的一步)**: 伺服器首先將這條訊息寫入**持久化儲存**中。這一步是確保訊息永不丟失的關鍵。
        - **寫入目標**: 可以是一個代表該聊天室的 Redis Stream、一個 Kafka Topic，或是一個資料庫的 `messages` 表。
        - **訊息內容**: 儲存完整的訊息內容，包括發送者 ID、聊天室 ID、內容、時間戳等。
    - **步驟 2 (即時推送)**: 訊息**成功儲存後**，伺服器再將這條訊息透過 **Redis Pub/Sub** 的特定頻道（例如 `chat_room:123`）發布 (Publish) 出去。
        - **發布內容**: 可以是完整的訊息，也可以只是一個包含訊息 ID 的輕量級通知。

3.  **在線用戶接收 (Online Users Receive)**:
    - 所有當前**在線**並訂閱了該 Pub/Sub 頻道的用戶（例如用戶 B），他們的 WebSocket 連線會立刻收到這條 "Hello" 訊息。
    - 客戶端收到訊息後，將其渲染到畫面上。

![Chat Send Flow](https://i.imgur.com/example.png)  <!-- 這裡可以放一個流程圖 -->

#### 場景二：用戶 C 剛剛上線或從後台切回

1.  **客戶端連接 (Client Connects)**:
    - 用戶 C 的 App 啟動，或從後台喚醒，與伺服器建立 WebSocket 連線。

2.  **拉取歷史/離線訊息 (Client Pulls History)**:
    - 客戶端向伺服器發送一個請求，例如 `GET /api/messages?room_id=123&last_sync_timestamp=...`。
    - `last_sync_timestamp` 告訴伺服器該用戶上次同步到哪裡。

3.  **伺服器響應 (Server Responds)**:
    - 伺服器查詢**持久化儲存**（Redis Stream 或資料庫），找出在 `last_sync_timestamp` 之後的所有訊息。
    - 伺服器將這些錯過的訊息一次性透過 HTTP 或 WebSocket 推送給用戶 C。

4.  **訂閱即時訊息 (Subscribe to Real-time)**:
    - 當歷史訊息同步完成後，用戶 C 的客戶端通知伺服器：「我準備好了，可以接收即時訊息了」。
    - 伺服器將用戶 C 的連線加入到對應聊天室的 Pub/Sub 頻道訂閱列表中。
    - 從此刻起，用戶 C 就能像用戶 B 一樣，即時接收到新的聊天訊息。

### 技術選型的考量

- **為什麼持久化儲存推薦 Redis Stream？**
    - **消費者群組**: Redis Stream 支持消費者群組，可以追蹤每個用戶消費到哪條訊息，非常適合處理「離線訊息拉取」的場景。
    - **持久化**: 它提供了可靠的持久化能力。
    - **整合性**: 如果已經在使用 Redis，那麼使用 Stream 可以保持技術棧的統一。

- **NATS 作為替代方案**
    - NATS 是一個現代化的訊息系統，它本身就完美地融合了這兩種模式：
        - **Core NATS**: 提供極致性能的 Pub/Sub 功能（對應 Redis Pub/Sub）。
        - **NATS JetStream**: 提供持久化的 Stream 功能（對應 Redis Stream 或 Kafka）。
    - 對於一個從零開始的、特別是使用 Go 語言的專案，直接選擇 NATS 可以提供一個更統一、更專注於訊息傳遞的解決方案。

### 結論

一個可靠的聊天系統並非單一技術的產物，而是一個精心設計的組合。它利用 Pub/Sub 來實現低延遲的**即時廣播**，同時依賴一個獨立的持久化系統來保證訊息的**完整性和可追溯性**。

這個「持久化 + 推送」的混合模型，不僅適用於聊天系統，也廣泛應用於需要結合可靠性和即時性的各種現代應用程式架構中，是系統設計面試中的一個重要模式。
