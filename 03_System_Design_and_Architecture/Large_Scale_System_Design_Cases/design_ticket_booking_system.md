# 如何設計購票系統？

- **難度**: 9
- **重要程度**: 5
- **標籤**: `System Design`, `Ticket Booking`, `High Concurrency`, `Payment`

## 問題詳述

線上購票系統（如 KKTIX、Ticketmaster）需要處理高併發搶票場景，確保票券不超賣、支付流程可靠，並提供良好的用戶體驗。請設計一個可擴展的購票系統，需要考慮：

1. **核心功能**：如何實現活動發布、座位選擇、訂單創建、支付處理和票券發放？
2. **超賣問題**：如何在高併發情況下防止票券超賣？
3. **公平性**：如何確保購票過程的公平性，防止黃牛和機器人？
4. **支付流程**：如何設計可靠的支付流程，處理支付失敗和超時？
5. **擴展性**：如何應對熱門活動開賣瞬間的流量峰值？

## 核心理論與詳解

購票系統是典型的高併發、強一致性場景，需要在性能、一致性和用戶體驗之間取得平衡。

### 1. 核心功能分析

#### 主要業務流程

- **活動管理**：
  - 主辦方創建活動，設置票種、價格、數量、開賣時間
  - 支援座位選擇（如演唱會）或無座位（如展覽）
  - 設置購票規則（每人限購數量、身份驗證要求）

- **購票流程**：
  1. 用戶瀏覽活動並選擇票種/座位
  2. 系統鎖定座位，創建臨時訂單（有時效性）
  3. 用戶填寫資訊並進入支付
  4. 支付完成後確認訂單，發放電子票券
  5. 若超時未支付，釋放鎖定的座位

- **票券管理**：
  - 生成唯一的票券 ID 和 QR Code
  - 支援票券轉讓、退票
  - 入場驗證和防偽

### 2. 超賣問題的解決方案

超賣是購票系統最核心的技術挑戰，需要確保在高併發下不會售出超過庫存數量的票券。

#### 方案一：資料庫悲觀鎖

- **實現**：使用 `SELECT ... FOR UPDATE` 鎖定票券記錄
- **優點**：
  - 實現簡單，邏輯清晰
  - 強一致性保證
- **缺點**：
  - 性能較差，高併發下會產生大量鎖等待
  - 容易造成死鎖
  - 不適合極高併發場景

#### 方案二：樂觀鎖 + 版本號

- **實現**：
  - 在票券表增加 `version` 欄位
  - 更新時檢查版本號：`UPDATE tickets SET sold = sold + 1, version = version + 1 WHERE id = ? AND version = ? AND sold < total`
  - 若更新失敗（version 不匹配），說明有併發衝突，需要重試
- **優點**：
  - 無鎖等待，性能較好
  - 適合衝突較少的場景
- **缺點**：
  - 高併發下重試次數多，用戶體驗差
  - 可能導致"驚群效應"

#### 方案三：Redis 原子操作（推薦）

- **實現**：
  - 使用 Redis 的 `DECR` 或 `INCRBY` 原子操作扣減庫存
  - Redis 單線程模型天然支援原子性
  - 扣減成功後，非同步寫入資料庫
- **優點**：
  - 性能極高，支援百萬級 QPS
  - 天然的原子性保證
  - 無鎖設計，無死鎖風險
- **缺點**：
  - 需要處理 Redis 與資料庫的數據同步
  - Redis 故障時需要有恢復機制

#### 方案四：分段庫存

- **實現**：
  - 將總庫存分成多個段，每個應用服務器實例獲取一段庫存
  - 在本地記憶體中扣減，減少 Redis 訪問
  - 當本地庫存耗盡時，再向 Redis 申請新的庫存段
- **優點**：
  - 進一步提升性能
  - 減少網路 I/O
- **缺點**：
  - 實現較複雜
  - 服務器宕機時會有少量庫存浪費

### 3. 座位鎖定機制

#### 臨時鎖定策略

- **鎖定時長**：通常為 10-15 分鐘
- **實現方式**：
  - 在 Redis 中設置帶過期時間的鎖：`SET seat:{id} {user_id} EX 900 NX`
  - 或使用 Redlock 演算法確保分散式鎖的可靠性
- **鎖定釋放**：
  - 支付成功：將臨時鎖轉為永久佔用
  - 超時未支付：Redis 自動過期，座位自動釋放
  - 用戶主動取消：手動釋放鎖

#### 座位選擇優化

- **熱門區域限流**：對熱門座位區域設置訪問限流
- **推薦座位**：對於不在意座位的用戶，系統自動推薦可用座位，減少衝突
- **分批放票**：將票券分批次發售，降低瞬時併發

### 4. 防黃牛與反作弊

#### 身份驗證

- **實名制**：要求綁定手機號或身份證
- **限購數量**：每個身份限購 N 張票
- **驗證碼**：使用圖形驗證碼、滑動驗證等人機識別

#### 行為分析

- **頻率限制**：限制同一用戶的請求頻率（Rate Limiting）
- **設備指紋**：識別同一設備的多次購買行為
- **IP 限制**：檢測異常 IP（大量請求、機房 IP）
- **風控系統**：基於機器學習識別異常購買模式

#### 排隊機制

- **虛擬排隊**：開賣前將用戶加入等候隊列
- **隨機放行**：從隊列中隨機抽取用戶進入購票頁面
- **限制併發**：控制同時進入購票頁面的用戶數量

### 5. 支付流程設計

#### 訂單狀態機

購票訂單的狀態流轉：

1. **待支付** → 用戶創建訂單，座位已鎖定
2. **支付中** → 用戶提交支付請求
3. **支付成功** → 支付網關確認收款
4. **已完成** → 票券已發放
5. **已取消** → 超時未支付或用戶取消
6. **已退款** → 處理退票請求

#### 支付可靠性保證

- **冪等性**：
  - 使用訂單 ID 作為冪等鍵
  - 防止重複扣款和重複發票

- **非同步通知處理**：
  - 支付網關透過 Webhook 非同步通知結果
  - 使用消息隊列確保通知不丟失
  - 實現重試機制（指數退避）

- **對帳機制**：
  - 定期與支付網關對帳
  - 檢測並修正不一致的訂單狀態

- **超時處理**：
  - 設置支付超時時間（如 15 分鐘）
  - 定時任務掃描超時訂單並釋放座位
  - 或使用延遲消息隊列觸發超時處理

### 6. 高併發架構設計

#### 流量削峰

- **CDN**：靜態資源（圖片、CSS、JS）使用 CDN 加速
- **限流降級**：
  - API Gateway 層實現令牌桶或漏桶算法
  - 超過閾值返回"系統繁忙，請稍後重試"
- **排隊系統**：使用消息隊列平滑流量峰值

#### 快取策略

- **活動資訊快取**：
  - 活動詳情、票價等不常變動的資訊快取在 Redis
  - 設置合理的過期時間（如 5 分鐘）
- **座位圖快取**：
  - 座位佈局快取在瀏覽器和 CDN
  - 座位可用性即時查詢 Redis
- **庫存快取**：
  - 剩餘票券數量快取在 Redis
  - 使用 Lua 腳本保證原子性

#### 資料庫優化

- **讀寫分離**：
  - 寫操作（創建訂單）走主庫
  - 讀操作（查詢活動）走從庫
- **分庫分表**：
  - 按活動 ID 或時間分表
  - 歷史訂單遷移到歸檔庫
- **索引優化**：
  - 在訂單的 `user_id`、`event_id`、`status` 上建立索引

### 7. 票券系統設計

#### 票券生成

- **唯一 ID**：使用雪花算法生成全域唯一票券 ID
- **QR Code**：
  - 包含票券 ID、活動 ID、座位號等資訊
  - 使用非對稱加密簽名防偽
- **電子票券**：
  - 以 PDF 或圖片形式發送給用戶
  - 支援 Apple Wallet / Google Pay 電子票夾

#### 驗票機制

- **入場驗證**：
  - 掃描 QR Code，驗證簽名和票券狀態
  - 檢查是否已使用（防止重複入場）
  - 將已使用的票券標記在 Redis 中（快速查詢）
- **離線驗證**：
  - 支援閘機離線工作模式
  - 預先下載票券白名單到本地

### 8. 資料一致性保證

#### 分散式事務

- **本地消息表**：
  - 在資料庫事務中同時寫入業務數據和消息表
  - 後台任務掃描消息表並發送到消息隊列
- **Saga 模式**：
  - 將購票流程拆分為多個本地事務
  - 鎖定座位 → 創建訂單 → 支付 → 發放票券
  - 每步失敗時執行補償操作（如釋放座位）

#### 最終一致性

- **非同步補償**：
  - 使用消息隊列確保 Redis 和資料庫的最終一致
  - 失敗時重試，記錄錯誤日誌
- **定時對帳**：
  - 定期比對 Redis 庫存和資料庫實際銷售數
  - 發現不一致時告警並人工介入

### 9. 監控與告警

#### 關鍵指標

- **業務指標**：
  - 實時售票數、剩餘票數
  - 訂單創建成功率、支付成功率
  - 平均購票時長
- **技術指標**：
  - API 響應時間、錯誤率
  - Redis/資料庫 QPS 和延遲
  - 消息隊列積壓量

#### 告警機制

- **異常告警**：
  - 庫存異常（超賣或剩餘數不符）
  - 支付成功率驟降
  - 系統響應時間超過閾值
- **容量告警**：
  - Redis 記憶體使用率過高
  - 資料庫連接池耗盡
  - 消息隊列積壓嚴重

## 架構總結

一個完整的購票系統架構應包含：

1. **接入層**：CDN + API Gateway（限流、認證）
2. **應用層**：無狀態微服務（活動服務、訂單服務、支付服務）
3. **快取層**：Redis 集群（庫存、座位鎖、用戶會話）
4. **資料層**：MySQL 集群（訂單、票券）+ NoSQL（日誌、統計）
5. **消息隊列**：Kafka / RabbitMQ（非同步處理、削峰填谷）
6. **支付網關**：第三方支付服務整合
7. **監控系統**：Prometheus + Grafana + ELK

透過合理的架構設計和技術選型，購票系統可以在保證數據一致性的前提下，支撐千萬級用戶的高併發搶票場景。
