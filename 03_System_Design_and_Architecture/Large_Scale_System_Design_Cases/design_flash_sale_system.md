# 如何設計秒殺系統？

- **難度**: 9
- **重要程度**: 5
- **標籤**: `System Design`, `Flash Sale`, `High Concurrency`, `Inventory Management`

## 問題詳述

設計一個秒殺系統，在極短時間內（如10秒）處理數百萬使用者對少量商品（如1000件）的搶購請求。系統需要保證庫存準確、不超賣、高可用，並能承受瞬間流量沖擊。

## 核心理論與詳解

### 1. 秒殺系統的獨特性與挑戰

秒殺系統與普通電商系統有本質區別，需要特殊的架構設計。

#### 1.1 核心特徵

**瞬時流量洪峰**：
- 平時流量：1,000 QPS
- 秒殺瞬間：100,000+ QPS（100倍暴增）
- 持續時間：數秒到數十秒
- **關鍵洞察**：流量來得快、去得也快

**極低的成功率**：
```
假設場景：
- 商品數量：1,000 件
- 參與使用者：1,000,000 人
- 理論成功率：0.1%

實際情況：
- 99.9% 的請求註定失敗
- 大量無效請求消耗系統資源
```

**庫存競爭激烈**：
- 所有請求都集中在同一個 SKU
- 並發扣減庫存容易出錯（超賣問題）
- 需要強一致性保證

#### 1.2 設計目標的優先級

秒殺系統的設計目標與普通系統不同：

1. **絕對不能超賣**（最高優先級）
2. **系統穩定性**（保護正常業務不受影響）
3. **公平性**（防止黃牛和腳本）
4. **使用者體驗**（快速響應，即使失敗）

### 2. 整體架構設計思路

秒殺系統的核心設計理念是：**將大量無效請求擋在系統外層，讓真正有效的請求進入核心業務邏輯**。

#### 2.1 分層防禦架構

```
┌────────────────────────────────────────────┐
│         Layer 1: 前端限流層                 │
│  - 按鈕置灰防止重複點擊                      │
│  - 靜態資源 CDN 加速                        │
│  - 答題驗證碼（增加攻擊成本）                │
└─────────────┬──────────────────────────────┘
              │ 攔截 50% 無效請求
┌─────────────▼──────────────────────────────┐
│         Layer 2: 接入層限流                 │
│  - Nginx 限流（per IP: 10 req/s）          │
│  - API Gateway 限流（全局：100k req/s）     │
│  - 使用者維度限流（per User: 5 req/s）      │
└─────────────┬──────────────────────────────┘
              │ 攔截 40% 惡意請求
┌─────────────▼──────────────────────────────┐
│         Layer 3: 業務層過濾                 │
│  - 檢查使用者資格（風控、黑名單）            │
│  - 檢查秒殺時間是否開始                      │
│  - 檢查使用者是否已購買                      │
└─────────────┬──────────────────────────────┘
              │ 剩餘 5-10% 請求
┌─────────────▼──────────────────────────────┐
│         Layer 4: 庫存扣減層（核心）         │
│  - Redis 原子操作扣減庫存                   │
│  - Lua 腳本保證原子性                       │
└─────────────┬──────────────────────────────┘
              │ 成功 0.1% 請求
┌─────────────▼──────────────────────────────┐
│         Layer 5: 訂單處理層                 │
│  - 異步創建訂單（Kafka）                    │
│  - 異步扣減 MySQL 庫存                      │
│  - 發送成功通知                             │
└────────────────────────────────────────────┘
```

**為什麼需要分層**：
- 每一層都能過濾掉大量無效請求
- 越往下走，通過的請求越少，資源消耗越精準
- 保護核心資產（資料庫）不被壓垮

### 3. 庫存扣減方案（核心技術決策）

這是秒殺系統最關鍵的設計，直接決定能否防止超賣。

#### 3.1 方案對比與選擇理由

**方案一：MySQL 悲觀鎖**

```sql
BEGIN;
SELECT stock FROM products WHERE id = 123 FOR UPDATE;
-- 檢查庫存
UPDATE products SET stock = stock - 1 WHERE id = 123;
COMMIT;
```

**為什麼不推薦**：
- ❌ 資料庫成為瓶頸：MySQL 單機 QPS 約 1,000-5,000，無法承受 10 萬+ QPS
- ❌ 鎖等待時間長：大量請求排隊等待行鎖
- ❌ 容易死鎖：高並發下死鎖風險大

**方案二：MySQL 樂觀鎖**

```sql
UPDATE products 
SET stock = stock - 1, version = version + 1
WHERE id = 123 AND stock > 0 AND version = ?;
```

**為什麼不推薦**：
- ❌ 資料庫壓力仍然很大：雖然無鎖等待，但 QPS 上限仍在
- ❌ 大量失敗重試：version 不匹配導致頻繁重試
- ⚠️ 相比悲觀鎖略好，但仍不適合秒殺場景

**方案三：Redis 原子操作（推薦）**

**為什麼選擇 Redis**：
- ✅ **性能極高**：單機 Redis 可支持 10 萬+ QPS
- ✅ **原子操作**：DECR 命令天然保證原子性
- ✅ **內存操作**：響應時間 < 1ms
- ✅ **簡單可靠**：邏輯清晰，不易出錯

**實現方式：Lua 腳本保證原子性**

為什麼用 Lua 而不是直接用 DECR：
```
直接 DECR 的問題：
1. stock = redis.GET("stock:123")     // 讀取庫存
2. if stock > 0:                       // 判斷
3.     redis.DECR("stock:123")        // 扣減

問題：步驟 1-3 不是原子的，可能超賣
```

**Lua 腳本解決方案**：
```lua
-- 在 Redis 服務器端原子執行
local stock = tonumber(redis.call('GET', KEYS[1]))
if stock == nil or stock <= 0 then
    return 0  -- 庫存不足
end
redis.call('DECR', KEYS[1])
return 1  -- 扣減成功
```

**為什麼 Lua 腳本能保證原子性**：
- Redis 單線程模型：同一時間只執行一個 Lua 腳本
- 腳本執行期間不會被其他命令打斷
- 多個操作（讀取 + 判斷 + 扣減）作為一個整體執行

#### 3.2 預扣庫存 + 異步下單模式

**核心思想**：將「扣庫存」和「創建訂單」解耦，前者同步後者異步。

**流程設計**：
```
1. 使用者點擊搶購
   ↓
2. Redis Lua 腳本扣減庫存（同步，< 1ms）
   ↓ 成功
3. 返回「搶購成功」給使用者
   ↓
4. 發送消息到 Kafka（異步）
   ↓
5. 訂單服務消費消息
   ↓
6. 創建訂單寫入 MySQL
   ↓
7. 發送訂單通知
```

**為什麼這樣設計**：
- ✅ **快速響應**：使用者等待時間 < 10ms（只等待 Redis 操作）
- ✅ **削峰填谷**：Kafka 緩衝流量，訂單服務按自己的節奏處理
- ✅ **系統解耦**：秒殺服務和訂單服務獨立擴展
- ⚠️ **權衡**：引入最終一致性（使用者看到搶購成功，但訂單可能晚幾秒生成）

### 4. 限流策略（多層防護）

限流的目的是**保護系統不被壓垮**，寧可拒絕部分請求也要保證系統穩定。

#### 4.1 為什麼需要多層限流

**單點限流的不足**：
- 只在網關限流：無法防止分佈式攻擊
- 只在應用層限流：網關層可能先被打垮
- 只按 IP 限流：無法防止肉雞攻擊

**多層限流互補**：
```
前端限流：防止誤操作（按鈕重複點擊）
Nginx 限流：防止 IP 級攻擊
網關限流：全局流量控制（令牌桶）
應用限流：業務邏輯保護（使用者維度）
```

#### 4.2 限流算法選擇

**令牌桶 vs 漏桶**：

| 特性 | 令牌桶 | 漏桶 |
|------|--------|------|
| **流量特性** | 允許突發流量 | 強制平滑流量 |
| **實現複雜度** | 較簡單 | 較簡單 |
| **適用場景** | 秒殺（推薦） | 保護後端穩定 |

**為什麼秒殺選擇令牌桶**：
- 秒殺本身就是突發流量場景
- 令牌桶可以容納短時間的流量洪峰
- 配置靈活：桶容量 = 允許的突發量

### 5. 防刷與風控

秒殺系統必須防止黃牛和腳本攻擊，否則真實使用者根本搶不到。

#### 5.1 多維度風控策略

**時間維度**：
- 秒殺開始前 1 分鐘彈出驗證碼
- 要求使用者完成滑塊/答題驗證
- **目的**：增加腳本攻擊成本，人機識別

**行為維度**：
- 監控請求頻率（正常使用者 < 5 次/秒）
- 分析滑鼠軌跡、點擊模式
- 識別異常行為模式
- **目的**：識別腳本行為

**帳號維度**：
- 新註冊帳號限制參與（需註冊 > 7 天）
- 未實名認證帳號限制
- 歷史違規帳號黑名單
- **目的**：提高攻擊門檻

**設備維度**：
- 設備指紋識別
- 同一設備多帳號檢測
- 模擬器識別
- **目的**：防止一人多號

#### 5.2 風控評分模型

**綜合評分機制**：
```
總分 = 帳號年齡分 + 行為分 + 設備分 + 歷史信譽分

評分規則：
- 帳號註冊 < 7 天：-30 分
- 請求頻率 > 10/s：-40 分
- 設備指紋重複：-20 分
- 歷史違規記錄：-50 分

判定：
- 總分 < 60：直接拒絕
- 60-80：需要額外驗證
- > 80：正常放行
```

**為什麼用評分而不是單一規則**：
- 攻擊者會繞過單一規則
- 綜合評分更難繞過
- 可以動態調整權重

### 6. 數據一致性保證

秒殺系統涉及 Redis 和 MySQL 兩個數據源，如何保證一致性？

#### 6.1 一致性權衡

**強一致性 vs 最終一致性**：

```
強一致性方案（不推薦）：
- 同步扣減 Redis 和 MySQL 庫存
- 使用分佈式事務（2PC/3PC）

問題：
- 性能急劇下降
- 複雜度高
- 不適合秒殺場景

最終一致性方案（推薦）：
- Redis 作為權威庫存（實時）
- MySQL 異步更新（最終一致）
- 定時任務校對修復

優點：
- 性能高
- 實現簡單
- 符合業務特點
```

**為什麼秒殺可以接受最終一致性**：
- 庫存扣減瞬間完成（Redis）
- 訂單創建晚幾秒無影響
- 使用者可以接受「搶購成功，訂單生成中」的提示

#### 6.2 數據校對機制

**定時任務校對**：
```
每 5 分鐘執行：
1. 讀取 Redis 庫存
2. 讀取 MySQL 庫存
3. 比對差異
4. 如果不一致，以 Redis 為準修復 MySQL

目的：
- 確保最終一致性
- 發現潛在問題
```

### 7. 高可用架構

#### 7.1 單點故障應對

**Redis 故障**：
```
方案一：Redis Cluster（推薦）
- 多主節點，每個主節點有從節點
- 自動故障轉移
- 數據分片，性能擴展

方案二：降級策略
- Redis 不可用時，切換到 MySQL 扣庫存
- 性能下降但保證可用
- 限制流量進入降級模式
```

**Kafka 故障**：
```
- 異步操作可容忍短時間故障
- 訂單累積在 Kafka，恢復後慢慢處理
- 對使用者透明（已經返回搶購成功）
```

#### 7.2 容量規劃

**如何評估需要多少台服務器**：
```
假設：
- 峰值 QPS：100,000
- 單機 QPS：1,000（含業務邏輯）

計算：
- 服務器數量：100,000 / 1,000 = 100 台
- 考慮冗餘（50%）：150 台
- 預留擴容空間：200 台

Redis 容量：
- 單機 Redis：10 萬 QPS
- 需要：100,000 / 100,000 = 1 台（但需要主從）
- 實際部署：3 主 6 從（高可用）
```

### 8. 監控與應急

#### 8.1 關鍵指標監控

**實時監控**：
- 當前 QPS / 目標 QPS
- Redis 庫存數量
- 成功下單數 vs 預期數
- 系統響應時間（P99）

**告警閾值**：
```
嚴重：
- QPS > 預期 2 倍：可能遭受攻擊
- 庫存出現負數：超賣！立即熔斷

警告：
- 響應時間 > 100ms：系統壓力大
- Redis 命中率 < 90%：可能有問題
```

#### 8.2 應急預案

**超賣應急處理**：
```
發現超賣：
1. 立即停止秒殺活動
2. 凍結異常訂單
3. 人工審核，取消超額訂單
4. 向使用者道歉補償

預防措施：
- 灰度發布秒殺活動
- 小規模驗證後全量
```

## 程式碼範例（可選）

僅展示核心的 Redis Lua 腳本邏輯：

```go
// 使用 Lua 腳本扣減庫存
func DecrStock(productID int64) (bool, error) {
    script := `
        local stock = tonumber(redis.call('GET', KEYS[1]))
        if stock == nil or stock <= 0 then
            return 0
        end
        redis.call('DECR', KEYS[1])
        return 1
    `
    
    key := fmt.Sprintf("seckill:stock:%d", productID)
    result, err := redis.Eval(script, []string{key}).Int()
    
    return result == 1, err
}
```

## 總結

設計秒殺系統的核心要點：

1. **分層防禦**：前端限流 → 網關限流 → 業務過濾 → 庫存扣減，層層過濾無效請求
2. **Redis 扣庫存**：利用 Lua 腳本原子性操作，性能高且不超賣
3. **異步解耦**：預扣庫存（同步） + 創建訂單（異步），快速響應使用者
4. **多重限流**：多層次、多維度限流保護系統
5. **風控防刷**：驗證碼 + 行為分析 + 帳號信譽，防止黃牛
6. **最終一致性**：Redis 為準，MySQL 異步同步，定時校對
7. **高可用**：Redis Cluster + 降級策略

秒殺系統體現的核心設計思想：**在保證核心業務正確性的前提下，通過分層過濾和異步化，用最少的資源處理最關鍵的請求**。
