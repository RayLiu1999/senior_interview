# 如何設計搜尋引擎或自動補全？

- **難度**: 8
- **重要程度**: 5
- **標籤**: `System Design`, `Search Engine`, `Autocomplete`, `Indexing`

## 問題詳述

搜尋引擎（如 Google、Elasticsearch）和自動補全功能（如 Google Search Suggestions）是現代應用的核心功能。請設計一個高效的搜尋系統，需要考慮：

1. **核心功能**：如何實現全文檢索、相關性排序、自動補全？
2. **索引建構**：如何從海量文檔建立倒排索引？
3. **查詢處理**：如何快速響應搜尋請求並返回相關結果？
4. **自動補全**：如何在用戶輸入時實時提示可能的搜尋詞？
5. **擴展性**：如何支撐億級文檔和百萬級 QPS？

## 核心理論與詳解

搜尋引擎是資訊檢索領域的經典應用，涉及索引建構、查詢處理、相關性排序等核心技術。

### 1. 搜尋引擎核心概念

#### 基本術語

- **文檔（Document）**：被索引的內容單元（網頁、文章、商品等）
- **詞項（Term）**：分詞後的單詞或詞組
- **倒排索引（Inverted Index）**：詞項到文檔的映射
- **相關性（Relevance）**：查詢與文檔的匹配程度
- **排序（Ranking）**：按相關性對結果排序

#### 搜尋流程

1. **索引階段**：
   - 爬取或接收文檔
   - 分詞、提取詞項
   - 建立倒排索引
   - 計算文檔特徵（如 TF-IDF）

2. **查詢階段**：
   - 接收用戶查詢
   - 分詞、查詢優化
   - 根據倒排索引找到候選文檔
   - 計算相關性分數並排序
   - 返回 Top-N 結果

### 2. 倒排索引

#### 正排索引 vs. 倒排索引

- **正排索引**：文檔 ID → 文檔內容
  - 範例：文檔 1 → "搜尋引擎原理"
  - 查詢時需要掃描所有文檔，效率低

- **倒排索引**：詞項 → 包含該詞的文檔列表
  - 範例："搜尋" → [Doc1, Doc5, Doc10]
  - 查詢時直接定位到相關文檔，效率高

#### 倒排索引結構

- **詞典（Dictionary）**：
  - 所有詞項的有序列表
  - 支援快速查找（通常使用 B+ Tree 或雜湊表）

- **倒排列表（Posting List）**：
  - 每個詞項對應一個倒排列表
  - 包含：文檔 ID、詞頻（TF）、位置資訊

- **範例**：
  ```
  "搜尋" → [(Doc1, tf=3, pos=[1,5,10]), (Doc5, tf=1, pos=[3]), ...]
  "引擎" → [(Doc1, tf=2, pos=[2,6]), (Doc3, tf=1, pos=[4]), ...]
  ```

#### 索引壓縮

倒排列表可能很長，需要壓縮以節省空間。

- **文檔 ID 壓縮**：
  - 使用差分編碼（Delta Encoding）
  - 範例：[1, 5, 10, 15] → [1, 4, 5, 5]
  - 再使用變長編碼（如 Varbyte、PForDelta）

- **位置資訊壓縮**：
  - 同樣使用差分編碼
  - 減少儲存空間

### 3. 分詞與文本處理

#### 中文分詞

中文沒有天然的詞邊界，需要分詞。

- **分詞算法**：
  - **基於詞典**：最大匹配（正向、逆向、雙向）
  - **基於統計**：HMM、CRF
  - **基於深度學習**：BERT、LSTM

- **常用工具**：
  - jieba（Python）
  - IKAnalyzer（Java）
  - HanLP

#### 文本預處理

- **小寫轉換**：統一大小寫（英文）
- **停用詞過濾**：去除「的」、「是」、「在」等無意義詞
- **詞幹提取（Stemming）**：將詞彙還原為詞幹
  - 範例：running → run
- **詞形還原（Lemmatization）**：更精確的詞彙標準化
  - 範例：better → good

#### 同義詞處理

- **同義詞擴展**：
  - 查詢「手機」時也搜尋「手提電話」、「行動電話」
  - 維護同義詞詞典
  - 使用詞向量（Word2Vec）計算語義相似度

### 4. 相關性排序

#### TF-IDF

TF-IDF 是經典的相關性計算方法。

- **詞頻（TF, Term Frequency）**：
  - 詞項在文檔中出現的頻率
  - `TF(t, d) = count(t in d) / total_terms(d)`

- **逆文檔頻率（IDF, Inverse Document Frequency）**：
  - 詞項的稀有程度
  - `IDF(t) = log(N / df(t))`
  - N：總文檔數，df(t)：包含詞項 t 的文檔數

- **TF-IDF 分數**：
  - `TF-IDF(t, d) = TF(t, d) × IDF(t)`
  - 詞項越頻繁、越稀有，分數越高

#### BM25

BM25 是改進的 TF-IDF，是現代搜尋引擎的標準算法。

- **公式**（簡化版）：
  ```
  Score(D, Q) = Σ IDF(qi) × (f(qi, D) × (k1 + 1)) / (f(qi, D) + k1 × (1 - b + b × |D| / avgdl))
  ```
  - D：文檔
  - Q：查詢
  - f(qi, D)：詞項 qi 在文檔 D 中的頻率
  - |D|：文檔長度
  - avgdl：平均文檔長度
  - k1, b：調節參數

- **優勢**：
  - 考慮文檔長度，避免長文檔優勢
  - 詞頻飽和效應（高頻詞增長放緩）

#### 向量空間模型（VSM）

- **文檔和查詢表示為向量**：
  - 每個維度代表一個詞項
  - 值為 TF-IDF 權重

- **餘弦相似度**：
  - `cos(θ) = (D · Q) / (||D|| × ||Q||)`
  - 值越接近 1，相關性越高

#### 深度學習排序

- **BERT for Search**：
  - 使用預訓練的 BERT 模型
  - 輸入：[CLS] 查詢 [SEP] 文檔 [SEP]
  - 輸出：相關性分數

- **Learning to Rank（LTR）**：
  - 使用機器學習模型排序
  - 特徵：TF-IDF、BM25、PageRank、點擊率等
  - 模型：LambdaMART、XGBoost

### 5. 查詢處理

#### 查詢解析

- **布林查詢**：
  - AND：交集（"蘋果 AND 手機"）
  - OR：並集（"蘋果 OR 橘子"）
  - NOT：排除（"蘋果 NOT 水果"）

- **短語查詢**：
  - 查詢詞必須連續出現
  - 範例："搜尋引擎"（"搜尋" 和 "引擎" 必須相鄰）

- **通配符查詢**：
  - `*`：匹配任意字元
  - 範例："搜*" 匹配 "搜尋"、"搜索"

#### 查詢擴展

- **自動糾錯**：
  - 檢測拼寫錯誤（編輯距離）
  - 建議正確拼寫

- **查詢改寫**：
  - 根據用戶意圖改寫查詢
  - 範例："iphone 15 多少錢" → "iphone 15 價格"

- **相關查詢推薦**：
  - 推薦相關的熱門查詢
  - 範例："iphone 15" → "iphone 15 評測"、"iphone 15 購買"

#### 查詢優化

- **查詢快取**：
  - 熱門查詢結果快取在記憶體
  - 使用 LRU 淘汰策略

- **查詢重寫**：
  - 將複雜查詢拆分為多個子查詢
  - 並行執行後合併結果

### 6. 自動補全（Autocomplete）

#### 需求分析

- **實時性**：用戶每輸入一個字母就需要更新建議
- **低延遲**：響應時間 < 100ms
- **相關性**：建議必須與用戶輸入相關
- **熱門度**：優先推薦熱門搜尋詞

#### 數據結構

**前綴樹（Trie）**：

- **結構**：
  - 每個節點代表一個字元
  - 從根到某節點的路徑表示一個前綴
  - 葉子節點標記完整詞彙

- **查詢**：
  - 輸入 "app"
  - 在 Trie 中找到前綴 "app" 的節點
  - 返回該節點下的所有完整詞彙

- **優化**：
  - 在節點中儲存 Top-K 熱門詞彙
  - 避免遍歷整棵子樹

**範例**：
```
      root
      /  \
     a    b
    /      \
   p        o
  /          \
 p            o
/ \            \
l   e           k
e               

"app" → [apple, append]
"bo" → [book]
```

#### 熱門度計算

- **搜尋頻率**：
  - 統計每個查詢詞的搜尋次數
  - 高頻詞優先推薦

- **時間衰減**：
  - 最近的搜尋權重更高
  - 使用指數衰減函數

- **個人化**：
  - 根據用戶歷史搜尋
  - 推薦個人化的建議

#### 實現方案

**方案一：記憶體 Trie**

- 將 Trie 完全載入記憶體
- 優點：查詢極快（微秒級）
- 缺點：記憶體佔用大，更新複雜

**方案二：Redis + Sorted Set**

- 使用 Redis 的 Sorted Set 儲存查詢詞和分數
- `ZRANGEBYLEX` 查詢指定前綴
- 優點：易於更新，支援分散式
- 缺點：查詢稍慢於純記憶體 Trie

**方案三：Elasticsearch**

- 使用 Elasticsearch 的 Completion Suggester
- 基於 FST（Finite State Transducer）
- 優點：功能強大，支援多種建議策略
- 缺點：需要額外部署 Elasticsearch

#### 更新策略

- **實時更新**：
  - 用戶每次搜尋後更新統計
  - 使用消息隊列非同步處理

- **批次更新**：
  - 定期（如每小時）重新計算熱門詞
  - 更新 Trie 或快取

### 7. 分散式架構

#### 索引分片（Sharding）

- **水平分片**：
  - 將文檔按 ID 雜湊分佈到多個分片
  - 每個分片是一個獨立的索引

- **查詢處理**：
  - 查詢發送到所有分片
  - 每個分片返回 Top-K 結果
  - 協調節點合併結果並重新排序

#### 副本（Replication）

- **主副本**：
  - 每個分片有一個主副本和多個從副本
  - 寫入走主副本，讀取可以走從副本

- **高可用**：
  - 主副本故障時，從副本提升為主
  - 保證服務可用性

#### 負載均衡

- **查詢路由**：
  - 使用負載均衡器分發查詢到不同節點
  - 根據負載、響應時間動態調整

- **熱點分片**：
  - 識別高負載分片
  - 拆分或增加副本

### 8. 性能優化

#### 快取策略

- **查詢結果快取**：
  - 熱門查詢結果快取在 Redis
  - 設置合理的過期時間（如 5 分鐘）

- **倒排列表快取**：
  - 高頻詞項的倒排列表快取在記憶體
  - 減少磁碟 I/O

#### 索引優化

- **索引合併**：
  - 定期合併小的索引片段
  - 減少索引文件數量，提升查詢效率

- **增量索引**：
  - 新文檔先寫入小的增量索引
  - 定期合併到主索引

#### 查詢優化

- **提前終止（Early Termination）**：
  - 當找到足夠多的結果時提前停止
  - 不需要掃描所有文檔

- **跳表（Skip List）**：
  - 在倒排列表中使用跳表加速遍歷
  - 快速跳過不相關的文檔

### 9. 搜尋質量

#### 評估指標

- **精確率（Precision）**：
  - 返回的相關結果 / 返回的所有結果
  - 衡量結果的準確性

- **召回率（Recall）**：
  - 返回的相關結果 / 所有相關結果
  - 衡量結果的完整性

- **F1 分數**：
  - 精確率和召回率的調和平均
  - `F1 = 2 × (Precision × Recall) / (Precision + Recall)`

- **NDCG（Normalized Discounted Cumulative Gain）**：
  - 考慮排序位置的質量指標
  - 相關結果排在前面分數更高

#### 相關性優化

- **點擊數據**：
  - 分析用戶點擊行為
  - 點擊率高的結果相關性更好

- **停留時間**：
  - 用戶在結果頁面的停留時間
  - 停留時間長說明內容相關

- **A/B 測試**：
  - 測試不同的排序算法
  - 選擇用戶滿意度最高的

### 10. 特殊功能

#### 分面搜尋（Faceted Search）

- **功能**：
  - 左側顯示篩選條件（分類、價格、品牌等）
  - 用戶勾選後動態過濾結果

- **實現**：
  - 使用 Aggregation 聚合統計
  - Elasticsearch 內建支援

#### 模糊搜尋（Fuzzy Search）

- **容錯查詢**：
  - 允許拼寫錯誤（1-2 個字元差異）
  - 使用編輯距離（Levenshtein Distance）

- **範例**：
  - 查詢 "ipone" → 匹配 "iphone"

#### 地理位置搜尋

- **附近搜尋**：
  - "附近的餐廳"
  - 使用 Geohash 或 R-Tree 索引

- **範圍搜尋**：
  - 查詢某個座標 X 公里範圍內的地點

### 11. 開源搜尋引擎

#### Elasticsearch

- **特點**：
  - 基於 Lucene
  - 分散式、RESTful API
  - 功能豐富（聚合、地理位置、自動補全等）

- **適用場景**：
  - 日誌分析、全文檢索、電商搜尋

#### Solr

- **特點**：
  - 同樣基於 Lucene
  - 功能強大，支援複雜查詢
  - 較成熟穩定

- **適用場景**：
  - 企業級搜尋、內容管理系統

#### Meilisearch

- **特點**：
  - 輕量級、開箱即用
  - 搜尋速度極快
  - 支援自動補全和拼寫糾錯

- **適用場景**：
  - 小型應用、快速原型開發

## 架構總結

一個完整的搜尋引擎架構包含：

1. **數據採集層**：爬蟲、數據同步、增量更新
2. **索引層**：
   - 文本處理：分詞、停用詞、同義詞
   - 索引建構：倒排索引、特徵提取
   - 索引儲存：分片、副本
3. **查詢層**：
   - 查詢解析：分詞、查詢優化
   - 查詢執行：倒排索引查詢、多分片聚合
   - 排序：BM25、機器學習排序
4. **自動補全層**：Trie、Redis、熱門詞快取
5. **快取層**：查詢結果快取、熱點數據快取
6. **服務層**：API Gateway、負載均衡

搜尋引擎是**資訊檢索領域的核心應用**，結合了文本處理、索引建構、相關性排序等多項技術。設計時需要平衡**查詢速度**、**相關性質量**、**系統擴展性**和**維護成本**，根據業務規模和需求選擇合適的技術方案。
