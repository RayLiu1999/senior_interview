# 部署策略對比（藍綠、金絲雀、滾動）

- **難度**: 7
- **重要程度**: 5
- **標籤**: `部署`, `DevOps`, `藍綠部署`, `金絲雀`, `滾動更新`

## 問題詳述

選擇合適的部署策略對於確保服務的可用性和穩定性至關重要。不同的部署策略有不同的特點、優勢和適用場景。理解這些策略及其權衡，是資深後端工程師和 DevOps 工程師的核心能力。

## 核心理論與詳解

### 部署策略概覽

```
常見部署策略：

1. 停機部署（Recreate）
   - 最簡單，但有停機時間

2. 滾動更新（Rolling Update）
   - 逐步替換，無停機

3. 藍綠部署（Blue-Green）
   - 兩套環境，快速切換

4. 金絲雀部署（Canary）
   - 小範圍驗證，逐步擴大

5. A/B 測試（A/B Testing）
   - 基於特定條件路由
```

---

### 1. 停機部署（Recreate Deployment）

#### 原理

```
最簡單的部署方式：先停止舊版本，再啟動新版本。

流程：
Step 1: 停止所有舊版本實例
┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │
└──X──┘ └──X──┘ └──X──┘
   停止   停止   停止

Step 2: 有停機時間
[服務不可用]

Step 3: 啟動新版本實例
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │
└─────┘ └─────┘ └─────┘
```

#### 特性

```
✅ 優勢：
- 實現簡單
- 不需要額外資源
- 版本切換乾淨

❌ 劣勢：
- 有停機時間（通常數分鐘）
- 用戶體驗差
- 回滾慢

⚙️ 適用場景：
- 開發/測試環境
- 維護窗口內的部署
- 非關鍵服務
- 小型應用
```

#### Kubernetes 配置

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  strategy:
    type: Recreate  # 停機部署
  replicas: 3
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v2
```

---

### 2. 滾動更新（Rolling Update）

#### 原理

```
逐個替換實例，確保始終有可用的服務實例。

初始狀態（3 個 v1 實例）：
┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │
└─────┘ └─────┘ └─────┘

Step 1: 停止 1 個 v1，啟動 1 個 v2
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v1  │ │ v1  │
└─────┘ └─────┘ └─────┘

Step 2: 停止第 2 個 v1，啟動第 2 個 v2
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v1  │
└─────┘ └─────┘ └─────┘

Step 3: 停止最後 1 個 v1，啟動最後 1 個 v2
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │
└─────┘ └─────┘ └─────┘

完成！所有實例都是 v2
```

#### 參數配置

```
關鍵參數：

1. maxUnavailable（最大不可用數）
   - 更新過程中可以不可用的最大實例數
   - 範例：maxUnavailable: 1
   - 任何時候最多 1 個實例不可用

2. maxSurge（最大激增數）
   - 更新過程中可以超出期望副本數的最大實例數
   - 範例：maxSurge: 1
   - 可以臨時創建 1 個額外實例

範例：
replicas: 4
maxUnavailable: 1
maxSurge: 1

過程：
初始：[v1] [v1] [v1] [v1]
     ↓
Step 1: [v1] [v1] [v1] [v1] [v2]  (創建 1 個 v2，總共 5 個)
Step 2: [v1] [v1] [v1] [v2]       (刪除 1 個 v1)
Step 3: [v1] [v1] [v1] [v2] [v2]  (創建 1 個 v2)
Step 4: [v1] [v1] [v2] [v2]       (刪除 1 個 v1)
     ...
完成：[v2] [v2] [v2] [v2]
```

#### 特性

```
✅ 優勢：
- 無停機時間
- 資源使用相對較少
- 是 Kubernetes 的預設策略

❌ 劣勢：
- 新舊版本共存（可能有相容性問題）
- 部署時間較長
- 發現問題時已經部分更新

⚙️ 適用場景：
- 大部分生產環境
- 資源有限
- 可以容忍新舊版本短暫共存
```

#### Kubernetes 配置

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1  # 最多 1 個實例不可用
      maxSurge: 1        # 最多額外 1 個實例
  replicas: 4
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v2
        readinessProbe:  # 健康檢查
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

---

### 3. 藍綠部署（Blue-Green Deployment）

#### 原理

```
維護兩套完全相同的環境（藍/綠），一次性切換流量。

初始狀態：
Blue Environment (v1) - 生產環境
┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │
└─────┘ └─────┘ └─────┘
   ▲
   │ 100% 流量
   │
Load Balancer

Green Environment (idle) - 閒置
┌─────┐ ┌─────┐ ┌─────┐
│     │ │     │ │     │
└─────┘ └─────┘ └─────┘

部署 v2：
Blue Environment (v1)
┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │
└─────┘ └─────┘ └─────┘
   ▲
   │ 100% 流量
   │
Load Balancer

Green Environment (v2) - 部署新版本
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │
└─────┘ └─────┘ └─────┘
   (測試通過)

切換流量：
Blue Environment (v1) - 閒置
┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │
└─────┘ └─────┘ └─────┘

Green Environment (v2) - 生產環境
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │
└─────┘ └─────┘ └─────┘
   ▲
   │ 100% 流量（一次性切換）
   │
Load Balancer
```

#### 切換機制

```
1. DNS 切換
   - 修改 DNS 記錄指向新環境
   - 簡單但有 DNS 快取延遲

2. Load Balancer 切換
   - 修改負載均衡器配置
   - 快速、精確

3. Service Mesh 切換
   - 使用 Istio 等工具
   - 更靈活的流量控制
```

#### 特性

```
✅ 優勢：
- 零停機時間
- 快速切換（秒級）
- 快速回滾（切回藍環境）
- 新版本可以充分測試

❌ 劣勢：
- 需要雙倍資源（兩套環境）
- 資料庫遷移複雜
- 成本高

⚙️ 適用場景：
- 關鍵業務系統
- 需要快速回滾
- 資源充足
- 零容忍停機時間
```

#### Kubernetes 配置

```yaml
# 藍環境
apiVersion: v1
kind: Service
metadata:
  name: myapp-blue
spec:
  selector:
    app: myapp
    version: v1
  ports:
  - port: 80
    targetPort: 8080

---
# 綠環境
apiVersion: v1
kind: Service
metadata:
  name: myapp-green
spec:
  selector:
    app: myapp
    version: v2
  ports:
  - port: 80
    targetPort: 8080

---
# 主服務（切換藍綠）
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
    version: v2  # 切換到 v2（綠環境）
  ports:
  - port: 80
    targetPort: 8080
```

---

### 4. 金絲雀部署（Canary Deployment）

#### 原理

```
先將新版本部署到一小部分用戶，驗證無誤後逐步擴大範圍。

名稱由來：
礦工帶金絲雀下礦井，金絲雀對有毒氣體敏感，
如果金絲雀死亡，說明環境危險，礦工立即撤離。

部署流程：
Stage 1: 5% 流量到 v2
┌──────────────────────┐
│ Load Balancer        │
└────┬─────────────┬───┘
     │ 95%         │ 5%
     ▼             ▼
  ┌─────┐       ┌─────┐
  │ v1  │       │ v2  │
  └─────┘       └─────┘
  (19 個)        (1 個)

監控指標正常 ↓

Stage 2: 50% 流量到 v2
┌──────────────────────┐
│ Load Balancer        │
└────┬─────────────┬───┘
     │ 50%         │ 50%
     ▼             ▼
  ┌─────┐       ┌─────┐
  │ v1  │       │ v2  │
  └─────┘       └─────┘
  (10 個)       (10 個)

監控指標正常 ↓

Stage 3: 100% 流量到 v2
┌──────────────────────┐
│ Load Balancer        │
└──────────┬───────────┘
           │ 100%
           ▼
        ┌─────┐
        │ v2  │
        └─────┘
        (20 個)
```

#### 流量分配策略

```
1. 基於比例
   - 5% → 25% → 50% → 100%

2. 基於用戶屬性
   - 內部員工先試用
   - VIP 用戶優先
   - 特定地區用戶

3. 基於請求屬性
   - 特定 User-Agent
   - Cookie 或 Header
   - IP 範圍
```

#### 監控指標

```
關鍵指標：
1. 錯誤率
   - v1: 0.1%
   - v2: 0.2% ⚠️ (略高，觀察)
   - v2: 5% ❌ (異常，回滾)

2. 延遲
   - v1 P95: 200ms
   - v2 P95: 250ms (可接受)
   - v2 P95: 2000ms ❌ (異常)

3. 業務指標
   - 轉換率
   - 訂單量
   - 用戶留存

自動決策：
if v2.error_rate > v1.error_rate * 1.5:
    rollback()
elif v2.all_metrics_good:
    increase_traffic()
```

#### 特性

```
✅ 優勢：
- 風險最小化（小範圍試錯）
- 可以基於實際數據決策
- 快速回滾
- 適合 A/B 測試

❌ 劣勢：
- 部署時間長
- 需要複雜的流量控制
- 監控要求高
- 新舊版本共存時間長

⚙️ 適用場景：
- 高風險變更
- 需要驗證的新功能
- 大規模系統
- 重視穩定性
```

#### Istio 金絲雀部署

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: myapp
spec:
  hosts:
  - myapp
  http:
  - match:
    - headers:
        user-type:
          exact: "internal"  # 內部用戶
    route:
    - destination:
        host: myapp
        subset: v2
      weight: 100
  - route:
    - destination:
        host: myapp
        subset: v1
      weight: 90  # 90% 流量到 v1
    - destination:
        host: myapp
        subset: v2
      weight: 10  # 10% 流量到 v2
```

---

### 5. A/B 測試（A/B Testing）

#### 原理

```
與金絲雀部署類似，但側重於對比兩個版本的效果。

架構：
┌────────────────────────┐
│ Load Balancer          │
└────┬───────────────┬───┘
     │               │
基於特定條件分流
     │               │
     ▼               ▼
  ┌─────┐         ┌─────┐
  │ v1  │         │ v2  │
  └─────┘         └─────┘
  版本 A          版本 B
  (對照組)        (實驗組)

分流規則：
- 用戶 ID 的奇偶性
- 地理位置
- 用戶屬性（新/老用戶）
- 隨機分配

目標：
對比兩個版本的業務指標，
選擇效果更好的版本。
```

#### A/B 測試 vs 金絲雀部署

```
相似點：
- 都是流量逐步遷移
- 都需要監控指標

不同點：
A/B 測試：
- 目標：對比效果，選擇更好的版本
- 時間：較長（收集足夠數據）
- 決策：基於業務指標
- 結果：可能保留 A，也可能切換到 B

金絲雀部署：
- 目標：驗證新版本穩定性
- 時間：較短（快速驗證）
- 決策：基於技術指標
- 結果：通常是逐步切換到新版本
```

---

### 部署策略對比表

| 策略 | 停機時間 | 回滾速度 | 資源需求 | 部署速度 | 風險 | 適用場景 |
|------|---------|---------|---------|---------|------|---------|
| **停機部署** | 有 | 慢 | 低 | 快 | 高 | 開發/測試環境 |
| **滾動更新** | 無 | 中 | 低 | 中 | 中 | 大部分生產環境 |
| **藍綠部署** | 無 | 快 | 高（2倍） | 快 | 低 | 關鍵業務 |
| **金絲雀** | 無 | 快 | 中 | 慢 | 最低 | 高風險變更 |
| **A/B 測試** | 無 | 快 | 中 | 慢 | 低 | 功能對比 |

---

### 選擇指南

```
選擇流程圖：

是否可以停機？
├─ 是 → 停機部署
└─ 否 → 繼續

資源是否充足（2 倍）？
├─ 是 → 藍綠部署
└─ 否 → 繼續

是否高風險變更？
├─ 是 → 金絲雀部署
└─ 否 → 滾動更新

需要對比效果？
└─ 是 → A/B 測試
```

---

### 常見面試問題

#### Q1：藍綠部署和金絲雀部署有什麼區別？

**回答要點**：
- 藍綠：一次性切換，快速回滾
- 金絲雀：逐步遷移，降低風險
- 藍綠需要雙倍資源
- 金絲雀部署時間更長

#### Q2：如何處理資料庫遷移？

**回答要點**：
- 向後相容的 schema 變更
- 分階段遷移
- 使用功能開關
- 藍綠部署時共享資料庫

#### Q3：如何快速回滾？

**回答要點**：
- 藍綠：切換負載均衡器
- 滾動：回滾到上一版本
- 金絲雀：停止流量遷移
- 保留舊版本的部署配置

---

## 總結

選擇部署策略需要考慮：

1. **業務需求**：停機容忍度、風險承受能力
2. **資源限制**：是否有足夠資源支持多版本
3. **技術複雜度**：團隊是否有能力實施和維護
4. **部署頻率**：高頻部署建議自動化程度更高

**推薦實踐**：
- 開發/測試：停機部署或滾動更新
- 一般生產：滾動更新
- 關鍵業務：藍綠部署或金絲雀部署
- 高風險變更：金絲雀部署
- 功能驗證：A/B 測試

記住：**沒有最好的策略，只有最合適的策略**。
