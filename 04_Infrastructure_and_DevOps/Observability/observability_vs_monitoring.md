# Observability vs Monitoring (可觀測性與監控)

- **難度**: 4
- **標籤**: `Observability`, `Monitoring`, `SRE`, `DevOps`

## 問題詳述

「可觀測性 (Observability)」和「監控 (Monitoring)」這兩個詞經常被混用，但它們代表了不同的理念。請解釋兩者的核心區別，以及為什麼現代微服務架構更強調可觀測性？

## 核心理論與詳解

簡單來說，**監控告訴你系統「壞了」(What is broken)**，而**可觀測性告訴你「為什麼壞了」(Why it is broken)**。

### 1. 監控 (Monitoring)

- **定義**: 監控是關於**已知的未知 (Known Unknowns)**。
- **特點**:
  - 基於預定義的指標 (Metrics) 和儀表板 (Dashboards)。
  - 關注系統的整體健康狀況 (Health Check)。
  - 回答的問題通常是固定的：CPU 使用率是否過高？磁碟空間是否不足？API 錯誤率是否超過閾值？
- **局限性**: 當系統出現前所未見的故障模式時，監控往往無能為力，因為你無法為「不知道會發生什麼」的事情設置報警。

### 2. 可觀測性 (Observability)

- **定義**: 可觀測性是關於**未知的未知 (Unknown Unknowns)**。
- **特點**:
  - 它是系統的一種屬性，衡量的是「我們能多大程度上通過系統的外部輸出 (Logs, Metrics, Traces) 來推斷其內部狀態」。
  - 允許你提出新的問題，並通過探索數據來找到答案，而無需預先定義。
  - 強調數據的關聯性 (Correlation) 和高基數 (High Cardinality) 數據的分析能力。
- **核心三支柱 (Three Pillars)**:
  1. **Metrics (指標)**: 聚合的數值數據，用於發現趨勢和觸發告警 (如 Prometheus)。
  2. **Logs (日誌)**: 離散的事件記錄，用於了解特定時間點發生了什麼 (如 ELK)。
  3. **Traces (追蹤)**: 請求在分散式系統中的傳播路徑，用於定位跨服務的延遲和錯誤 (如 Jaeger)。

### 3. 為什麼微服務需要可觀測性？

在單體架構 (Monolith) 中，故障通常是線性的，監控 CPU 和記憶體就足夠了。但在微服務架構中：

- **故障是分散的**: 一個請求失敗可能是因為下游服務 C 的資料庫鎖死，導致服務 B 超時，最終服務 A 報錯。單看服務 A 的監控無法找到根因。
- **環境是動態的**: 容器隨時可能重啟、擴縮容，IP 地址不固定。
- **交互是複雜的**: 服務間的依賴關係錯綜複雜。

因此，我們需要具備「調試生產環境」的能力，這就是可觀測性的價值所在。

## 程式碼範例

(此概念主要為理論，無特定程式碼範例)
