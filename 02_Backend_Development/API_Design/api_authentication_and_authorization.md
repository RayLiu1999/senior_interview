# API 驗證與授權機制

- **難度**: 7
- **重要性**: 5
- **標籤**: `API Design`, `Security`, `Authentication`, `Authorization`

## 問題詳述

請解釋 API 中的驗證 (Authentication) 和授權 (Authorization) 有何不同。並比較幾種常見的 API 驗證機制，如 API Key, Basic Auth, OAuth 2.0, 和 JWT。

## 核心理論與詳解

### 驗證 (Authentication) vs. 授權 (Authorization)

這兩個概念是 API 安全的基石，但經常被混淆。

1. **驗證 (Authentication) - 你是誰？**
    - **目的**：確認請求者的身份。就像在機場出示護照，證明你是你所聲稱的那個人。
    - **過程**：客戶端提供一組憑證（如使用者名稱/密碼、API Key、Token），伺服器驗證這些憑證的有效性。
    - **結果**：一個二元結果——「已驗證」或「未驗證」。

2. **授權 (Authorization) - 你能做什麼？**
    - **目的**：在身份成功驗證後，判斷該身份是否有權限執行請求的操作。就像登機證決定了你只能登上特定航班的特定座位。
    - **過程**：伺服器檢查已驗證的身份所擁有的權限（或角色），並與請求的資源和操作所需的權限進行比對。
    - **結果**：一個決定——「允許」或「拒絕」訪問。

**簡單來說：驗證是「驗明正身」，授權是「授予權力」。** 驗證總是在授權之前。

### 常見的 API 驗證機制

#### 1. API 金鑰 (API Key)

- **運作方式**: 伺服器為每個客戶端生成一個唯一的、通常很長的字串（API Key）。客戶端在每次請求時，將此金鑰放在查詢參數 (`?api_key=...`) 或 HTTP 標頭 (`X-Api-Key: ...`) 中。
- **優點**:
  - **非常簡單**: 實現和使用都極其簡單。
  - **易於撤銷**: 如果某個金鑰洩露，可以輕鬆地在伺服器端禁用它。
- **缺點**:
  - **安全性較低**: 金鑰是靜態的，一旦洩露，攻擊者就可以冒充客戶端。它通常不會過期。
  - **僅識別應用，不識別使用者**: API Key 通常用於識別發起請求的應用程式，而不是最終使用者。
- **適用場景**: 簡單的、對安全性要求不高的公開 API，或用於追蹤和限制應用程式的請求速率。

#### 2. HTTP 基本驗證 (Basic Authentication)

- **運作方式**: 客戶端將「使用者名稱:密碼」的字串進行 Base64 編碼，然後放在 `Authorization` 標頭中：`Authorization: Basic <base64-encoded-credentials>`。
- **優點**:
  - **簡單**: 內建於 HTTP 規範中，大多數客戶端都支援。
- **缺點**:
  - **極不安全**: Base64 只是編碼，不是加密，可以輕易解碼。**必須**與 HTTPS 結合使用，否則憑證會在網路上以明文形式傳輸。
  - **容易遭受重放攻擊**: 憑證在每個請求中都會發送，增加了洩露的風險。
- **適用場景**: 內部網路或受嚴格保護的環境中的簡單應用，且**必須**在 TLS/SSL (HTTPS) 上運行。

#### 3. OAuth 2.0 (開放授權)

- **運作方式**: 這是一個**授權框架**，而不是一個具體的驗證協議。它允許第三方應用在不獲取使用者密碼的情況下，代表使用者訪問其在某個服務上的資源。核心流程是：
  1. 使用者請求第三方應用（Client）訪問他在資源伺服器（Resource Server）上的數據。
  2. Client 將使用者導向到授權伺服器（Authorization Server）。
  3. 使用者在授權伺服器上登入並同意授權。
  4. 授權伺服器返回一個**授權碼 (Authorization Code)** 給 Client。
  5. Client 使用授權碼向授權伺服器換取一個**存取權杖 (Access Token)**。
  6. Client 使用 Access Token 去訪問資源伺服器。
- **優點**:
  - **安全**: 使用者的密碼永遠不會暴露給第三方應用。
  - **權限分離**: Access Token 可以被授予有限的權限（範圍，Scopes），例如「唯讀」。
  - **可撤銷**: 使用者可以隨時撤銷對某個應用的授權，而無需更改密碼。
  - **標準化**: 是一個廣泛採用的行業標準。
- **缺點**:
  - **複雜**: 涉及多方（使用者、客戶端、授權伺服器、資源伺服器）和多個步驟，實現起來比其他方法複雜得多。
- **適用場景**: 任何涉及「以使用者身份登入」並授權第三方應用訪問其數據的場景，例如「使用 Google/Facebook 登入」。

#### 4. JWT (JSON Web Token)

- **運作方式**: JWT 本身不是一個驗證協議，而是一種**權杖格式標準**。它通常與 OAuth 2.0 或其他驗證流程結合使用。一個 JWT 包含三部分：標頭 (Header)、負載 (Payload)、簽名 (Signature)。
  1. 使用者使用帳號密碼登入。
  2. 伺服器驗證成功後，生成一個包含使用者 ID、角色、過期時間等資訊的 JWT，並用私鑰對其進行**簽名**。
  3. 伺服器將 JWT 返回給客戶端。
  4. 客戶端在後續請求的 `Authorization` 標頭中攜帶此 JWT：`Authorization: Bearer <jwt>`。
  5. 伺服器收到 JWT 後，使用公鑰或共享密鑰**驗證簽名**的有效性。如果驗證通過，則信任其中的負載資訊，無需查詢資料庫。
- **優點**:
  - **無狀態 (Stateless)**: 伺服器端無需儲存 Session 資訊，只需驗證簽名即可。這使得系統非常容易水平擴展。
  - **自包含 (Self-contained)**: 負載中可以包含所有必要的授權資訊（如使用者角色），減少了資料庫查詢。
  - **跨域友好**: 可以輕鬆地在多個服務之間傳遞和驗證。
- **缺點**:
  - **無法輕易撤銷**: 一旦簽發，JWT 在其過期之前都會有效。如果需要強制撤銷，就必須引入額外的複雜性（如黑名單機制），這也破壞了其無狀態的優點。
  - **安全性依賴於密鑰**: 簽名密鑰的安全性至關重要，一旦洩露，整個系統就會被攻破。
- **適用場景**: 分散式系統、微服務架構中的無狀態 API 驗證，特別是單頁應用 (SPA) 和移動應用的後端。

### 總結比較

| 機制 | 安全性 | 複雜度 | 狀態 | 適用場景 |
| :--- | :--- | :--- | :--- | :--- |
| **API Key** | 低 | 非常低 | 無狀態 | 簡單的公開 API，應用級別授權 |
| **Basic Auth** | 極低 (需 HTTPS) | 低 | 無狀態 | 內部或受保護的簡單服務 |
| **OAuth 2.0** | 高 | 非常高 | 有狀態 | 第三方應用授權，使用者登入 |
| **JWT** | 高 (依賴密鑰) | 中等 | 無狀態 | 微服務、SPA、移動應用的 API |

在現代 API 設計中，**OAuth 2.0 框架與 JWT 權杖格式的結合**是最常見和推薦的解決方案，它兼顧了安全性、靈活性和可擴展性。