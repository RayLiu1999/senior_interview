# GraphQL vs. REST: 一場 API 架構的對比

- **難度**: 7
- **重要性**: 4
- **標籤**: `API Design`, `GraphQL`, `REST`

## 問題詳述

請比較 GraphQL 和 REST 這兩種 API 設計架構。它們的核心思想是什麼？各自解決了什麼問題，又帶來了哪些新的挑戰？

## 核心理論與詳解

REST (Representational State Transfer) 和 GraphQL 是目前最主流的兩種 Web API 設計風格。REST 長期以來一直是業界標準，而 GraphQL 作為一個較新的挑戰者，提供了不同的解決方案來應對現代應用的複雜需求。

### REST: 以資源為中心

REST 是一種架構風格，它將伺服器上的所有事物都視為**資源 (Resource)**。每個資源都有一個唯一的 URI (Uniform Resource Identifier)。客戶端透過標準的 HTTP 方法 (`GET`, `POST`, `PUT`, `DELETE` 等) 來對這些資源進行操作。

#### 核心思想

- **資源導向**: 整個 API 是圍繞名詞（資源）組織的，例如 `/users`, `/orders/{orderId}`。
- **統一介面**: 使用標準的 HTTP 動詞來表示對資源的操作，例如 `GET /users` (獲取使用者列表), `DELETE /users/123` (刪除特定使用者)。
- **無狀態**: 每個請求都應包含所有必要資訊，伺服器不儲存客戶端的會話狀態。
- **多端點**: 不同的資源有不同的端點。獲取複雜數據通常需要請求多個端點。

#### REST 的問題

1. **過度獲取 (Over-fetching)**: 當客戶端只需要資源的一部分數據時，REST API 往往會返回整個資源的完整數據。例如，獲取文章列表時，可能只需要標題和作者，但 API 返回了完整的文章內容，浪費了頻寬。
    - **場景**: 手機 App 的文章列表頁面。
    - **請求**: `GET /articles`
    - **回應**: `[{ "id": 1, "title": "...", "author": "...", "content": "...", "comments": [...] }, ...]` (其中 `content` 和 `comments` 是多餘的)

2. **請求不足 (Under-fetching)**: 當客戶端需要來自多個資源的數據時，必須發送多次請求。例如，要顯示一篇文章及其評論，客戶端可能需要先請求文章，再請求評論。
    - **場景**: 文章詳情頁面。
    - **請求 1**: `GET /articles/1`
    - **請求 2**: `GET /articles/1/comments`
    - **請求 3**: `GET /users/author-id` (獲取作者資訊)
    - 這種多次往返 (N+1 問題) 會增加延遲，尤其是在移動網路上。

### GraphQL: 以查詢為中心

GraphQL 是由 Facebook 開發的一種 API **查詢語言**和執行時。它允許客戶端精確地指定它需要哪些數據，伺服器則不多不少地返回這些數據。

#### 核心思想

- **單一端點**: 通常只有一個端點（例如 `/graphql`），所有請求都發送到這裡。
- **強型別系統**: API 的所有能力都定義在一個 schema 中，使用 GraphQL Schema Definition Language (SDL) 來描述。這個 schema 就像是前後端之間的一份合約。
- **客戶端驅動**: 客戶端透過一個查詢 (Query) 來決定需要獲取什麼數據，包括數據的結構和欄位。
- **聲明式數據獲取**: 客戶端聲明它需要什麼，而不是如何獲取。

#### GraphQL 如何解決 REST 的問題

1. **解決過度獲取**: 客戶端可以在查詢中只指定需要的欄位。
    - **場景**: 手機 App 的文章列表頁面。
    - **查詢**:
        ```graphql
        query {
          articles {
            id
            title
            author { name }
          }
        }
        ```
    - **回應**: `[{ "id": 1, "title": "...", "author": { "name": "..." } }, ...]` (只返回了請求的欄位)

2. **解決請求不足**: 客戶端可以在一個查詢中同時獲取來自多個資源的數據。
    - **場景**: 文章詳情頁面。
    - **查詢**:
        ```graphql
        query {
          article(id: 1) {
            title
            content
            author { name }
            comments {
              body
              user { name }
            }
          }
        }
        ```
    - **回應**: 一次請求就返回了文章、作者和評論的所有相關資訊。

### GraphQL 帶來的挑戰

1. **複雜性**:
    - **客戶端**: 需要使用專門的 GraphQL 客戶端庫（如 Apollo, Relay）來管理查詢、快取等。
    - **伺服器端**: 實現一個 GraphQL 伺服器比實現 REST API 更複雜。需要定義 schema、編寫解析器 (Resolver) 來獲取數據。

2. **效能問題**:
    - **複雜查詢**: 如果不加以限制，客戶端可能會發送一個非常複雜、深度巢狀的查詢，導致伺服器負載過高，甚至被惡意攻擊 (DoS)。需要實現查詢深度限制、查詢複雜度分析等保護措施。
    - **N+1 問題**: 雖然 GraphQL 解決了客戶端的 N+1 請求，但它可能將問題轉移到了伺服器端。如果解析器實現不當，一個查詢可能會觸發多次資料庫查詢。需要使用 **DataLoader** 等模式來批量處理數據請求。

3. **快取**:
    - **HTTP 快取失效**: REST API 可以利用原生的 HTTP 快取機制（基於 URL 和 ETag），因為每個資源都有唯一的 URL。而 GraphQL 通常只有一個端點，且請求體是 `POST`，這使得基於 URL 的 HTTP 快取變得無效。
    - **客戶端快取**: 快取必須在客戶端庫的層級進行，這比 HTTP 快取更複雜。

4. **檔案上傳**: GraphQL 規範本身不包含檔案上傳的功能，需要透過社群制定的 `graphql-multipart-request-spec` 等規範來實現，增加了額外的複雜性。

### 總結比較

| 特性 | REST | GraphQL |
| :--- | :--- | :--- |
| **設計範式** | 以資源為中心 | 以客戶端查詢為中心 |
| **端點** | 多個端點 (e.g., `/users`, `/posts`) | 通常為單一端點 (e.g., `/graphql`) |
| **數據獲取** | 伺服器決定回應結構 | 客戶端精確指定所需數據 |
| **數據獲取問題** | 過度獲取 (Over-fetching) 和請求不足 (Under-fetching) | 客戶端解決了，但可能在伺服器端引發 N+1 問題 |
| **型別系統** | 無內建型別系統 (需 OpenAPI/Swagger) | 內建強型別 Schema |
| **快取** | 可利用標準 HTTP 快取 | HTTP 快取失效，需依賴客戶端庫 |
| **學習曲線** | 較低，基於現有 HTTP 知識 | 較高，需要學習新的語言和工具鏈 |
| **適用場景** | 簡單的、以資源為導向的 CRUD API | 需求多變的前端、微服務聚合、移動應用 |

### 結論

REST 和 GraphQL 並不是非此即彼的關係。

- **REST** 非常適合用於定義簡單、直觀、以資源為核心的 API。它的生態成熟，學習成本低，對於許多標準的 CRUD 操作來說，它依然是最佳選擇。

- **GraphQL** 則在處理複雜數據需求、多變的前端介面和聚合來自多個微服務的數據時大放異彩。它給予前端極大的靈活性，但也對後端提出了更高的效能和安全要求。

在實際專案中，也可以混合使用它們，例如使用 RESTful API 處理簡單的資源操作，同時提供一個 GraphQL 端點來滿足複雜的查詢需求。