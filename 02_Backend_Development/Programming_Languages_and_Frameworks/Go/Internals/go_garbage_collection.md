# Go 的記憶體回收 (GC) 是如何運作的？三色標記法是什麼？

- **難度**: 8
- **重要程度**: 4
- **標籤**: `GC`, `Internals`, `Memory Management`

## 問題詳述

本問題深入 Go 執行時的核心，旨在考察面試者對 Go 自動記憶體管理的理解深度。這不僅僅是關於 GC 的基本概念，更是關於 Go 如何實現低延遲、高併發 GC 的關鍵技術。這通常是區分中、高級 Go 開發者的重要指標。

## 核心理論與詳解

Go 語言的記憶體回收器（Garbage Collector, GC）負責自動尋找並回收不再被程式使用的記憶體。Go GC 的主要目標是實現極低的延遲（甚至達到亞毫秒級的 STW - Stop The World 暫停時間），這對於網路服務等延遲敏感的應用至關重要。

Go 的 GC 採用的是**併發、三色標記-清除（Concurrent Tri-color Mark-and-Sweep）** 演算法。

### 三色標記-清除法 (Tri-color Mark-and-Sweep)

這是一種邏輯上將堆（Heap）中的所有物件分為三種顏色集合的演算法，用以追蹤哪些物件是可達的（正在被使用），哪些是不可達的（可以被回收）。

-   **白色 (White) 集合**: 潛在的垃圾。初始時，所有物件都被放入白色集合。在 GC 週期的末尾，所有仍在白色集合中的物件都將被回收。
-   **灰色 (Gray) 集合**: 已被證明是可達的，但其指向的其他物件（子物件）還需要被掃描。可以視為「待處理」的工作佇列。
-   **黑色 (Black) 集合**: 已被證明是可達的，並且其所有子物件也已經被完全掃描。黑色物件是本輪 GC 中的「安全」物件。

#### 演算法流程

1.  **初始階段 (STW)**: GC 開始時，會有一個非常短暫的 STW。在此期間，GC 會執行一些準備工作，並將所有根物件（Root Objects，如全域變數、Goroutine 堆疊上的變數等）放入灰色集合。

2.  **標記階段 (Marking - Concurrent)**: 這是 GC 的核心階段，與使用者程式（Mutator）併發執行。
    a. GC 從灰色集合中取出一個物件。
    b. 將該物件標記為黑色。
    c. 掃描該物件，尋找它指向的其他物件。對於每個它指向的物件，如果該物件是白色的，則將其標記為灰色，並放入灰色集合。
    d. 重複以上步驟，直到灰色集合變空。

3.  **標記終止階段 (Mark Termination - STW)**: 當灰色集合為空後，會有另一個短暫的 STW。此階段會執行一些最終的清理工作，並確保標記階段已完全完成。

4.  **清除階段 (Sweeping - Concurrent)**: GC 遍歷整個堆，將所有仍然是白色的物件進行回收（釋放其記憶體）。這個階段也是與使用者程式併發執行的。

### 併發 GC 的挑戰與寫屏障 (Write Barrier)

在標記階段併發執行時，會出現一個問題：如果使用者程式在 GC 掃描的同時修改了物件的指標，可能會破壞三色不變性，導致可達物件被錯誤地回收。

**致命場景**: 一個黑色物件（已掃描完畢）指向了一個新的白色物件，而這個白色物件沒有任何其他灰色物件指向它。如果 GC 不知道這次修改，它將永遠不會再次掃描黑色物件，導致那個白色物件在週期結束時被當作垃圾回收，引發程式錯誤。

**解決方案：寫屏障 (Write Barrier)**

為了防止這種情況，Go 引入了「寫屏障」機制。寫屏障是一小段由編譯器插入的程式碼，它會在每次指標寫入操作時執行。

-   **Go 的混合寫屏障 (Hybrid Write Barrier)**: 從 Go 1.8 開始，Go 採用了混合寫屏障。其核心思想是：當使用者程式執行 `*p = q`（將指標 `p` 指向物件 `q`）這樣的操作時，寫屏障會**將物件 `q` 標記為灰色**。

這樣做確保了任何被黑色物件新引用的白色物件都會被著色為灰色，從而保證了 GC 的正確性。它防止了「黑色指向白色」這種危險情況的發生，使得併發標記可以安全地進行。

### GC 的觸發

Go 的 GC 主要由環境變數 `GOGC` 控制，其預設值為 100。它表示當新分配的記憶體達到上次 GC 後存活記憶體大小的 100% 時，就會觸發下一次 GC。例如，如果上次 GC 後堆大小為 256MB，那麼當堆增長到 512MB 時，就會觸發新的 GC 週期。
