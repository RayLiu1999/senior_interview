# node_modules 與模組解析

- **難度**: 6
- **重要程度**: 3
- **標籤**: `node_modules`, `Module Resolution`, `Dependencies`, `npm`

## 問題詳述

請深入解釋 Node.js 的 node_modules 目錄結構、模組解析算法、依賴提升（Hoisting）、幽靈依賴（Phantom Dependencies）以及不同包管理器的差異。

## 核心理論與詳解

### 1. node_modules 目錄結構

#### 基本結構

```
project/
├── node_modules/
│   ├── express/
│   │   ├── package.json
│   │   ├── index.js
│   │   └── node_modules/      # express 的依賴
│   │       └── body-parser/
│   ├── lodash/
│   │   ├── package.json
│   │   └── lodash.js
│   └── .bin/                   # 可執行文件的符號連結
│       ├── tsc -> ../typescript/bin/tsc
│       └── jest -> ../jest/bin/jest.js
├── package.json
└── package-lock.json
```

#### 嵌套結構（npm v2 及之前）

```
node_modules/
├── package-a/
│   ├── node_modules/
│   │   └── package-c@1.0.0/
│   └── package.json
└── package-b/
    ├── node_modules/
    │   └── package-c@2.0.0/    # 不同版本
    └── package.json
```

**問題**：
- 深層嵌套（Windows 路徑長度限制）
- 重複的依賴（佔用大量空間）
- 安裝速度慢

#### 扁平化結構（npm v3+）

```
node_modules/
├── package-a/
│   └── package.json
├── package-b/
│   ├── node_modules/
│   │   └── package-c@2.0.0/    # 版本衝突，保留嵌套
│   └── package.json
├── package-c@1.0.0/             # 提升到頂層
└── shared-dep/                  # 共享依賴
```

**優點**：
- 減少嵌套深度
- 共享依賴（節省空間）
- 安裝速度更快

**缺點**：
- 非確定性（安裝順序影響結構）
- 幽靈依賴問題

### 2. 模組解析算法

#### Node.js 模組解析流程

```javascript
require('express')

// 解析步驟：
// 1. 核心模組？
//    - 是：直接載入（如 fs, http, path）
//    - 否：繼續

// 2. 相對路徑？
require('./express')   // 相對路徑
require('../express')  // 相對路徑
//    - 是：從當前目錄解析
//    - 否：繼續

// 3. 絕對路徑？
require('/usr/local/lib/express')
//    - 是：直接載入
//    - 否：繼續

// 4. node_modules 查找
//    從當前目錄開始，逐層向上查找：
//    /current/dir/node_modules/express
//    /current/node_modules/express
//    /node_modules/express
```

**詳細算法**：

```
require(X) from module at path Y

1. 如果 X 是核心模組
   a. 返回核心模組
   b. 停止

2. 如果 X 以 '/' 開頭
   a. 設置 Y 為文件系統根目錄

3. 如果 X 以 './' 或 '../' 或 '/' 開頭
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
   c. 拋出 "not found"

4. 如果 X 以 '#' 開頭
   a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))

5. LOAD_PACKAGE_SELF(X, dirname(Y))
6. LOAD_NODE_MODULES(X, dirname(Y))
7. 拋出 "not found"
```

```
LOAD_AS_FILE(X)
1. 如果 X 是文件，載入 X 作為 JavaScript
   返回

2. 如果 X.js 是文件，載入 X.js
   返回

3. 如果 X.json 是文件，解析 X.json 為 JavaScript 物件
   返回

4. 如果 X.node 是文件，載入 X.node 為二進制插件
   返回
```

```
LOAD_AS_DIRECTORY(X)
1. 如果 X/package.json 存在
   a. 解析 package.json
   b. 讀取 "main" 欄位
   c. LOAD_AS_FILE(X + main)
   d. LOAD_INDEX(X + main)

2. LOAD_INDEX(X)
```

```
LOAD_INDEX(X)
1. 如果 X/index.js 是文件，載入 X/index.js
   返回

2. 如果 X/index.json 是文件，解析為物件
   返回

3. 如果 X/index.node 是文件，載入為二進制
   返回
```

```
LOAD_NODE_MODULES(X, START)
1. DIRS = NODE_MODULES_PATHS(START)
2. 對於 DIRS 中的每個 DIR
   a. LOAD_PACKAGE_EXPORTS(X, DIR)
   b. LOAD_AS_FILE(DIR/X)
   c. LOAD_AS_DIRECTORY(DIR/X)
```

```
NODE_MODULES_PATHS(START)
1. PARTS = path split(START)
2. I = PARTS.length - 1
3. DIRS = []
4. while I >= 0
   a. 如果 PARTS[I] = "node_modules" 繼續
   b. DIR = path join(PARTS[0 .. I] + "node_modules")
   c. DIRS.push(DIR)
   d. I = I - 1

5. 返回 DIRS

範例：
START = /home/user/projects/my-app/src/utils
返回：
[
  /home/user/projects/my-app/src/utils/node_modules
  /home/user/projects/my-app/src/node_modules
  /home/user/projects/my-app/node_modules
  /home/user/projects/node_modules
  /home/user/node_modules
  /home/node_modules
  /node_modules
]
```

#### ES Modules 解析

```javascript
import express from 'express'

// ESM 解析規則：
// 1. 必須有明確的文件副檔名（除非使用 exports）
// 2. package.json 的 "type": "module"
// 3. 或使用 .mjs 副檔名
```

```json
// package.json
{
  "type": "module",  // 所有 .js 文件視為 ESM
  
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    },
    "./utils": "./dist/utils.mjs"
  }
}
```

### 3. 依賴提升（Hoisting）

**npm/yarn v1 的提升策略**：

```bash
# package.json
{
  "dependencies": {
    "express": "^4.18.0",
    "koa": "^2.14.0"
  }
}

# express 依賴：
# - body-parser@1.20.0
# - cookie-parser@1.4.6

# koa 依賴：
# - cookie-parser@1.4.5  # 不同版本！

# 結果結構：
node_modules/
├── express/
├── koa/
│   └── node_modules/
│       └── cookie-parser@1.4.5/  # 保留在這裡
├── body-parser@1.20.0/            # 提升
└── cookie-parser@1.4.6/           # 提升（先安裝的版本）
```

**提升規則**：
1. 第一個被安裝的版本會被提升
2. 後續不相容的版本保留在各自的 node_modules
3. 安裝順序決定最終結構（非確定性）

### 4. 幽靈依賴（Phantom Dependencies）

**問題描述**：
可以 require 未在 package.json 中聲明的依賴。

```javascript
// package.json
{
  "dependencies": {
    "express": "^4.18.0"  // 只聲明了 express
  }
}

// index.js
const bodyParser = require('body-parser')  // ✅ 可以運行！
// body-parser 是 express 的依賴，被提升到頂層

// 問題：
// 1. express 未來可能移除 body-parser
// 2. 更新 express 可能導致你的代碼崩潰
```

**如何避免**：

```bash
# 1. 明確聲明所有直接依賴
npm install body-parser

# 2. 使用 pnpm（自動避免幽靈依賴）
pnpm install

# 3. 啟用 npm/yarn 的嚴格模式（未來功能）
```

### 5. 不同包管理器對比

#### npm（預設）

```bash
# 安裝
npm install

# 結構：扁平化 + 部分嵌套
node_modules/
├── package-a/
├── package-b/
│   └── node_modules/
│       └── conflict-pkg@2.0.0/
└── shared-pkg/
```

**特點**：
- 扁平化結構
- 有幽靈依賴問題
- node_modules 大小：中等

#### yarn v1

```bash
# 安裝
yarn install

# 結構：類似 npm
node_modules/
├── package-a/
├── package-b/
└── shared-pkg/
```

**特點**：
- 類似 npm 的扁平化
- 更快的安裝速度（並行）
- yarn.lock 鎖定版本
- 有幽靈依賴問題

#### pnpm（推薦）

```bash
# 安裝
pnpm install

# 結構：符號連結 + 內容可尋址存儲
node_modules/
├── .pnpm/                        # 實際存儲
│   ├── express@4.18.0/
│   │   └── node_modules/
│   │       ├── express/          # 實際文件
│   │       └── body-parser/      # 符號連結
│   └── body-parser@1.20.0/
│       └── node_modules/
│           └── body-parser/
├── express -> .pnpm/express@4.18.0/node_modules/express
└── lodash -> .pnpm/lodash@4.17.21/node_modules/lodash
```

**優勢**：
- ✅ 沒有幽靈依賴（嚴格的依賴隔離）
- ✅ 節省磁碟空間（全局內容可尋址存儲）
- ✅ 安裝速度快
- ✅ 嚴格的 peer dependencies

**全局存儲**：

```
~/.pnpm-store/
└── v3/
    └── files/
        ├── 00/
        │   └── abc123...  # 內容可尋址
        ├── 01/
        └── ...

# 所有專案共享相同的套件文件（硬連結）
```

#### yarn v2/v3 (Berry)

```bash
# 使用 PnP（Plug'n'Play）模式
yarn install

# 不生成 node_modules！
.yarn/
├── cache/          # 壓縮的套件
└── unplugged/      # 需要解壓的套件

.pnp.cjs            # 模組解析映射
```

**PnP 模式**：
- 沒有 node_modules
- 使用 `.pnp.cjs` 映射模組路徑
- 安裝超快（不需要複製文件）
- 但相容性問題較多

**Node-modules 模式**：

```bash
# yarn 3 也可以使用傳統模式
yarn config set nodeLinker node-modules
```

### 6. 模組解析問題診斷

#### 問題 1：找不到模組

```
Error: Cannot find module 'express'
```

**診斷步驟**：

```bash
# 1. 檢查是否安裝
npm ls express

# 2. 檢查 node_modules
ls node_modules/express

# 3. 檢查 package.json
cat package.json | grep express

# 4. 重新安裝
rm -rf node_modules package-lock.json
npm install
```

#### 問題 2：版本衝突

```
Warning: Dependency conflict
```

**解決方案**：

```bash
# 1. 查看衝突詳情
npm ls <package-name>

# 2. 強制解析到單一版本（yarn）
{
  "resolutions": {
    "package-name": "1.2.3"
  }
}

# npm (overrides)
{
  "overrides": {
    "package-name": "1.2.3"
  }
}

# pnpm
{
  "pnpm": {
    "overrides": {
      "package-name": "1.2.3"
    }
  }
}
```

#### 問題 3：幽靈依賴

```javascript
// 代碼可以運行，但：
const dep = require('undeclared-dependency')
// ✅ 開發環境 OK
// ❌ 生產環境失敗
```

**檢測**：

```bash
# 使用 dependency-check
npx dependency-check .

# 或使用 depcheck
npx depcheck

# 結果：
Unused dependencies:
- package-a

Missing dependencies:
- undeclared-dependency (used in index.js)
```

### 7. 優化 node_modules

#### 清理未使用的依賴

```bash
# 查找未使用的依賴
npx depcheck

# 移除
npm uninstall unused-package

# 清理快取
npm cache clean --force
```

#### 減少安裝大小

```bash
# 只安裝生產依賴
npm install --production

# 或設置環境變數
NODE_ENV=production npm install
```

```json
{
  "scripts": {
    "install:prod": "npm ci --production"
  }
}
```

#### 使用 .npmrc 優化

```ini
# .npmrc
# 不安裝 optional dependencies
optional=false

# 跳過 postinstall scripts（謹慎使用）
ignore-scripts=true

# 使用更快的網路
registry=https://registry.npm.taobao.org

# 更嚴格的引擎檢查
engine-strict=true
```

### 8. Monorepo 中的依賴管理

#### Workspaces 結構

```
monorepo/
├── package.json          # 根 package.json
├── node_modules/         # 共享依賴
│   ├── shared-dep/
│   └── .bin/
├── packages/
│   ├── app-a/
│   │   ├── package.json
│   │   └── node_modules/  # app-a 特有依賴
│   └── app-b/
│       ├── package.json
│       └── node_modules/
```

**優勢**：
- 共享依賴（減少安裝時間）
- 統一版本管理
- 本地套件連結

#### pnpm Workspaces

```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'apps/*'
```

```json
// packages/app-a/package.json
{
  "dependencies": {
    "@myorg/shared": "workspace:*"  // 引用本地套件
  }
}
```

### 9. 最佳實踐

```bash
# ✅ 使用 pnpm（避免幽靈依賴）
npm install -g pnpm
pnpm install

# ✅ 鎖定依賴版本
# 提交 package-lock.json / pnpm-lock.yaml

# ✅ 使用 npm ci 在 CI/CD
npm ci  # 更快、更可靠

# ✅ 定期清理
npm prune  # 移除未使用的套件

# ✅ 檢查安全漏洞
npm audit
npm audit fix

# ✅ 明確聲明所有直接依賴
# 不依賴幽靈依賴
```

**package.json 最佳實踐**：

```json
{
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "packageManager": "pnpm@8.0.0",  // 指定包管理器
  
  "dependencies": {
    "express": "^4.18.0"
  },
  
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

## 總結

**node_modules 演進**：
- npm v2：深層嵌套
- npm v3+：扁平化
- pnpm：符號連結 + 內容可尋址
- yarn PnP：無 node_modules

**模組解析**：
1. 核心模組
2. 相對/絕對路徑
3. node_modules 查找（逐層向上）

**常見問題**：
- 幽靈依賴：使用 pnpm 或明確聲明
- 版本衝突：使用 resolutions/overrides
- 安裝緩慢：使用 pnpm 或 yarn

**推薦工具**：
- **pnpm**：速度快、節省空間、無幽靈依賴
- **depcheck**：檢查未使用/缺失的依賴
- **npm-check-updates**：檢查可更新的套件

理解 node_modules 和模組解析是處理依賴問題的關鍵。
