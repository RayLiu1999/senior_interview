# 比較 Node.js 套件管理器：npm vs. Yarn vs. pnpm

- **難度**: 6
- **標籤**: `Node.js`, `npm`, `Yarn`, `pnpm`, `Package Manager`

## 問題詳述

`npm` 是 Node.js 的預設套件管理器，但社群也發展出了 Yarn 和 pnpm 等替代方案。請比較這三者在 `node_modules` 結構、性能、磁碟空間使用和功能特性上的主要差異。

## 核心理論與詳解

套件管理器是 Node.js 生態系統的支柱，它負責處理專案的依賴安裝、版本控制和腳本執行。雖然它們的目標相同，但實現方式卻大相徑庭，尤其是在處理 `node_modules` 目錄結構方面。

### 1. npm (Node Package Manager)

`npm` 是 Node.js 自帶的官方套件管理器，歷史最悠久，用戶群最廣泛。

- **`node_modules` 結構**:
  - **v2 及之前**: **巢狀結構 (Nested)**。每個依賴項都有自己獨立的 `node_modules` 資料夾來存放其子依賴。
    - **優點**: 結構清晰，依賴關係隔離得很好。
    - **缺點**: 產生大量重複的套件（磁碟空間浪費），檔案路徑過長（在 Windows 上容易出錯），依賴關係更新困難。
  - **v3 及之後**: **扁平化結構 (Flat)**。`npm` 會嘗試將所有依賴（包括子依賴）都提升到 `node_modules` 的頂層。
    - **優點**: 大大減少了套件重複，解決了路徑過長的問題。
    - **缺點**:
      - **不確定性**: 依賴的提升順序取決於安裝順序，可能導致同樣的 `package.json` 在不同時間安裝產生不同的 `node_modules` 結構。為了解決這個問題，`npm v5` 引入了 `package-lock.json`。
      - **幽靈依賴 (Phantom Dependencies)**: 由於所有東西都被提升，專案可以非法地存取到那些沒有在 `package.json` 中明確聲明的套件（即子依賴）。
- **性能**: 早期版本較慢，但從 v5 開始有顯著改進，引入了快取和 `package-lock.json`。
- **磁碟空間**: 扁平化結構比巢狀結構好，但仍然存在多個專案之間無法共享相同套件副本的問題。

### 2. Yarn (Yet Another Resource Negotiator)

Yarn 由 Facebook (現 Meta) 於 2016 年推出，旨在解決 `npm` 早期版本在性能、穩定性和安全性上的問題。

- **`node_modules` 結構**:
  - **Yarn 1 (Classic)**: 採用與 `npm v3+` 類似的 **扁平化結構**，並通過 `yarn.lock` 檔案來確保依賴結構的一致性。
  - **Yarn 2+ (Berry)**: 引入了 **Plug'n'Play (PnP)** 的革命性概念。它不再使用 `node_modules` 資料夾，而是生成一個 `.pnp.cjs` 檔案。
    - 這個檔案包含了專案所有依賴的位置資訊以及它們之間的關係圖。
    - **優點**:
      - **極速安裝**: 無需將大量檔案寫入 `node_modules`，安裝速度極快。
      - **零幽靈依賴**: 程式碼無法存取未聲明的套件。
      - **啟動更快**: Node.js 啟動時無需遍歷 `node_modules` 來解析模組位置。
    - **缺點**: 與某些不遵循標準 Node.js 模組解析演算法的工具（如舊版的 `react-native`）存在相容性問題。
- **性能**: Yarn Classic 的並行安裝使其比早期的 `npm` 快得多。Yarn PnP 則更快。
- **磁碟空間**: Yarn PnP 因為沒有 `node_modules`，專案本身佔用空間極小。

### 3. pnpm (performant npm)

`pnpm` 是一個後起之秀，它的目標是結合 `npm` 和 `Yarn` 的優點，同時解決 `node_modules` 帶來的根本問題。

- **`node_modules` 結構**:
  - **內容可定址儲存 (Content-addressable Store)**: `pnpm` 的核心思想是，所有套件的檔案都儲存在一個**全域的、內容可定址的儲存區** (`~/.pnpm-store`) 中。
  - **符號連結 (Symbolic Links) 和硬連結 (Hard Links)**:
    1. 當你安裝一個依賴時，`pnpm` 會將該依賴從全域儲存區**硬連結**到專案的 `node_modules/.pnpm` 資料夾中。硬連結不會佔用額外的磁碟空間。
    2. 然後，`pnpm` 只將 `package.json` 中明確聲明的**直接依賴**以**符號連結**的方式連結到 `node_modules` 的頂層。
  - **結果**:
    - `node_modules` 看起來非常整潔，只有你直接依賴的套件。
    - 每個套件的子依賴都儲存在 `.pnpm` 資料夾內，並通過符號連結相互關聯。
- **優點**:
  - **極省磁碟空間**: 所有專案共享同一個全域儲存區，一個套件的一個版本在磁碟上只會有一份實體檔案。
  - **安裝速度極快**: 如果某個版本的套件已存在於全域儲存區，安裝時只需創建連結，幾乎是瞬間完成。
  - **嚴格的依賴管理**: 完美解決了幽靈依賴問題，因為只有直接依賴在 `node_modules` 的頂層可見。
  - **確定性**: 相同的 `pnpm-lock.yaml` 總會產生完全相同的 `node_modules` 結構。

### 核心差異總結

| 特性 | npm | Yarn (Classic) | Yarn (PnP) | pnpm |
| :--- | :--- | :--- | :--- | :--- |
| **`node_modules` 結構** | 扁平化 | 扁平化 | **無 `node_modules`** (PnP) | **符號連結** + 全域儲存 |
| **幽靈依賴** | 存在 | 存在 | **不存在** | **不存在** |
| **磁碟空間效率** | 低 (專案間不共享) | 低 (專案間不共享) | 高 | **極高** (全域共享) |
| **安裝性能** | 中等 | 快 | **極快** | **極快** |
| **確定性** | 依賴 `package-lock.json` | 依賴 `yarn.lock` | 極高 | 極高 |
| **生態相容性** | 最好 | 好 | 可能有問題 | **非常好** |

## 結論

- **npm**: 作為官方工具，穩定且可靠。對於小型專案或不關心磁碟空間和安裝速度的場景，它依然是一個不錯的選擇。
- **Yarn**: Yarn Classic 是一個穩定的 `npm` 替代品。Yarn PnP 則是一個面向未來的激進方案，提供了極致的性能，但可能需要應對一些生態相容性挑戰。
- **pnpm**: `pnpm` 被許多人認為是目前解決方案中的「集大成者」。它通過巧妙的連結機制，**同時解決了磁碟空間、安裝速度和幽靈依賴三大問題**，並且保持了與現有生態的高度相容性。對於新的大型專案或 Monorepo 專案，`pnpm` 是一個強烈推薦的選擇。

隨著時間的推移，`pnpm` 的理念正被越來越多的開發者和公司所接受，成為 `npm` 最有力的競爭者。
