# 比較 Node.js 中的阻塞式 I/O 與非阻塞式 I/O

- **難度**: 6
- **重要程度**: 5
- **標籤**: `Node.js`, `Blocking I/O`, `Non-blocking I/O`, `Asynchronous`

## 問題詳述

請解釋什麼是阻塞式 I/O (Blocking I/O) 和非阻塞式 I/O (Non-blocking I/O)，並舉例說明它們在 Node.js 中的體現。為什麼 Node.js 選擇非阻塞式 I/O 作為其核心模型？

## 核心理論與詳解

I/O (Input/Output) 操作是程式與外部世界（如檔案系統、資料庫、網路）互動的通道。根據 I/O 操作在等待結果時是否會「卡住」主執行緒，可以將其分為阻塞式和非阻塞式兩種模型。

### 1. 阻塞式 I/O (Blocking I/O)

阻塞式 I/O 是指當一個程式發起一個 I/O 操作時，它會一直等待該操作徹底完成，然後才繼續執行後續的程式碼。在等待期間，執行緒會被掛起，無法處理任何其他任務。

**比喻**:
想像你去一家咖啡店，點了一杯咖啡。在阻塞式模型下，你必須站在櫃檯前一直等到咖啡師把你的咖啡做好遞給你，這期間你什麼也做不了。

**特點**:

- **同步 (Synchronous)**: 程式碼按順序執行，一個操作完成後下一個才能開始。
- **簡單直觀**: 邏輯清晰，易於理解和編寫。
- **效率低下**: 在高並發場景下，大量的等待時間會導致系統吞吐量急劇下降。如果伺服器為每個請求都分配一個執行緒，那麼當大量請求都在等待 I/O 時，會產生巨大的執行緒開銷和上下文切換成本。

**在 Node.js 中的體現**:
雖然 Node.js 的核心是非阻塞的，但其標準庫也提供了一些阻塞式的同步方法，通常以 `Sync` 作為後綴。這些方法主要用於腳本初始化或一次性任務，**強烈不建議在生產環境的 Web 伺服器中使用**。

```javascript
// 阻塞式檔案讀取範例
const fs = require('fs');

console.log('開始讀取檔案...');

try {
  // readFileSync 會阻塞主執行緒，直到檔案讀取完成
  const data = fs.readFileSync('./my-file.txt', 'utf8');
  console.log('檔案讀取完成:', data);
} catch (err) {
  console.error('讀取檔案時發生錯誤:', err);
}

console.log('這是檔案讀取之後的程式碼。');
```

在上面的程式碼中，`console.log('這是檔案讀取之後的程式碼。')` 必須等到 `fs.readFileSync` 完全結束後才能被執行。

### 2. 非阻塞式 I/O (Non-blocking I/O)

非阻塞式 I/O 是指當一個程式發起一個 I/O 操作時，它會立即返回，不會等待操作完成。程式可以繼續執行後續的程式碼。當 I/O 操作完成後，系統會通過某種機制（在 Node.js 中是事件循環和回呼函式）來通知程式。

**比喻**:
在非阻塞式模型下，你點完咖啡後會拿到一個取餐呼叫器。然後你可以找個位子坐下，玩手機或做其他事情。當你的咖啡準備好時，呼叫器會震動，你再去取餐。

**特點**:

- **異步 (Asynchronous)**: 發起操作後無需等待結果，可以繼續做其他事。
- **高效率和高吞吐量**: 單一執行緒可以在等待一個 I/O 操作的同時，處理成千上萬個其他任務，極大地提高了資源利用率。
- **基於事件驅動**: 依賴事件循環來處理已完成的 I/O 操作的回呼。
- **邏輯相對複雜**: 回呼函式（Callback）的嵌套可能導致「回呼地獄 (Callback Hell)」，但可以通過 Promises、Async/Await 等現代 JavaScript 語法來優雅地解決。

**在 Node.js 中的體現**:
Node.js 的絕大部分 I/O API 都是非阻塞的異步版本。

```javascript
// 非阻塞式檔案讀取範例
const fs = require('fs');

console.log('開始讀取檔案...');

// readFile 是非阻塞的，它會立即返回，並在背景執行檔案讀取
fs.readFile('./my-file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('讀取檔案時發生錯誤:', err);
    return;
  }
  console.log('檔案讀取完成:', data);
});

console.log('這是檔案讀取之後的程式碼。');
```

在上面的程式碼中，`fs.readFile` 會立即返回，所以 `console.log('這是檔案讀取之後的程式碼。')` 會先被打印出來。檔案讀取操作在背景由 Libuv 的執行緒池處理，完成後，其回呼函式會被放入事件循環的佇列中，等待主執行緒空閒時執行。

### 3. 為什麼 Node.js 選擇非阻塞模型？

Node.js 的設計初衷是為了解決高並發、I/O 密集型的網路應用場景（例如 Web 伺服器、API 閘道、即時通訊應用等）。在這些場景中，應用程式的大部分時間都花在等待網路請求、資料庫查詢或檔案讀寫等 I/O 操作上。

- **單執行緒的優勢**: 傳統的多執行緒阻塞模型中，每個連接都需要一個執行緒，當連接數增多時，記憶體消耗和執行緒上下文切換的開銷會變得非常巨大。Node.js 的單執行緒模型避免了這些問題。
- **事件循環的威力**: 配合事件循環，單一執行緒可以高效地處理大量並發的 I/O 操作。當一個 I/O 操作被發起後，執行緒可以立即去處理下一個事件，而不是空閒等待。
- **與 JavaScript 的契合**: JavaScript 作為一門事件驅動的語言（例如瀏覽器中的點擊、滑鼠移動事件），其語言特性與非阻塞、事件驅動的伺服器模型天然契合。

## 總結

| 特性 | 阻塞式 I/O (Blocking I/O) | 非阻塞式 I/O (Non-blocking I/O) |
| :--- | :--- | :--- |
| **執行緒狀態** | 等待 I/O 時，執行緒被掛起 | 發起 I/O 後，執行緒繼續執行 |
| **程式模型** | 同步 (Synchronous) | 異步 (Asynchronous) |
| **Node.js 範例** | `fs.readFileSync()`, `fs.writeFileSync()` | `fs.readFile()`, `fs.writeFile()` |
| **適用場景** | 簡單腳本、應用程式啟動時的配置加載 | 高並發、I/O 密集的網路應用 |
| **優點** | 程式碼簡單，符合直覺 | 資源利用率高，系統吞吐量大 |
| **缺點** | 並發能力差，資源浪費 | 程式碼邏輯相對複雜（需處理回呼） |

通過擁抱非阻塞 I/O，Node.js 成功地在單執行緒模型下實現了卓越的性能和擴展性，使其成為現代後端開發的熱門選擇。
