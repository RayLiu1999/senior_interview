# PHP 的垃圾回收 (Garbage Collection) 機制是如何運作的？

- **難度**: 7
- **重要程度**: 3
- **標籤**: `PHP`, `Core`, `Internals`, `Memory Management`

## 問題詳述

記憶體管理是任何程式語言的關鍵部分。PHP 作為一門高階語言，為開發者自動處理了大部分記憶體管理工作，其中垃圾回收 (GC) 是核心機制之一。請解釋 PHP 的垃圾回收機制是如何運作的？`zval` 在其中扮演什麼角色？以及什麼是「循環引用」問題，PHP 是如何解決這個問題的？

## 核心理論與詳解

PHP 的記憶體管理核心圍繞著一個名為 `zval` (Zend Value) 的內部資料結構。理解 `zval` 是理解 PHP 變數和垃圾回收的基礎。

### 1. `zval` 與引用計數 (Reference Counting)

在 PHP 內部，每個變數都儲存在一個 `zval` 容器中。一個簡化的 `zval` 結構包含以下幾個關鍵部分：

- **`value`**: 變數的實際值（例如整數、字串、陣列等）。
- **`type`**: 變數的類型（`IS_STRING`, `IS_ARRAY` 等）。
- **`refcount`**: 一個引用計數器，記錄有多少個「符號」（即變數名）指向這個 `zval`。
- **`is_ref`**: 一個布林值，標記這個 `zval` 是否是一個「引用」(&)。

**基本的引用計數機制** 非常直觀：

1. **創建**: 當一個變數被賦值時，PHP 會創建一個 `zval` 容器，並將其 `refcount` 設為 1。

    ```php
    $a = "Hello"; // 創建一個 zval，"Hello" 的 refcount = 1
    ```

2. **增加**: 當另一個變數指向同一個 `zval` 時，`refcount` 會加 1。

    ```php
    $b = $a; // $a 和 $b 指向同一個 zval，"Hello" 的 refcount = 2
    ```

3. **減少**: 當一個變數被 `unset` 或離開其作用域時，它所指向的 `zval` 的 `refcount` 會減 1。

    ```php
    unset($b); // "Hello" 的 refcount = 1
    ```

4. **銷毀**: 當一個 `zval` 的 `refcount` 變為 0 時，表示沒有任何變數再指向它，PHP 就會釋放這個 `zval` 佔用的記憶體。這就是最基礎的「垃圾回收」。

### 2. 循環引用問題

單純的引用計數機制無法處理 **循環引用 (Circular References)** 的情況。當兩個或多個物件（或陣列）互相引用，形成一個閉環時，它們的 `refcount` 將永遠不會變為 0，即使它們已經沒有被外部的任何變數所使用。

**範例**:

```php
<?php
$a = new stdClass();
$b = new stdClass();

$a->child = $b; // $b 的 zval 的 refcount 增加
$b->parent = $a; // $a 的 zval 的 refcount 增加

// 此時，$a 和 $b 的 refcount 至少為 2

unset($a); // $a 的 zval 的 refcount 減 1，但不為 0
unset($b); // $b 的 zval 的 refcount 減 1，但不為 0
?>
```

在 `unset($a)` 和 `unset($b)` 之後，變數 `$a` 和 `$b` 本身已經被銷毀，但它們所指向的物件記憶體並沒有被釋放。因為 `$a` 物件內部還被 `$b->parent` 引用，而 `$b` 物件內部還被 `$a->child` 引用。它們的 `refcount` 都大於 0，導致了 **記憶體洩漏 (Memory Leak)**。

### 3. PHP 的同步週期回收演算法 (Concurrent Cycle Collection)

為了解決循環引用問題，PHP 5.3 引入了一種更先進的垃圾回收機制。這個機制並 **不是** 實時運作的，而是週期性地觸發。

**核心思想**:
PHP 的 GC 機制專門用來檢測並清理那些 `refcount` 大於 0 但實際上已經是垃圾的 `zval`（即循環引用的節點）。

**運作流程**:

1. **根緩衝區 (Root Buffer)**: PHP 維護了一個「根緩衝區」，用來存放所有可能產生循環引用的 `zval`（主要是陣列和物件）。當一個 `zval` 的 `refcount` 減少且不為 0 時，它會被放入這個緩衝區。當緩衝區滿了（預設 10,000 個節點），GC 機制就會被觸發。

2. **模擬刪除 (Simulated Deletion)**:
    - GC 演算法遍歷根緩衝區中的所有 `zval`。
    - 對於每一個 `zval`，它會 **模擬地** 將其 `refcount` 減 1。這一步的意義在於：如果一個 `zval` 的引用完全來自於循環引用內部，那麼在模擬刪除後，它的 `refcount` 就會變為 0。如果它還被外部變數引用，那麼 `refcount` 仍然會大於 0。

3. **模擬恢復 (Simulated Restoration)**:
    - 演算法再次遍歷所有節點。
    - 如果一個節點在模擬刪除後，其 `refcount` **不為 0**，說明它是一個「活」的節點（被外部變數引用）。演算法會將這個節點以及它能遍歷到的所有子節點的 `refcount` **恢復**（即加 1），並將它們標記為非垃圾。

4. **清理垃圾**:
    - 經過前兩步，根緩衝區中所有 `refcount` 仍然為 0 的 `zval` 就是真正的垃圾（即循環引用且無外部引用的節點）。
    - PHP 會遍歷這些節點，並將它們從記憶體中徹底釋放。

### 總結

- PHP 的主要記憶體管理依賴 **引用計數**，這是一種高效、即時的垃圾回收方式，適用於絕大多數情況。
- 為了處理引用計數無法解決的 **循環引用** 問題，PHP 引入了一個 **同步週期回收演算法** 作為補充。
- 這個演算法不是實時的，它會在一個包含潛在垃圾的緩衝區滿了之後觸發。
- 演算法通過「模擬刪除」和「模擬恢復」來識別出那些雖然 `refcount` > 0 但實際上已經脫離主程式作用域的循環引用結構，並將其清理。
- 開發者可以通過 `gc_enable()`, `gc_disable()` 和 `gc_collect_cycles()` 函式來手動控制 GC 的行為，但在絕大多數情況下，讓 PHP 自動管理是最佳選擇。
