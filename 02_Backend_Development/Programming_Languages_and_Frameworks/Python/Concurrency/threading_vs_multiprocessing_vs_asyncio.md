# Python 併發模型：多執行緒 vs. 多進程 vs. 異步

- **難度**: 8
- **重要程度**: 5
- **標籤**: `Python`, `Concurrency`, `Threading`, `Multiprocessing`, `Asyncio`

## 問題詳述

Python 提供了多種實現併發 (Concurrency) 的方式，主要是多執行緒 (`threading`)、多進程 (`multiprocessing`) 和異步 (`asyncio`)。請詳細比較這三種模型的運作原理、優缺點以及它們各自最適合的應用場景。在 CPython 的 GIL (全域直譯器鎖) 限制下，它們的表現有何不同？

## 核心理論與詳解

理解 Python 的併發模型以及如何根據任務類型做出正確的選擇，是資深後端工程師的必備技能。這三種模型解決了不同類型的問題，其選擇主要受到 GIL 和任務是 CPU 密集型還是 I/O 密集型的影響。

### 1. 多執行緒 (`threading`)

- **運作原理**:
  - 在單一進程內創建多個執行緒，這些執行緒共享同一個記憶體空間。
  - 作業系統可以在不同執行緒之間快速切換，從而產生“同時”執行的錯覺。
  - 在 CPython 中，由於 GIL 的存在，任何時候只有一個執行緒能執行 Python 位元組碼。當一個執行緒遇到 I/O 操作（如網路請求、檔案讀寫）時，它會釋放 GIL，讓其他執行緒有機會執行。

- **優點**:
  - **輕量級**: 執行緒的創建和銷毀比進程快。
  - **共享記憶體**: 執行緒之間共享數據非常方便，無需複雜的進程間通訊 (IPC)。

- **缺點**:
  - **受 GIL 限制**: 對於 CPU 密集型任務，多執行緒無法利用多核 CPU 的優勢，性能甚至可能因為執行緒切換的開銷而下降。
  - **競爭條件**: 由於共享記憶體，需要使用鎖 (`Lock`, `RLock` 等) 來避免數據競爭，增加了程式的複雜性。

- **適用場景**:
  - **I/O 密集型任務 (I/O-bound)**。例如：
    - 同時發起多個網路請求（網路爬蟲）。
    - 同時讀寫多個檔案。
    - 同時與多個資料庫連接進行交互。

### 2. 多進程 (`multiprocessing`)

- **運作原理**:
  - 創建多個獨立的 Python 直譯器進程。每個進程都有自己獨立的記憶體空間和自己的 GIL。
  - 作業系統可以將這些進程分配到不同的 CPU 核心上，實現真正的平行計算 (Parallelism)。

- **優點**:
  - **繞過 GIL**: 能夠充分利用多核 CPU 的計算能力，實現平行處理。
  - **隔離性好**: 每個進程有獨立的記憶體空間，一個進程的崩潰不會影響其他進程。

- **缺點**:
  - **資源消耗大**: 創建和維護進程的開銷遠大於執行緒。
  - **進程間通訊 (IPC) 複雜**: 進程間共享數據需要通過 `Queue`, `Pipe`, `Value`, `Array` 等序列化機制，比執行緒共享記憶體要慢且複雜。

- **適用場景**:
  - **CPU 密集型任務 (CPU-bound)**。例如：
    - 大規模的科學計算、數據分析。
    - 視頻編碼、圖像處理。
    - 平行執行複雜的演算法。

### 3. 異步 I/O (`asyncio`)

- **運作原理**:
  - `asyncio` 是基於**單一執行緒**的事件循環 (Event Loop) 和協程 (Coroutine) 模型。
  - 它不是平行計算，而是**並發**。在一個執行緒內，當一個任務（協程）遇到 I/O 阻塞時，它會顯式地掛起 (`await`)，事件循環會立即切換到另一個已就緒的任務去執行。
  - 這種切換是由程式本身控制的（通過 `async/await` 關鍵字），而不是由作業系統強制切換，因此開銷極小。

- **優點**:
  - **極高的效率**: 對於高併發 I/O 場景，`asyncio` 的性能遠超多執行緒，因為它沒有執行緒創建和上下文切換的開銷。
  - **單執行緒**: 無需處理執行緒安全問題和鎖，心智負擔較小。
  - **生態系統豐富**: 現代 Python Web 框架 (FastAPI, Sanic) 和網路庫 (aiohttp, httpx) 都基於 `asyncio`。

- **缺點**:
  - **對 CPU 密集型任務無能為力**: 如果一個協程執行了長時間的 CPU 計算而沒有 `await`，它會阻塞整個事件循環，導致所有其他任務都無法執行。
  - **傳染性**: `async` 代碼需要 `await` 來調用，而 `await` 只能在 `async` 函數中使用。一旦開始使用 `asyncio`，整個調用鏈往往都需要變成異步的。
  - **學習曲線**: 需要理解協程、事件循環、Future 等概念。

- **適用場景**:
  - **高併發、高 I/O 的網路應用**。例如：
    - Web 伺服器、API 後端。
    - 聊天伺服器、即時通訊。
    - 需要同時處理大量網路連接的應用。

### 總結與選型建議

| 特性 | `threading` (多執行緒) | `multiprocessing` (多進程) | `asyncio` (異步 I/O) |
| :--- | :--- | :--- | :--- |
| **核心思想** | 作業系統級執行緒切換 | 作業系統級進程切換 | 應用程式級任務切換 |
| **GIL 影響** | 受影響，無法利用多核 | 不受影響，可利用多核 | 在單執行緒內，與 GIL 無關 |
| **平行/並發** | 並發 (Concurrency) | 平行 (Parallelism) | 並發 (Concurrency) |
| **資源開銷** | 小 | 大 | 極小 |
| **數據共享** | 簡單 (共享記憶體) | 複雜 (IPC) | 簡單 (單執行緒) |
| **適用場景** | **I/O 密集型** | **CPU 密集型** | **高併發 I/O 密集型** |
| **範例** | 網路爬蟲、多檔案處理 | 科學計算、數據處理 | Web 伺服器、聊天應用 |

**選型心法**：

1. **任務是 CPU 密集型嗎？**
    - 是 -> 使用 `multiprocessing`。
2. **任務是 I/O 密集型嗎？**
    - 是 -> 接著問：**併發量要求高嗎？**
        - 是，且 I/O 操作支持異步（如網路請求） -> **優先選擇 `asyncio`**。
        - 否，或 I/O 操作是阻塞式的且沒有好的異步庫支持 -> 使用 `threading`。

在現代 Python 後端開發中，`asyncio` 因其在網路應用中的卓越性能而成為主流選擇，而 `multiprocessing` 則作為處理繁重計算的補充。`threading` 雖然依然有用，但在高併發網路場景下已逐漸被 `asyncio` 取代。
