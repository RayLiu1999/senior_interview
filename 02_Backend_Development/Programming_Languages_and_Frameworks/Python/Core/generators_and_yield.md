# Python 生成器與 yield 關鍵字

- **難度**: 6
- **重要程度**: 4
- **標籤**: `Python`, `Core`, `Generators`, `yield`, `Iterator`

## 問題詳述

什麼是 Python 的生成器 (Generator)？`yield` 關鍵字的作用是什麼，它與 `return` 有何不同？使用生成器相比於一次性返回一個完整的列表，有哪些優勢？請解釋生成器表達式 (Generator Expressions)。

## 核心理論與詳解

生成器是 Python 中一種強大且節省記憶體的工具，用於創建迭代器。與常規函數一次性計算並返回所有結果不同，生成器允許你“惰性地”逐個產生結果，僅在需要時才計算下一個值。

### 1. `yield` 關鍵字 vs. `return`

理解 `yield` 是理解生成器的關鍵。

- **`return`**: 當一個常規函數執行到 `return` 語句時，它會終止執行，並將 `return` 後面的值返回給調用者。函數內部所有的狀態都會被銷毀。
- **`yield`**: 當一個函數包含 `yield` 關鍵字時，它就不再是一個普通的函數，而是一個**生成器函數**。當調用一個生成器函數時，它不會立即執行，而是返回一個**生成器物件**（一種迭代器）。
  - 當 `for` 循環或其他迭代工具開始遍歷生成器物件時，函數的代碼才會開始執行。
  - 當執行到 `yield` 語句時，函數會“暫停”執行，並將 `yield` 後面的值“產生”給調用者。
  - 函數的所有內部狀態（包括局部變數）都會被保留。
  - 當下一次迭代請求值時，函數會從上次暫停的地方繼續執行，直到遇到下一個 `yield` 或函數結束。
  - 如果函數執行完畢而沒有更多的 `yield`，生成器會自動拋出 `StopIteration` 異常，標誌著迭代的結束。

### 2. 生成器的優勢

生成器最主要的優勢在於其**記憶體效率**。

- **常規函數**: 如果一個函數需要返回一個包含一百萬個元素的列表，它必須先在記憶體中創建並儲存這一百萬個元素，然後才能將整個列表返回。這會消耗大量的記憶體。
- **生成器**: 一個生成器在任何時候只在記憶體中保留單一項目的狀態。它逐個產生項目，處理完一個就丟棄，再去計算下一個。這使得生成器在處理大型數據集或無限序列時，記憶體佔用是恆定的，幾乎可以忽略不計。

**總結優勢**:
1.  **記憶體效率高**: 處理大數據流時，無需將所有數據一次性載入記憶體。
2.  **惰性求值 (Lazy Evaluation)**: 只有在需要時才計算下一個值，可以提升性能，特別是當我們只需要處理序列的前幾個元素時。
3.  **可讀性強**: 對於實現複雜的迭代邏輯，生成器可以讓代碼像寫一個普通函數一樣直觀，而無需手動實現一個迭代器類（即實現 `__iter__` 和 `__next__` 方法）。
4.  **能夠表示無限序列**: 由於惰性求值，生成器可以輕鬆地用來表示一個無限長的數據序列（例如，一個無限的計數器）。

### 3. 生成器表達式 (Generator Expressions)

生成器表達式是列表推導式 (List Comprehensions) 的一個惰性版本。它們的語法非常相似，但使用的是圓括號 `()` 而不是方括號 `[]`。

- **列表推導式**:
  ```python
  my_list = [i * i for i in range(10)] 
  # 這會立即在記憶體中創建一個包含 10 個元素的列表。
  ```
- **生成器表達式**:
  ```python
  my_gen = (i * i for i in range(10))
  # 這會創建一個生成器物件，不會立即計算任何值。
  ```

生成器表達式提供了一種簡潔、高效的方式來創建生成器，適用於簡單的迭代場景。

## 程式碼範例 (可選)

### 範例 1: 處理大型檔案

假設我們要讀取一個非常大的日誌檔案，並找出所有包含 "ERROR" 的行。

**使用列表 (低效)**:
```python
def find_errors_list(filepath):
    """一次性讀取整個檔案並返回列表，記憶體消耗大"""
    with open(filepath, 'r') as f:
        lines = f.readlines() # 將整個檔案載入記憶體
    return [line for line in lines if "ERROR" in line]
```

**使用生成器 (高效)**:
```python
def find_errors_generator(filepath):
    """逐行讀取檔案，使用 yield 產生結果，記憶體消耗小"""
    with open(filepath, 'r') as f:
        for line in f: # 檔案物件本身就是一個迭代器
            if "ERROR" in line:
                yield line

# 使用方式
# for error_line in find_errors_generator('large_log_file.log'):
#     print(error_line, end='')
```
在第二個版本中，無論日誌檔案有多大（即使是幾十 GB），程式的記憶體佔用都非常小。

### 範例 2: 無限序列

創建一個生成斐波那契數列的生成器。
```python
def fibonacci_generator():
    """產生無限的斐波那契數列"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 使用範例
fib_gen = fibonacci_generator()
print("前 10 個斐波那契數:")
for i in range(10):
    print(next(fib_gen), end=' ') # 輸出: 0 1 1 2 3 5 8 13 21 34 
```
這個例子如果用列表是無法實現的，因為斐波那契數列是無限的。
