# 資料庫索引的奧秘：B-Tree 與 LSM-Tree

- **難度**: 7
- **重要性**: 5
- **標籤**: `Databases`, `Indexing`, `B-Tree`, `LSM-Tree`

## 問題詳述

什麼是資料庫索引？為什麼它能加速查詢？請比較兩種主流的索引結構：B-Tree 和 LSM-Tree，並說明它們各自的優缺點和適用場景。

## 核心理論與詳解

### 什麼是資料庫索引？

資料庫索引是一種特殊的數據結構，它以犧牲**寫入效能**和**儲存空間**為代價，來大幅提升數據的**讀取速度**。你可以把它想像成一本書的目錄：沒有目錄，你需要逐頁翻閱才能找到特定章節；有了目錄，你可以直接定位到頁碼，快速找到內容。

在資料庫中，如果沒有索引，對某個條件的查詢（如 `WHERE name = 'John'`）需要進行**全表掃描 (Full Table Scan)**，其時間複雜度為 O(N)，其中 N 是表的總行數。而有了索引，查詢可以快速定位到數據所在的物理位置，時間複雜度可以降至 O(log N)。

### B-Tree (B樹)

B-Tree (及其變體 B+Tree) 是關聯式資料庫（如 MySQL, PostgreSQL）中最經典、最廣泛使用的索引結構。

#### 結構與原理

B+Tree 是一種自平衡的多路搜尋樹，專為磁碟等塊設備設計。

- **平衡性**: 樹的所有葉子節點都在同一層級，確保了任何查詢的路徑長度都大致相同。
- **多路**: 每個節點可以有多個子節點，這降低了樹的高度。由於磁碟 I/O 是昂貴的操作，較低的樹高意味著更少的磁碟讀取次數。
- **數據儲存**: 在 B+Tree 中，所有數據記錄都儲存在**葉子節點**上，並且葉子節點之間透過指針連接成一個有序的雙向鏈表。這極大地優化了**範圍查詢 (Range Query)**，例如 `WHERE age > 20`。
- **非葉子節點**: 只儲存鍵值和指向子節點的指針，作為索引的索引。

#### 寫入與讀取流程

- **讀取**: 從根節點開始，比較鍵值，逐層向下查找，直到到達葉子節點，找到對應的數據。
- **寫入 (更新/插入/刪除)**: 寫入操作是**原地更新 (In-place Update)** 的。
  1. 找到需要修改的數據所在的葉子節點。
  2. 直接在該頁面 (Page) 上進行修改。
  3. 如果修改導致頁面分裂或合併，會觸發樹的平衡調整，這可能涉及多個節點的 I/O 操作。

#### 優點

- **讀取效能極佳**: 特別是對於點查詢和範圍查詢，由於其有序的結構和平衡的高度，查詢效能非常穩定和高效。
- **成熟穩定**: 經過數十年的發展和驗證，是關聯式資料庫的基石。

#### 缺點

- **寫入效能相對較差**:
  - **原地更新**: 寫入操作是隨機 I/O，而隨機 I/O 通常比順序 I/O 慢得多。
  - **寫入放大 (Write Amplification)**: 即使只修改一行數據，也可能需要讀取和重寫整個數據頁（通常是 4KB 或 16KB）。
  - **鎖競爭**: 為了保證併發寫入的一致性，需要使用鎖，這在高併發寫入場景下會成為瓶頸。

### LSM-Tree (Log-Structured Merge-Tree)

LSM-Tree 是一種針對**高併發寫入**場景優化的數據結構，廣泛應用於 NoSQL 資料庫中，如 Cassandra, HBase, RocksDB, LevelDB。

#### 結構與原理

LSM-Tree 的核心思想是**放棄原地更新，將所有寫入操作都轉化為順序的日誌追加 (Append-only Log)**。

它主要由兩部分組成：

1. **MemTable**: 一個在**記憶體**中的數據結構（通常是紅黑樹或跳表），用於接收新的寫入。所有寫入操作都先進入 MemTable。
2. **SSTable (Sorted String Table)**: 一系列在**磁碟**上不可變的、有序的數據文件。

#### 寫入與讀取流程

- **寫入**:
  1. 數據首先被寫入一個預寫日誌 (WAL, Write-Ahead Log) 以確保持久性。
  2. 然後數據被寫入記憶體中的 **MemTable**。
  3. 當 MemTable 的大小達到一個閾值時，它會被**凍結**並轉換成一個新的、不可變的 **SSTable** 文件，順序地刷寫到磁碟上。這個過程非常快，因為是順序 I/O。
  4. 隨著時間推移，磁碟上會產生很多 SSTable 文件。後台會有一個 **Compaction (合併)** 進程，定期將多個小的 SSTable 合併成一個大的、更緊湊的 SSTable，並在這個過程中清理掉被覆蓋或刪除的數據。

- **讀取**:
  1. 首先查詢 MemTable。
  2. 如果沒找到，則**從新到舊**依次查詢磁碟上的 SSTable 文件。
  3. 為了加速查詢，通常會使用**布隆過濾器 (Bloom Filter)** 來快速判斷某個 key 是否可能存在於一個 SSTable 中，避免不必要的磁碟 I/O。
  4. 找到 key 對應的最新版本的值後返回。

#### 優點

- **極高的寫入吞吐量**: 將隨機寫入轉換為記憶體操作和磁碟的順序寫入，極大地提升了寫入效能。
- **高壓縮率**: 定期的 Compaction 過程可以有效地壓縮數據，節省儲存空間。

#### 缺點

- **讀取效能相對較差**:
  - **讀取放大 (Read Amplification)**: 一次讀取可能需要查詢多個 SSTable 文件才能找到最新的數據。
  - **範圍查詢較慢**: 數據分散在多個 SSTable 中，範圍查詢不如 B+Tree 高效。
- **Compaction 開銷**: 後台的合併操作會消耗一定的 CPU 和 I/O 資源，可能影響系統的穩定性。
- **空間放大 (Space Amplification)**: 在 Compaction 完成之前，舊的、被覆蓋的數據仍然佔用磁碟空間。

### 總結比較

| 特性 | B-Tree (B+Tree) | LSM-Tree |
| :--- | :--- | :--- |
| **核心思想** | 原地更新 (In-place Update) | 順序追加，延遲合併 |
| **寫入操作** | 隨機 I/O，較慢 | 順序 I/O，非常快 |
| **讀取操作** | 點查詢和範圍查詢都很快 | 點查詢較快，範圍查詢較慢 |
| **寫入放大** | 較高 | 較低 |
| **讀取放大** | 較低 | 較高 |
| **空間使用** | 較緊湊 | 可能有空間放大問題 |
| **適用資料庫** | MySQL, PostgreSQL (關聯式) | Cassandra, HBase, RocksDB (NoSQL) |
| **最佳場景** | 讀多寫少，需要強一致性和複雜查詢 | 寫多讀少，需要高寫入吞吐量 |

### 結論

B-Tree 和 LSM-Tree 是針對不同場景的權衡結果。

- **B-Tree** 犧牲了部分寫入效能，換取了極致的讀取效能和穩定性，是**讀密集型**和事務性應用的不二之選。
- **LSM-Tree** 則犧牲了部分讀取效能，換取了極高的寫入吞吐量，是**寫密集型**和海量數據儲存場景的理想選擇。

理解這兩種索引結構的底層原理，有助於我們在進行技術選型和系統設計時，做出更符合業務需求的決策。