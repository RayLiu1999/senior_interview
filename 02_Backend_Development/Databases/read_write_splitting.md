# 資料庫讀寫分離 (Database Read/Write Splitting)

- **難度**: 6
- **標籤**: `Database`, `Scalability`, `Architecture`, `Replication`

## 問題詳述

在系統擴展過程中，資料庫往往是最先遇到的瓶頸。請解釋什麼是「讀寫分離」，它是如何運作的？這是否意味著要將資料庫部署在不同的主機上？以及這種架構會帶來什麼樣的數據一致性問題？

## 核心理論與詳解

### 1. 什麼是讀寫分離？

是的，您的理解完全正確。**讀寫分離 (Read/Write Splitting)** 通常意味著將資料庫部署在**多個不同的主機節點 (Host Nodes)** 上。

這是一種利用資料庫**主從複製 (Master-Slave Replication)** 機制來提升系統讀取能力的架構模式。

- **主庫 (Master / Primary)**:
  - 負責處理所有的**寫入 (INSERT, UPDATE, DELETE)** 請求。
  - 也負責處理對數據一致性要求極高的**讀取 (SELECT)** 請求。
  - 將數據變更同步 (Replicate) 給從庫。
- **從庫 (Slave / Replica)**:
  - 負責處理大部分的**讀取 (SELECT)** 請求。
  - **不允許寫入** (通常設置為 Read-Only)。
  - 從主庫接收數據變更並應用到本地。

### 2. 為什麼要這樣做？ (Why)

大多數的網路應用程式都是 **讀多寫少 (Read-Heavy)** 的。
例如：

- **電商**: 瀏覽商品 (讀) 的次數遠大於下單 (寫)。
- **社群**: 看貼文 (讀) 的次數遠大於發貼文 (寫)。
- **新聞**: 閱讀新聞 (讀) 的次數遠大於編輯發布 (寫)。

如果一台資料庫主機每秒能處理 10,000 個請求，其中 8,000 個是讀，2,000 個是寫。
通過引入 2 台從庫分擔讀取流量，主庫就只需要專注處理那 2,000 個寫請求，系統整體的吞吐量 (Throughput) 就大幅提升了。

### 3. 架構運作流程

1. **寫入**: 應用程式將寫請求發送給 **Master**。
2. **複製**: Master 執行寫入後，將變更日誌 (如 MySQL 的 Binlog) 傳送給 **Slaves**。
3. **同步**: Slaves 接收日誌並在自己的數據庫中重放 (Replay)，更新數據。
4. **讀取**: 應用程式 (或中間件) 將讀請求發送給 **Slaves**。

### 4. 核心挑戰：複製延遲 (Replication Lag)

這是讀寫分離架構中**最大**的問題。

由於 Master 到 Slave 的數據複製通常是 **非同步 (Asynchronous)** 的（為了效能），這意味著在 Master 寫入成功後的**一小段時間內**（幾毫秒到幾秒），Slave 上的數據可能還沒更新。

**場景**:

1. 用戶修改了自己的個人資料 (寫入 Master)。
2. 用戶立刻刷新頁面查看 (讀取 Slave)。
3. 因為延遲，Slave 還沒收到更新，用戶看到舊的資料。
4. 用戶以為修改失敗，又改了一次。

這就是所謂的 **最終一致性 (Eventual Consistency)** 問題。

### 5. 解決方案

針對複製延遲，有幾種常見的應對策略：

1. **強制讀主 (Force Master Read)**:
   - 對於**對一致性要求極高**的場景（如：用戶查看自己剛修改的資料、訂單支付狀態），代碼層面強制路由到 Master 讀取。
   - 對於不敏感的數據（如：熱門商品列表、評論區），繼續讀 Slave。

2. **延遲讀取**:
   - 寫入後，讓前端 UI 轉圈圈等待幾秒再跳轉，給資料庫一點同步的時間（雖然有點髒，但很有效）。

3. **中間件路由 (Middleware Routing)**:
   - 使用如 ShardingSphere, ProxySQL 等中間件，它們可以根據請求類型自動路由，甚至追蹤複製延遲，如果某個 Slave 延遲太高，就暫時不將流量導給它。

### 6. 總結

| 特性 | 說明 |
| :--- | :--- |
| **部署方式** | 多台主機 (1 Master + N Slaves)。 |
| **核心目的** | 分擔讀取流量，提升系統吞吐量。 |
| **適用場景** | 讀多寫少的應用。 |
| **最大代價** | 數據複製延遲 (Replication Lag) 導致的短暫不一致。 |

讀寫分離是資料庫擴展的第一步，它簡單有效，但必須在代碼或架構層面處理好「剛寫完讀不到」的問題。
