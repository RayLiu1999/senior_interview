# 資料庫正規化 (Database Normalization)

- **難度**: 7
- **重要性**: 4
- **標籤**: `Databases`, `Normalization`, `SQL`

## 問題詳述

什麼是資料庫正規化？請解釋第一正規化 (1NF)、第二正規化 (2NF) 和第三正規化 (3NF) 的定義、目標和範例。正規化會帶來哪些優缺點？

## 核心理論與詳解

### 什麼是資料庫正規化？

資料庫正規化（或稱正規化、標準化）是設計關聯式資料庫時，用來**減少數據冗餘**和**改善數據完整性**的一系列標準化流程。它透過將大型、複雜的資料表分解成更小、結構更佳的資料表，並在它們之間建立定義良好的關係來達成目標。

正規化的主要目標是：

- **消除數據冗餘**：同樣的數據不應在多個地方重複儲存。
- **避免更新異常**：當數據只儲存一次時，更新操作會變得更簡單、更不容易出錯。
- **避免插入異常**：確保不會因為缺少某些不相關的數據而無法插入一筆新記錄。
- **避免刪除異常**：確保不會因為刪除一筆記錄而意外丟失了其他不相關的數據。

### 正規化的各個級別

正規化通常分為多個級別，最常見的是前三個級別：1NF, 2NF, 3NF。

#### 第一正規化 (1NF - First Normal Form)

- **定義**: 確保資料表中的所有欄位都是**不可分割的原子值**。換句話說，每個欄位都應該只包含一個單一值，而不是一個值的列表或集合。
- **目標**: 消除重複的列組，確保每個欄位都是單值的。

**範例：**

一個**不符合 1NF** 的資料表可能長這樣：

**`訂單表 (Orders)`**

| OrderID | CustomerID | CustomerName | Product |
| :--- | :--- | :--- | :--- |
| 101 | C001 | Alice | `蘋果, 橘子` |
| 102 | C002 | Bob | `牛奶` |

這裡的 `Product` 欄位包含了多個值，違反了 1NF。

**符合 1NF 的設計：**

我們將其分解成兩個資料表：

**`訂單表 (Orders)`**

| OrderID | CustomerID | CustomerName |
| :--- | :--- | :--- |
| 101 | C001 | Alice |
| 102 | C002 | Bob |

**`訂單明細表 (OrderDetails)`**

| OrderDetailID | OrderID | Product |
| :--- | :--- | :--- |
| 1 | 101 | 蘋果 |
| 2 | 101 | 橘子 |
| 3 | 102 | 牛奶 |

#### 第二正規化 (2NF - Second Normal Form)

- **定義**:
  1. 首先必須**滿足 1NF**。
  2. 資料表中的所有非主鍵欄位，都必須**完全依賴於整個主鍵**，而不是只依賴於主鍵的一部分。這個規則只適用於**複合主鍵**（由多個欄位組成的主鍵）的資料表。如果資料表的主鍵是單一欄位，那麼它天生就滿足 2NF。
- **目標**: 消除部分依賴，進一步減少數據冗餘。

**範例：**

假設我們有一個**不符合 2NF** 的資料表，其複合主鍵是 `(OrderID, ProductID)`：

**`訂單明細表 (OrderDetails)`**

| OrderID | ProductID | ProductName | Price | Quantity |
| :--- | :--- | :--- | :--- | :--- |
| 101 | P01 | 蘋果 | 10 | 5 |
| 101 | P02 | 橘子 | 8 | 10 |
| 102 | P01 | 蘋果 | 10 | 20 |

在這個例子中：

- `Quantity` **完全依賴**於 `(OrderID, ProductID)`，因為它描述了「哪個訂單中的哪個產品有多少數量」。
- `ProductName` 和 `Price` **部分依賴**於主鍵，因為它們只依賴於 `ProductID`，而與 `OrderID` 無關。這就造成了數據冗餘（"蘋果" 和 "10" 出現了兩次）。

**符合 2NF 的設計：**

**`訂單明細表 (OrderDetails)`**

| OrderID | ProductID | Quantity |
| :--- | :--- | :--- |
| 101 | P01 | 5 |
| 101 | P02 | 10 |
| 102 | P01 | 20 |

**`產品表 (Products)`**

| ProductID | ProductName | Price |
| :--- | :--- | :--- |
| P01 | 蘋果 | 10 |
| P02 | 橘子 | 8 |

#### 第三正規化 (3NF - Third Normal Form)

- **定義**:
  1. 首先必須**滿足 2NF**。
  2. 資料表中的所有非主鍵欄位，都不能**傳遞依賴**於主鍵。也就是說，一個非主鍵欄位不能依賴於另一個非主鍵欄位。
- **目標**: 消除傳遞依賴。

**範例：**

一個**不符合 3NF** 的資料表：

**`訂單表 (Orders)`**

| OrderID | CustomerID | CustomerName | CustomerCity |
| :--- | :--- | :--- | :--- |
| 101 | C001 | Alice | New York |
| 102 | C002 | Bob | London |
| 103 | C001 | Alice | New York |

在這個例子中：

- `CustomerID` 依賴於主鍵 `OrderID`。
- `CustomerName` 和 `CustomerCity` 依賴於 `CustomerID`。
- 因此，`CustomerName` 和 `CustomerCity` **傳遞依賴**於 `OrderID`。這造成了數據冗餘（"Alice" 和 "New York" 出現了兩次）。

**符合 3NF 的設計：**

**`訂單表 (Orders)`**

| OrderID | CustomerID |
| :--- | :--- |
| 101 | C001 |
| 102 | C002 |
| 103 | C001 |

**`顧客表 (Customers)`**

| CustomerID | CustomerName | City |
| :--- | :--- | :--- |
| C001 | Alice | New York |
| C002 | Bob | London |

### 正規化的優缺點

**優點**:

- **減少數據冗餘**: 這是最主要的優點，可以節省儲存空間。
- **提高數據完整性**: 避免了各種更新、插入和刪除異常。
- **使數據模型更清晰**: 分解後的資料表結構更簡單，職責更單一。
- **改善查詢效能**: 在某些情況下，操作更小的資料表會更快。

**缺點**:

- **增加查詢複雜性**: 原本查詢一張大表就能得到的數據，現在可能需要 `JOIN` 多張表才能完成。
- **降低查詢效能**: 過度的正規化會導致 `JOIN` 操作過多，對於複雜查詢，效能可能會急劇下降。這也是為什麼在實務中，有時會進行**反正規化 (Denormalization)**。

### 結論

正規化是關聯式資料庫設計的理論基石。在實務中，大多數應用程式的資料庫設計會力求達到 **3NF**，因為它在數據完整性和查詢效能之間提供了一個很好的平衡。然而，對於讀取密集型或需要極高效能的特定查詢場景（如資料倉儲、報表系統），開發者常常會策略性地進行**反正規化**，用空間換時間，透過引入可控的數據冗餘來加速查詢。