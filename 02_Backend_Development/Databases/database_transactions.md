# 資料庫交易與 ACID 原則

- **難度**: 6
- **重要性**: 5
- **標籤**: `Databases`, `ACID`, `Transaction`, `Concurrency`

## 問題詳述

什麼是資料庫交易 (Transaction)？請詳細解釋 ACID 四大特性。並說明 SQL 標準中定義的四種交易隔離級別 (Isolation Levels) 及其可能解決的併發問題。

## 核心理論與詳解

### 什麼是資料庫交易？

資料庫交易是一個**不可分割的邏輯工作單元**，它包含了一系列資料庫操作（如讀取、寫入、更新、刪除）。這個工作單元中的所有操作要麼**全部成功執行**，要麼在任何一個操作失敗時**全部回滾**到交易開始前的狀態，就像這些操作從未發生過一樣。

交易的核心目標是**確保數據的完整性和一致性**，尤其是在多個使用者或進程同時訪問和修改資料庫的併發環境中。

### ACID 四大特性

ACID 是衡量一個資料庫系統是否能可靠地處理交易的四個核心標準。

1. **原子性 (Atomicity)**
    - **定義**: 一個交易被視為一個不可分割的最小工作單元。交易中的所有操作要麼全部提交成功，要麼全部失敗回滾。系統不會停留在中間狀態。
    - **比喻**: 銀行轉帳。從帳戶 A 轉 100 元到帳戶 B，這個操作包含兩個步驟：A 減 100，B 加 100。原子性確保這兩個步驟要麼都完成，要麼都不完成。如果 A 減了 100 後系統崩潰，那麼整個交易會回滾，A 的餘額會恢復。

2. **一致性 (Consistency)**
    - **定義**: 交易必須使資料庫從一個一致的狀態轉變到另一個一致的狀態。在交易開始之前和結束以後，資料庫的完整性約束（如外鍵、唯一索引、欄位類型等）沒有被破壞。
    - **比喻**: 續上例，銀行的規則是帳戶餘額不能為負。如果帳戶 A 只有 50 元，卻試圖轉出 100 元，這個交易會違反一致性約束，因此會被拒絕和回滾。一致性是由**應用程式和資料庫共同保證**的。

3. **隔離性 (Isolation)**
    - **定義**: 當多個交易併發執行時，一個交易的執行不應被其他交易干擾。即一個交易內部操作及使用的數據對併發的其他交易是隔離的，併發執行的各個交易之間不能互相干擾。
    - **比喻**: 兩個人同時向同一個帳戶 A（初始餘額 500）轉帳，一個轉 100，一個轉 200。如果沒有隔離性，兩人可能同時讀到餘額 500，然後分別計算出 600 和 700，最後的結果可能是 700，覆蓋了 600，導致數據丟失。隔離性確保交易一個接一個地執行，最終結果是 800。

4. **持久性 (Durability)**
    - **定義**: 一旦交易成功提交，它對資料庫的更改就是永久性的。即使後續發生系統崩潰或斷電，數據也不會丟失。
    - **實現**: 這通常是透過將交易日誌（如 Write-Ahead Log, WAL）寫入非易失性儲存（如硬碟）來實現的。

### 併發交易引發的問題

在缺乏足夠隔離性的情況下，併發交易可能導致以下問題：

1. **髒讀 (Dirty Read)**:
    - **現象**: 交易 A 讀取到了交易 B **尚未提交**的修改。如果交易 B 隨後回滾，那麼交易 A 讀取到的就是無效的「髒」數據。
    - **例子**: 交易 B 將一個值從 10 改為 20。交易 A 讀到了 20。但交易 B 回滾了，值恢復為 10。交易 A 手中的 20 就是髒數據。

2. **不可重複讀 (Non-repeatable Read)**:
    - **現象**: 在同一個交易內，兩次執行相同的查詢，但返回了不同的結果。
    - **例子**: 交易 A 第一次讀取某行數據，值為 10。此時交易 B 修改了該行的值為 20 並提交。交易 A 再次讀取該行，值變成了 20。對於交易 A 來說，一次讀取操作無法重複。

3. **幻讀 (Phantom Read)**:
    - **現象**: 幻讀是不可重複讀的一種特殊情況。它發生在一個交易內，兩次執行**範圍查詢**（如 `WHERE age > 20`），但第二次查詢返回了第一次查詢中不存在的新行（「幻影」行）。
    - **例子**: 交易 A 第一次查詢所有年齡大於 20 的員工，返回 5 條記錄。此時交易 B 插入了一個年齡為 25 的新員工並提交。交易 A 再次執行同樣的查詢，返回了 6 條記錄。

### 四種交易隔離級別

SQL 標準定義了四種隔離級別，用以在**效能**和**數據一致性**之間做出權衡。隔離級別越高，數據一致性越好，但併發效能越差。

| 隔離級別 | 髒讀 | 不可重複讀 | 幻讀 | 實現方式 (以 MySQL InnoDB 為例) |
| :--- | :--- | :--- | :--- | :--- |
| **讀未提交 (Read Uncommitted)** | ✅ 可能 | ✅ 可能 | ✅ 可能 | 基本無鎖 |
| **讀已提交 (Read Committed)** | ❌ 不允許 | ✅ 可能 | ✅ 可能 | MVCC + 讀取時生成快照 |
| **可重複讀 (Repeatable Read)** | ❌ 不允許 | ❌ 不允許 | ✅ 可能 (理論上) | MVCC + 交易開始時生成快照 |
| **可序列化 (Serializable)** | ❌ 不允許 | ❌ 不允許 | ❌ 不允許 | 讀寫都加鎖，強制交易串行執行 |

#### 1. 讀未提交 (Read Uncommitted)

- **描述**: 最低的隔離級別。一個交易可以讀取到其他交易尚未提交的數據。
- **問題**: 存在髒讀、不可重複讀、幻讀。
- **應用**: 效能要求極高，但對數據一致性要求極低的場景。極少使用。

#### 2. 讀已提交 (Read Committed)

- **描述**: 一個交易只能讀取到其他交易**已經提交**的數據。這是大多數資料庫（如 Oracle, PostgreSQL）的預設隔離級別。
- **解決**: 避免了髒讀。
- **問題**: 仍然可能發生不可重複讀和幻讀。

#### 3. 可重複讀 (Repeatable Read)

- **描述**: 確保在同一個交易中，多次讀取同一份數據的結果都是相同的。這是 MySQL InnoDB 引擎的預設隔離級別。
- **解決**: 避免了髒讀和不可重複讀。
- **問題**: 理論上仍然可能發生幻讀。但值得注意的是，MySQL InnoDB 引擎在可重複讀級別下，透過 **Next-Key Locking** 技術，部分地解決了幻讀問題。

#### 4. 可序列化 (Serializable)

- **描述**: 最高的隔離級別。它強制所有交易串行執行，彷彿它們是一個接一個地執行的。
- **解決**: 避免了所有併發問題（髒讀、不可重複讀、幻讀）。
- **問題**: 效能最差，因為併發度最低。
- **應用**: 對數據一致性要求極端嚴格，且可以接受較低併發的場景，如金融系統中的某些核心操作。

### 結論

交易和 ACID 原則是保證資料庫可靠性的基石。而隔離級別則是在多使用者併發訪問的現實世界中，對理想的「完全隔離」所做的妥協。理解不同隔離級別能解決哪些問題，以及它們帶來的效能代價，是資料庫設計和應用開發中的重要一環。選擇哪個級別，取決於具體業務對一致性和效能的權衡。