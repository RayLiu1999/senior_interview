# 請解釋 SQL 的四種交易隔離級別，以及它們分別解決了哪些併發問題

- **難度**: 7
- **重要程度**: 5
- **標籤**: `MySQL`, `SQL`, `Transaction`, `ACID`, `Concurrency`

## 問題詳述

在多使用者併發存取資料庫的環境下，為了保證資料的一致性，SQL 標準定義了四種交易隔離級別 (Transaction Isolation Levels)。請詳細解釋這四種隔離級別的含義，並說明它們分別能解決髒讀 (Dirty Read)、不可重複讀 (Non-Repeatable Read) 和幻讀 (Phantom Read) 中的哪些問題。

## 核心理論與詳解

交易隔離級別是 ACID 特性中「隔離性 (Isolation)」的具體體現。隔離級別越高，資料一致性越好，但併發效能通常也越低。理解它們是設計高併發、高可靠性系統的基礎。

### 三大併發讀取問題

在討論隔離級別之前，必須先理解併發交易可能導致的三種主要問題：

1. **髒讀 (Dirty Read)**:
    - **定義**: 一個交易 (T1) 讀取到了另一個交易 (T2) **尚未提交** 的修改。如果 T2 最終回滾 (Rollback) 了，那麼 T1 讀取到的就是「髒」資料，是不存在的資料。
    - **例子**: T2 將一個值從 10 修改為 20，T1 在此時讀取到了 20。但隨後 T2 回滾，值恢復為 10。T1 手中的資料 20 就成了髒資料。

2. **不可重複讀 (Non-Repeatable Read)**:
    - **定義**: 一個交易 (T1) 在 **同一個交易** 中，對同一筆資料前後兩次讀取，結果卻不一樣。這是因為在 T1 的兩次讀取之間，有另一個交易 (T2) 提交了對該資料的修改。
    - **例子**: T1 第一次讀取某行資料，值為 10。接著 T2 修改該行的值為 20 並提交。T1 再次讀取該行，值變成了 20。對於 T1 來說，一次交易內的讀取結果不一致，即「不可重複讀」。
    - **核心**: 關注的是 **單行資料的修改**。

3. **幻讀 (Phantom Read)**:
    - **定義**: 一個交易 (T1) 在 **同一個交易** 中，前後兩次執行 **相同的範圍查詢**，但第二次查詢返回的結果集包含了第一次查詢中未出現的行。這是因為在 T1 的兩次查詢之間，有另一個交易 (T2) **插入或刪除了** 符合 T1 查詢條件的資料並提交。
    - **例子**: T1 查詢所有年齡大於 20 歲的使用者，得到 5 條記錄。接著 T2 插入了一個 25 歲的新使用者並提交。T1 再次執行相同的查詢，得到了 6 條記錄。這多出來的一行就像「幻影」一樣，即「幻讀」。
    - **核心**: 關注的是 **一個範圍內的資料行數量的變化** (INSERT 或 DELETE)。

---

### 四種交易隔離級別

SQL 標準定義了以下四種隔離級別，從低到高排列：

#### 1. 讀未提交 (Read Uncommitted)

- **定義**: 最低的隔離級別。一個交易可以讀取到其他交易尚未提交的變更。
- **解決的問題**: 無。
- **會出現的問題**: 髒讀、不可重複讀、幻讀。
- **應用場景**: 極少使用。對資料一致性要求極低，但能提供最高併發效能的場景。

#### 2. 讀已提交 (Read Committed)

- **定義**: 一個交易只能讀取到其他交易 **已經提交** 的變更。這是大多數資料庫系統（如 Oracle, SQL Server）的預設隔離級別。
- **運作原理**: 通常通過在讀取時對資料加上讀鎖，讀完即釋放，或者利用 MVCC (多版本併發控制) 實現。
- **解決的問題**: **髒讀**。
- **會出現的問題**: 不可重複讀、幻讀。
- **應用場景**: 大多數常規應用。它避免了髒讀，但允許在一個交易中資料發生變化，提供了較好的併發效能。

#### 3. 可重複讀 (Repeatable Read)

- **定義**: 確保在同一個交易中，多次讀取同一筆資料的結果都是一致的。交易開始時的資料狀態會被「快照」下來。
- **運作原理**:
  - 在標準 SQL 中，通常是通過對讀取過的資料行加上讀鎖，並持有到交易結束。
  - 在 MySQL 的 InnoDB 引擎中，這是 **預設的隔離級別**。它通過 MVCC 機制來實現，當交易開始時，會創建一個一致性視圖 (Read View)，後續的讀取都從這個視圖中獲取資料，從而保證了可重複讀。
- **解決的問題**: **髒讀**、**不可重複讀**。
- **會出現的問題**: **幻讀** (在標準定義下)。
- **特例**: MySQL 的 InnoDB 引擎在「可重複讀」級別下，通過 **Next-Key Locking** (一種結合了行鎖和間隙鎖的機制) 在很大程度上 **解決了幻讀問題**，使其表現得接近於串行化。

#### 4. 串行化 (Serializable)

- **定義**: 最高的隔離級別。強制所有交易串行執行，彷彿它們是一個接一個地順序執行。
- **運作原理**: 通常是通過對交易涉及的所有讀寫資料都加上鎖，或者對整個表加鎖，來徹底避免併發衝突。
- **解決的問題**: **髒讀**、**不可重複讀**、**幻讀**。
- **會出現的問題**: 無。
- **應用場景**: 對資料一致性要求極高，且可以接受較低併發效能的場景。例如，涉及關鍵金融數據的計算或轉帳操作。

### 總結對照表

| 隔離級別 | 髒讀 (Dirty Read) | 不可重複讀 (Non-Repeatable Read) | 幻讀 (Phantom Read) |
| :--- | :---: | :---: | :---: |
| **讀未提交 (Read Uncommitted)** | 可能 | 可能 | 可能 |
| **讀已提交 (Read Committed)** | **不會** | 可能 | 可能 |
| **可重複讀 (Repeatable Read)** | **不會** | **不會** | 可能 (InnoDB 中基本解決) |
| **串行化 (Serializable)** | **不會** | **不會** | **不會** |
