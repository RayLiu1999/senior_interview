# MySQL 鎖機制詳解 (MySQL Locking Mechanism)

- **難度**: 7
- **重要程度**: 5
- **標籤**: `MySQL`, `行鎖`, `表鎖`, `間隙鎖`, `死鎖`, `InnoDB`

## 問題詳述

MySQL 的鎖機制是保證並發安全的核心，也是面試必考的高頻知識點。InnoDB 的行級鎖設計精妙，理解記錄鎖、間隙鎖、Next-Key Lock 的區別，是解釋死鎖、解決鎖等待問題的前提。

## 核心理論與詳解

### 鎖的維度分類

#### 按鎖定範圍（InnoDB）

**表鎖（Table Lock）**：
- 對整張表加鎖，並發度最低
- InnoDB 通常使用行鎖，但 DDL 操作（ALTER TABLE）和全表掃描（無索引的 UPDATE）會升級為表鎖
- MyISAM 只支援表鎖

**行鎖（Row Lock）**：InnoDB 的核心優勢，只鎖定具體記錄，並發度高。行鎖有三種類型：

1. **記錄鎖（Record Lock）**
   - 鎖定索引上的**具體記錄**
   - 場景：`WHERE id = 5`（id 是唯一索引）
   - 精確鎖定，不影響相鄰記錄

2. **間隙鎖（Gap Lock）**
   - 鎖定兩個索引記錄之間的**空白間隙**，防止其他事務在此間隙插入記錄
   - 場景：`WHERE id BETWEEN 5 AND 10`（假設 6、7、8、9 不存在）→ 鎖定 (5, 10) 開區間的間隙
   - **只在可重複讀（RR）隔離級別下存在**，用於防止幻讀
   - 間隙鎖之間不互斥（多個事務可以同時持有同一個間隙的間隙鎖），但插入會等待

3. **Next-Key Lock（臨鍵鎖）**
   - = 記錄鎖 + 記錄前面的間隙鎖
   - 鎖定「某個記錄」以及「記錄之前的間隙」，是**左開右閉**的區間：`(-∞, 記錄]`
   - InnoDB 在 RR 隔離級別下，**默認使用 Next-Key Lock**
   - 場景：`WHERE age = 25`（age 為非唯一索引，id 分別為 3、7、15）→ 鎖定 (20, 25]（25 是記錄值）和 (25, +∞) 的間隙

#### 按鎖的兼容性（意向鎖）

**意向鎖（Intention Lock）**：InnoDB 自動維護的**表級鎖**，用於快速判斷表中是否有行鎖，無需遍歷所有行：

- **意向共享鎖（IS）**：即將對表中的某行加共享鎖（S Lock）
- **意向排他鎖（IX）**：即將對表中的某行加排他鎖（X Lock）

意向鎖之間互相兼容，它們主要與 **全表的 S/X 鎖**互斥（如表級寫鎖 DDL）。

---

### 共享鎖（S）與排他鎖（X）

| | 共享鎖（S Lock）| 排他鎖（X Lock）|
|---|---|---|
| **兼容共享鎖** | ✅ 兼容（多讀） | ❌ 衝突 |
| **兼容排他鎖** | ❌ 衝突 | ❌ 衝突 |
| **加鎖方式** | `SELECT ... LOCK IN SHARE MODE` | `SELECT ... FOR UPDATE` 或 DML（UPDATE/DELETE/INSERT） |

---

### 鎖的加鎖規則（重點）

InnoDB 的加鎖遵循以下原則（RR 隔離級別）：

1. **查詢使用覆蓋索引時，不回表則不加記錄鎖**（優化器優化）
2. **唯一索引等值匹配（記錄存在）**：降級為記錄鎖（不加間隙鎖）
3. **唯一索引等值匹配（記錄不存在）**：使用間隙鎖鎖定缺失值的間隙
4. **非唯一索引等值匹配**：Next-Key Lock + 向後一個間隙的間隙鎖
5. **範圍查詢**：Next-Key Lock 鎖定掃描到的所有記錄和間隙

---

### 死鎖（Deadlock）

**死鎖產生條件**：兩個或多個事務相互等待對方釋放鎖。

**典型場景**：
```
事務 A: 鎖定 id=1，等待 id=2
事務 B: 鎖定 id=2，等待 id=1  → 死鎖！
```

**InnoDB 的死鎖自動檢測**：
- InnoDB 後台執行 Wait-For Graph 分析，檢測到死鎖後立即**回滾代價最小的事務**（undo log 量最小）
- 被回滾事務收到 `ERROR 1213 (40001): Deadlock found`

**預防死鎖的設計原則**：
- **固定加鎖順序**：所有事務按相同的順序操作多個資源
- **縮短事務範圍**：減小事務持鎖的時間窗口
- **批量操作代替逐行**：減少鎖的次數
- **降低隔離級別**：RC 隔離級別無間隙鎖，減少死鎖概率（但允許幻讀）
- **監控慢 SQL**：長事務是死鎖的主因

---

### 鎖等待問題排查

```sql
-- 查看當前鎖等待情況
SELECT * FROM information_schema.INNODB_LOCK_WAITS;

-- 查看事務和持有的鎖
SELECT * FROM information_schema.INNODB_TRX;
SELECT * FROM information_schema.INNODB_LOCKS;
```

`innodb_lock_wait_timeout`（默認 50 秒）：鎖等待超時時間，超時後事務回滾並報錯。
