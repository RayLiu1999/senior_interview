# 什麼是資料庫索引？它的優缺點是什麼？有哪些常見的索引類型？

- **難度**: 6
- **標籤**: `MySQL`, `Database`, `Index`, `Performance`

## 問題詳述

資料庫索引是提升查詢效能的關鍵工具。請詳細解釋索引的底層原理、它所帶來的優點和缺點，並介紹幾種在 MySQL (特別是 InnoDB) 中常見的索引類型及其適用場景。

## 核心理論與詳解

我們可以將資料庫索引類比為一本書的「目錄」。如果沒有目錄，當你想找一個特定的主題時，你必須從頭到尾翻閱整本書。而有了目錄，你可以快速定位到主題所在的頁碼，大大縮短查找時間。在資料庫中，索引扮演著同樣的角色，它讓資料庫伺服器無需掃描整張表就能快速找到所需的資料。

### 索引的底層資料結構

雖然索引有多種實現方式 (如 Hash 索引、R-tree 索引等)，但在 MySQL 的 InnoDB 和 MyISAM 儲存引擎中，最核心、最普遍的索引結構是 **B+ Tree**。

- **B+ Tree 的特點**:
  1. **平衡樹**: 它是一種多路平衡搜索樹，無論資料量多大，從根節點到任意葉子節點的路徑長度都是相同或相近的，這保證了查詢效能的穩定性。
  2. **分層儲存**: 非葉子節點只儲存「索引鍵值」和指向下一層節點的「指標」，不儲存完整的資料行資訊。這使得每個非葉子節點可以容納更多的索引鍵，從而降低樹的高度。
  3. **葉子節點儲存所有資料**: 所有的資料記錄 (或指向資料的指標) 都儲存在葉子節點上。
  4. **葉子節點串聯**: 葉子節點之間通過雙向指標串聯在一起，形成一個有序鏈表。這個特性使得 **範圍查詢 (Range Query)** 的效能非常高，因為資料庫找到範圍的起始點後，只需沿著鏈表遍歷即可。

### 索引的優點

1. **極大提升查詢速度**: 這是索引最主要的好處。通過 B+ Tree 結構，可以將全表掃描 (Full Table Scan) 的 `O(N)` 時間複雜度，降低到接近 `O(log N)` 的時間複雜度。
2. **加速排序**: 如果查詢中的 `ORDER BY` 子句所使用的欄位正好是索引欄位，那麼資料庫可以直接利用索引的有序性，避免額外的排序操作。
3. **加速分組**: 類似於排序，`GROUP BY` 子句如果使用索引欄位，也可以利用索引的有序性來加速分組操作。
4. **保證資料唯一性**: 主鍵和唯一鍵本質上也是一種索引，它們可以在資料庫層面強制保證欄位值的唯一性。

### 索引的缺點

1. **佔用磁碟空間**: 索引本身也是一個資料結構，需要儲存在磁碟上。資料量越大，索引佔用的空間也越多。
2. **降低寫操作效能**: 當對表進行 `INSERT`, `UPDATE`, `DELETE` 操作時，不僅需要修改資料本身，還需要動態地維護索引樹的結構（例如節點的分裂、合併等），這會帶來額外的效能開銷。索引越多，寫操作的成本就越高。
3. **索引需要精心設計**: 設計不良的索引（例如在區分度低的欄位上建立索引）可能不會帶來效能提升，甚至會因為查詢最佳化器誤用而導致效能下降。

---

### MySQL 中常見的索引類型

#### 1. 叢集索引 (Clustered Index) vs. 非叢集索引 (Non-Clustered Index)

這不是一種獨立的索引類型，而是 InnoDB 和 MyISAM 在物理儲存資料時的根本區別。

- **叢集索引 (InnoDB)**:
  - 資料行本身就是按照主鍵的順序儲存在 B+ Tree 的葉子節點上。
  - 一個表只能有一個叢集索引（因為資料只有一種物理排序方式）。
  - **優點**: 基於主鍵的查詢和範圍查詢速度極快。
  - **缺點**: 插入新資料可能導致頁分裂，維護成本較高；二級索引查詢需要「回表」。

- **非叢集索引 (MyISAM)**:
  - 索引的葉子節點儲存的是指向資料行物理位置的「指標」。索引和資料是分離的。
  - 主鍵索引和二級索引在結構上沒有區別。

#### 2. 二級索引 (Secondary Index)

在叢集索引之外建立的所有索引都稱為二級索引。在 InnoDB 中，二級索引的葉子節點儲存的是該行的 **主鍵值**。當通過二級索引查找資料時，會先找到對應的主鍵，然後再用主鍵去叢集索引中找到完整的資料行，這個過程稱為 **回表**。

#### 3. 覆蓋索引 (Covering Index)

這是一種查詢優化的概念，而不是一種索引類型。如果一個查詢所需的所有欄位（包括 `SELECT`, `WHERE`, `ORDER BY` 等子句中涉及的欄位）都恰好包含在某個二級索引中，那麼資料庫引擎就 **無需回表**，可以直接從該索引中獲取所有需要的資料並返回。這極大地減少了 I/O 操作，提升了查詢效能。

- **示例**: 假設有 `users` 表 (id, name, age)，並在 `(name, age)` 上建立了複合索引。

  ```sql
  -- 這個查詢就是一個覆蓋索引查詢
  SELECT name, age FROM users WHERE name = 'Alice';
  ```

#### 4. 複合索引 (Composite Index / Compound Index)

在多個欄位上組合建立的索引。複合索引在查詢時遵循 **最左前綴原則 (Leftmost Prefix Principle)**。

- **最左前綴原則**: 假設在 `(col1, col2, col3)` 上建立了複合索引，那麼這個索引可以被以下查詢有效地利用：
  - `WHERE col1 = ?`
  - `WHERE col1 = ? AND col2 = ?`
  - `WHERE col1 = ? AND col2 = ? AND col3 = ?`
- 但是，無法直接利用這個索引來加速以下查詢：
  - `WHERE col2 = ?`
  - `WHERE col3 = ?`
  - `WHERE col2 = ? AND col3 = ?`

#### 5. 前綴索引 (Prefix Index)

當索引欄位是字串類型 (如 `VARCHAR`, `TEXT`) 時，可以只取字串的前 N 個字元來建立索引。這可以大大減小索引的大小，提高效率。

- **語法**: `CREATE INDEX idx_name ON table_name (column_name(N));`
- **缺點**: 使用前綴索引後，無法再利用該索引進行排序 (`ORDER BY`) 和分組 (`GROUP BY`) 操作，也無法實現覆蓋索引。

#### 6. 全文索引 (Full-Text Index)

主要用於在大量文字內容中進行關鍵字搜索，類似於搜尋引擎的功能。它使用不同於 B+ Tree 的演算法（如倒排索引）來分析文字。適用於 `CHAR`, `VARCHAR`, `TEXT` 類型。

- **使用場景**: 文章內容搜索、商品描述搜索等。
