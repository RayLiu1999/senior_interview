# InnoDB 和 MyISAM 儲存引擎有什麼核心區別？

- **難度**: 5
- **重要程度**: 4
- **標籤**: `MySQL`, `Storage Engine`, `InnoDB`, `MyISAM`, `ACID`

## 問題詳述

InnoDB 和 MyISAM 是 MySQL 中最廣為人知的兩種儲存引擎。請詳細比較它們在交易支援、鎖定機制、資料完整性、效能和使用場景等方面的核心區別。

## 核心理論與詳解

選擇合適的儲存引擎對於資料庫的效能、可靠性和功能至關重要。InnoDB 自 MySQL 5.5 版本起成為預設儲存引擎，並在絕大多數場景下取代了 MyISAM。理解它們的區別有助於進行系統設計和效能調優。

### 核心區別對照表

| 特性 | InnoDB | MyISAM |
| :--- | :--- | :--- |
| **交易支援** | **支援 (ACID)** | **不支援** |
| **鎖定機制** | **行級鎖 (Row-Level Locking)** | **表級鎖 (Table-Level Locking)** |
| **外鍵約束** | **支援 (Foreign Keys)** | **不支援** |
| **崩潰恢復** | **非常可靠** (通過交易日誌) | **較差** (可能導致資料損壞) |
| **叢集索引** | **有** (資料本身按主鍵儲存) | **沒有** (資料與索引分開儲存) |
| **全文索引** | MySQL 5.6+ 支援 | 支援 |
| **儲存方式** | 表結構在 `.frm`，資料和索引在 `.ibd` | 表結構在 `.frm`，資料在 `.MYD`，索引在 `.MYI` |
| **快取機制** | 同時快取資料和索引 (Buffer Pool) | 只快取索引 (Key Buffer) |
| **`COUNT(*)`** | 需掃描全表 (因 MVCC) | 速度極快 (直接儲存了行數) |

---

### 1. 交易與 ACID 支援

- **InnoDB**:
  - **完全支援 ACID 交易** (原子性 Atomicity, 一致性 Consistency, 隔離性 Isolation, 持久性 Durability)。
  - 這意味著 InnoDB 非常適合需要高可靠性和資料一致性的應用，例如金融、電商、訂單系統等。
  - 提供了 `COMMIT`、`ROLLBACK` 和 `SAVEPOINT` 等完整的交易控制能力。

- **MyISAM**:
  - **完全不支援交易**。所有 DML 操作 (INSERT, UPDATE, DELETE) 都是「自動提交」的，無法回滾。
  - 這使得 MyISAM 在處理需要多步驟原子操作的業務時存在風險。

### 2. 鎖定機制

- **InnoDB**:
  - **支援行級鎖**，同時也支援表級鎖。
  - 當一個交易在修改某一行時，只會鎖定該行（或相關的間隙），而不會鎖定整個表。
  - 這使得 InnoDB 在高併發讀寫的場景下表現出色，因為不同交易所操作的行如果不同，它們之間就不會產生鎖衝突，大大提高了併發處理能力。

- **MyISAM**:
  - **只支援表級鎖**。
  - 任何對表進行的寫操作（`INSERT`, `UPDATE`, `DELETE`）都會鎖定整個表，這會阻塞其他所有對該表的讀寫操作。
  - 讀操作會加上讀鎖，阻塞寫操作，但不阻塞其他讀操作。
  - 因此，MyISAM 在寫操作頻繁的場景下併發效能非常差。

### 3. 資料完整性與崩潰恢復

- **InnoDB**:
  - **支援外鍵約束 (Foreign Key Constraints)**，有助於在資料庫層面維護資料的引用完整性。
  - 擁有完善的交易日誌 (Redo Log 和 Undo Log)，即使資料庫發生崩潰，也可以通過日誌來恢復資料，確保已提交的交易不會遺失，未完成的交易會被回滾，資料損壞的風險極低。

- **MyISAM**:
  - **不支援外鍵約束**。資料的引用完整性需要由應用程式層來保證。
  - 沒有交易日誌，崩潰恢復能力較差。如果伺服器在寫操作過程中宕機，很容易導致表損壞，需要手動執行 `REPAIR TABLE` 來修復，且不保證能完全恢復資料。

### 4. 索引與儲存結構

- **InnoDB**:
  - **使用叢集索引 (Clustered Index)**。表的資料行是根據主鍵順序進行物理儲存的。
  - 這種結構使得基於主鍵的查詢非常快。但二級索引 (Secondary Index) 必須先查找到主鍵值，再通過主鍵回表查詢資料，可能增加 I/O 操作。
  - 資料和索引通常儲存在同一個 `.ibd` 檔案中。

- **MyISAM**:
  - **使用非叢集索引 (Non-Clustered Index)**。索引和資料是分開儲存的。
  - 索引檔案 (`.MYI`) 的葉子節點儲存的是指向資料檔案 (`.MYD`) 中對應行的物理地址。主鍵索引和二級索引在結構上沒有區別。
  - 檔案是分離的：`.frm` (表結構), `.MYD` (資料), `.MYI` (索引)。

### 5. `COUNT(*)` 的效能

- **InnoDB**:
  - 執行 `SELECT COUNT(*) FROM table` 時，需要掃描全表或全索引來計算行數。
  - 這是因為 InnoDB 支援 MVCC (多版本併發控制)，在不同的交易隔離級別下，一個交易所能看到的行數是不同的，所以不能簡單地儲存一個固定的行數。

- **MyISAM**:
  - 執行 `SELECT COUNT(*) FROM table` 時，速度極快。
  - MyISAM 將整個表的總行數直接儲存在磁碟上，查詢時直接返回這個計數即可，無需掃描。

### 使用場景總結

- **選擇 InnoDB**:
  - **絕大多數場景** 的首選。
  - 需要交易支援，保證資料的絕對一致性和可靠性。
  - 應用場景有高併發的寫入和更新操作。
  - 需要使用外鍵來維護資料的引用完整性。

- **選擇 MyISAM (已非常罕見)**:
  - 應用以 **讀取和插入** 為主，很少有更新和刪除操作。
  - 對交易和資料完整性要求不高。
  - 可以容忍崩潰後資料可能損壞的風險。
  - 需要非常快速地執行 `COUNT(*)` 查詢。
  - 例如：日誌記錄系統、資料倉儲的某些事實表等。

在現代的應用開發中，除非有非常特殊的理由，否則 **始終推薦使用 InnoDB**。
