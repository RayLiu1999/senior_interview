# 解釋 SQL 標準中的四種交易隔離等級，並說明 PostgreSQL 如何實現它們

- **難度**: 7
- **重要程度**: 5
- **標籤**: `PostgreSQL`, `Transaction`, `Isolation`, `ACID`

## 問題詳述

交易隔離性是 ACID 特性中的「I」，它定義了一個交易中的修改在何種程度上對其他併發交易是可見的。SQL 標準定義了四種隔離等級。請詳細解釋這四種隔離等級，它們分別解決了哪些併發問題，並說明 PostgreSQL 是如何實現這些等級的。

## 核心理論與詳解

為了理解隔離等級，首先需要了解在缺乏隔離性的情況下可能出現的三種主要併發問題：

1. **髒讀 (Dirty Read)**:
    - **問題**: 交易 A 讀取了交易 B **已修改但尚未提交** 的資料。如果交易 B 最終回滾 (Rollback)，那麼交易 A 讀取的資料就是「髒」的、無效的。
    - **危害**: 導致應用程式基於從未正式存在的資料做出決策。

2. **不可重複讀 (Non-Repeatable Read)**:
    - **問題**: 在同一個交易 A 中，兩次執行相同的查詢，但得到了不同的結果。這是因為在這兩次查詢之間，交易 B 修改了這些資料並 **已提交**。
    - **危害**: 破壞了交易內部資料的一致性視圖。交易執行期間，它所依賴的資料發生了變化。

3. **幻讀 (Phantom Read)**:
    - **問題**: 在同一個交易 A 中，第一次查詢返回了一組符合條件的資料行，但第二次執行相同的查詢時，返回了額外的、之前不存在的「幻影」行。這是因為在這兩次查詢之間，交易 B **插入** 了新的、符合查詢條件的資料並 **已提交**。
    - **危害**: 類似於不可重複讀，但它涉及的是資料行的「集合」發生了變化，而不是單個資料行的值發生變化。

### SQL 標準的四種隔離等級

SQL 標準定義了四種隔離等級，從低到高，提供的保護越來越強，但通常也伴隨著效能的下降。

#### 1. 讀未提交 (Read Uncommitted)

- **定義**: 最低的隔離等級。一個交易可以看到其他交易尚未提交的修改。
- **解決的問題**: 無。
- **允許的問題**: 髒讀、不可重複讀、幻讀。
- **PostgreSQL 實現**: **PostgreSQL 不支援此隔離等級**。在 PostgreSQL 中，讀取操作永遠不會看到未提交的資料。因此，PostgreSQL 的最低隔離等級實際上是「讀已提交」。

#### 2. 讀已提交 (Read Committed)

- **定義**: 一個交易只能看到其他交易 **已經提交** 的修改。這是大多數資料庫（包括 PostgreSQL）的預設隔離等級。
- **解決的問題**: 髒讀。
- **允許的問題**: 不可重複讀、幻讀。
- **PostgreSQL 實現**:
  - 在 `Read Committed` 等級下，**每一個 SQL 敘述都會獲取一個新的交易快照**。
  - 這意味著在同一個交易內，如果 `SELECT` 敘述執行了兩次，而中間有另一個交易提交了 `UPDATE`，那麼第二次的 `SELECT` 將會看到更新後的資料，從而導致「不可重複讀」。
  - 同樣，如果另一個交易提交了 `INSERT`，第二次的 `SELECT` 也可能看到新的「幻影」行。

#### 3. 可重複讀 (Repeatable Read)

- **定義**: 保證在同一個交易中，多次讀取同樣的資料行會返回相同的結果。
- **解決的問題**: 髒讀、不可重複讀。
- **允許的問題**: 幻讀。
- **PostgreSQL 實現**:
  - 在 `Repeatable Read` 等級下，**只有交易的第一個 SQL 敘述會獲取一個交易快照**，並且整個交易期間都將使用這同一個快照。
  - 這確保了在交易內部，無論其他交易提交了什麼 `UPDATE` 或 `DELETE`，當前交易看到的資料行版本都是一致的，從而避免了「不可重複讀」。
  - **然而，對於幻讀**：如果交易 A 正在使用一個快照，而交易 B 在此期間插入了新行並提交，交易 A 看不到這個新行。但如果交易 A 接下來嘗試 `INSERT` 或 `UPDATE` 一個會與交易 B 插入的新行產生衝突的資料，PostgreSQL 會檢測到這種「序列化異常 (Serialization Anomaly)」並使交易 A 失敗回滾。因此，雖然標準定義允許幻讀，但 PostgreSQL 的實現實際上可以防止幻讀，只是方式是通過錯誤回滾。

#### 4. 可序列化 (Serializable)

- **定義**: 最高的隔離等級。併發執行的交易其結果等同於將它們一個接一個地順序執行。
- **解決的問題**: 髒讀、不可重複讀、幻讀。
- **允許的問題**: 無。
- **PostgreSQL 實現**:
  - PostgreSQL 使用一種稱為 **可序列化快照隔離 (Serializable Snapshot Isolation, SSI)** 的先進技術來實現。
  - 與 `Repeatable Read` 類似，它也為整個交易使用單一的快照。
  - 但它更進一步，會主動監控交易之間的讀寫依賴關係。如果偵測到兩個併發交易的執行結果無法被序列化（即它們的執行順序會影響最終結果，形成了一個依賴環），PostgreSQL 會選擇性地讓其中一個交易失敗並回滾，並提示「could not serialize access due to read/write dependencies」。
  - 這種方法比傳統的鎖定機制提供了更高的併發性，因為它是一種樂觀併發控制，只在真正出現衝突時才中止交易。

### 在 PostgreSQL 中設置隔離等級

你可以使用以下 SQL 命令為當前交易設置隔離等級：

```sql
-- 設置為可重複讀
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 設置為可序列化
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 恢復為預設的讀已提交
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 總結

| 隔離等級 | 髒讀 | 不可重複讀 | 幻讀 | PostgreSQL 實現方式 |
| :--- | :--- | :--- | :--- | :--- |
| **Read Uncommitted** | 允許 | 允許 | 允許 | **不支援** |
| **Read Committed (預設)** | 不允許 | 允許 | 允許 | 每個 **敘述** 獲取新快照 |
| **Repeatable Read** | 不允許 | 不允許 | 允許 (但 PG 會中止交易) | 整個 **交易** 使用單一快照 |
| **Serializable** | 不允許 | 不允許 | 不允許 | 可序列化快照隔離 (SSI)，監控讀寫依賴 |

在選擇隔離等級時，需要在資料一致性的要求和系統效能之間做出權衡。對於大多數應用場景，PostgreSQL 預設的 `Read Committed` 等級已經足夠。只有在需要更強一致性保證的關鍵業務邏輯中，才需要考慮使用 `Repeatable Read` 或 `Serializable`。
