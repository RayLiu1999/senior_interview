# `VACUUM`, `VACUUM FULL`, 和 `ANALYZE` 有何不同？請解釋它們各自的使用時機

- **難度**: 8
- **標籤**: `PostgreSQL`, `VACUUM`, `Performance`, `DBA`

## 問題詳述

`VACUUM` 是 PostgreSQL 維護資料庫健康的核心指令，但它有多種變體，如 `VACUUM FULL`，並且經常與 `ANALYZE` 指令一起出現。請詳細解釋 `VACUUM`、`VACUUM FULL` 和 `ANALYZE` 這三個指令的根本區別、它們對資料庫的影響（特別是鎖定行為），以及各自應該在何種情況下使用。

## 核心理論與詳解

這三個指令雖然都與資料庫的維護和效能有關，但它們的目標和運作方式有著本質的不同。

### 1. `VACUUM`

`VACUUM` 的核心職責是回收由 `UPDATE` 和 `DELETE` 操作產生的死元組 (Dead Tuples) 所佔據的空間，以便這些空間可以被重用。

- **工作原理**:
  - 掃描資料表，找到對所有現行交易都不可見的死元組。
  - 將這些死元組所佔據的空間標記為可用，並將其記錄在空閒空間映射 (Free Space Map, FSM) 中。
  - 這些被回收的空間 **只能被同一個資料表** 用於後續的 `INSERT` 或 `UPDATE` 操作。
  - **它不會將磁碟空間返還給作業系統**，因此資料表檔案的大小（在作業系統層面看到的檔案大小）通常不會減小。

- **鎖定行為**:
  - `VACUUM` 執行時，它會在目標資料表上施加一個 **非排他性的鎖**。
  - 這意味著在 `VACUUM` 運行期間，**不會阻塞** 對該表的正常讀取 (`SELECT`) 和寫入 (`INSERT`, `UPDATE`, `DELETE`) 操作。
  - 這是 `VACUUM` 的最大優點，使其可以作為日常維護的一部分，由 `autovacuum` 程序在背景頻繁地、安全地執行，而不會對線上業務造成顯著影響。

- **使用時機**:
  - **日常維護**: 這是最常規的操作。通常由 `autovacuum` 自動管理。
  - **手動觸發**: 當你知道一個大表剛剛經歷了大量的 `UPDATE` 或 `DELETE` 操作後，可以手動執行 `VACUUM` 來及時回收空間，防止表過度膨脹。

### 2. `VACUUM FULL`

`VACUUM FULL` 是一個更具侵入性的操作，它的目標是將資料表檔案壓縮到最小，並將未使用的空間返還給作業系統。

- **工作原理**:
  - `VACUUM FULL` 會創建一個全新的資料表檔案。
  - 它將舊檔案中所有仍然存活的資料行（即非死元組）複製到這個新檔案中。
  - 複製完成後，它會刪除舊的資料表檔案。
  - 這個過程會徹底地移除所有死元組和碎片，使得新的資料表檔案只包含有效的資料，並且排列緊湊。

- **鎖定行為**:
  - `VACUUM FULL` 會在目標資料表上施加一個 **排他性的 `ACCESS EXCLUSIVE` 鎖**。
  - 這個鎖會 **阻塞所有** 針對該表的讀寫操作，包括 `SELECT`。
  - 直到 `VACUUM FULL` 完成之前，該表對應用程式來說是完全不可用的。對於大表，這個過程可能會持續很長時間（數小時甚至更久）。

- **使用時機**:
  - **極少使用**: 由於其嚴重的鎖定行為，`VACUUM FULL` 不應該作為常規維護的一部分。
  - **特殊情況**:
    - 當一個表的大部分資料（例如 80% 以上）被刪除後，你希望立即將大量的磁碟空間返還給作業系統。
    - 當一個表因為嚴重的碎片化導致效能問題，並且你可以在業務低峰期（或停機維護期間）鎖定該表時。
  - **替代方案**: 在許多情況下，使用如 `pg_repack` 之類的第三方工具可以在不阻塞寫操作的情況下實現類似 `VACUUM FULL` 的效果，是更優的選擇。

### 3. `ANALYZE`

`ANALYZE` 的職責與空間回收無關，它的目標是 **收集和更新資料庫的統計資訊**。

- **工作原理**:
  - `ANALYZE` 會對資料表進行採樣，收集關於資料分佈的統計數據。
  - 這些數據包括：行數、欄位的非空值數量、最常見的值 (MCV)、直方圖（描述資料分佈）、相異值數量等。
  - 它將這些統計資訊存儲在系統目錄中（如 `pg_statistic`）。
  - PostgreSQL 的查詢最佳化器 (Query Planner) 會依賴這些統計資訊來估算不同查詢路徑的成本，並選擇最高效的執行計畫。

- **鎖定行為**:
  - `ANALYZE` 執行時，它只會在目標資料表上施加一個 **非排他性的讀鎖**。
  - 它 **不會阻塞** 任何讀寫操作。

- **使用時機**:
  - **與 `VACUUM` 一起**: `autovacuum` 程序通常會自動執行 `VACUUM ANALYZE`。手動執行時，也推薦使用 `VACUUM ANALYZE`，這樣可以在回收空間的同時更新統計資訊。
  - **查詢計畫不佳時**: 如果你發現某個查詢的效能突然變差，或者 `EXPLAIN` 的結果顯示最佳化器對行數的估算嚴重不準，這通常意味著統計資訊已經過時。此時應立即對相關資料表執行 `ANALYZE`。
  - **大量資料變更後**: 在對一個表進行了大量的 `INSERT`, `UPDATE`, `DELETE` 操作後，即使還沒有很多死元組需要回收，也應該執行 `ANALYZE` 來更新統計資訊，以確保查詢最佳化器能夠做出正確的決策。

### 總結比較

| 特性 | `VACUUM` | `VACUUM FULL` | `ANALYZE` |
| :--- | :--- | :--- | :--- |
| **主要目標** | 回收死元組空間以供 **重用** | 徹底重寫表，將空間 **返還給 OS** | **更新** 查詢最佳化器所需的統計資訊 |
| **鎖定行為** | **不阻塞** 讀寫 (非排他鎖) | **阻塞所有** 讀寫 (排他鎖) | **不阻塞** 讀寫 (非排他讀鎖) |
| **I/O 影響** | 中等 (掃描表和索引) | 非常高 (創建新表，複製所有資料) | 較低 (只採樣部分資料) |
| **對表大小的影響** | 不減小檔案大小 | 減小檔案大小到最小值 | 無影響 |
| **常規性** | **常規操作** (由 autovacuum 管理) | **緊急/特殊操作** (應避免) | **常規操作** (由 autovacuum 管理) |
| **推薦用法** | `VACUUM table;` 或 `VACUUM ANALYZE table;` | 停機維護時使用，或用 `pg_repack` 替代 | `ANALYZE table;` 或 `VACUUM ANALYZE table;` |

**核心要點**: 將 `VACUUM` 和 `ANALYZE` 視為保持資料庫日常高效運轉的「健康檢查」和「營養補充」，它們是低影響且必要的。而 `VACUUM FULL` 則是一場「大手術」，雖然效果徹底，但會帶來服務中斷的巨大代價，必須謹慎使用。
