# 什麼是快取穿透、快取擊穿和快取雪崩？該如何應對？

- **難度**: 7
- **重要程度**: 5
- **標籤**: `Redis`, `Caching`, `System Design`, `High Availability`

## 問題詳述

在使用 Redis 作為快取時，經常會遇到三個經典的高可用性問題：快取穿透 (Cache Penetration)、快取擊穿 (Cache Breakdown) 和快取雪崩 (Cache Avalanche)。請分別解釋這三個問題的成因，並闡述業界常用的解決方案。

## 核心理論與詳解

這三個問題都描述了在特定場景下，快取系統無法有效阻擋請求，導致大量請求直接衝擊後端資料庫，可能引發資料庫過載甚至崩潰的情況。理解它們的區別與對策是設計高可用快取架構的關鍵。

### 1. 快取穿透 (Cache Penetration)

#### 成因

快取穿透指的是 **查詢一個絕對不存在的資料**。由於快取中沒有這個資料 (快取未命中)，請求會被轉發到後端資料庫。資料庫中也查不到該資料，因此不會將任何結果寫回快取。

如果攻擊者利用這個漏洞，持續用大量不存在的 key 發起請求，那麼這些請求每次都會穿透快取，直接打到資料庫上，導致資料庫壓力劇增。

**核心特徵**: 查詢的資料在 **快取和資料庫中都不存在**。

#### 解決方案

1.  **快取空值 (Cache Null Values)**:
    *   **原理**: 當後端資料庫確認某個 key 不存在時，仍然在快取中為這個 key 儲存一個特殊的「空值」(例如，一個固定的字串 "NULL")，並設定一個較短的過期時間 (例如，幾分鐘)。
    *   **優點**: 實現簡單，能有效阻擋後續對同一個不存在 key 的查詢。
    *   **缺點**:
        *   會消耗一定的快取記憶體來儲存這些空值。
        *   如果攻擊者使用大量不同的不存在的 key，此方案效果會打折扣。
        *   存在短暫的資料不一致問題：如果在快取空值的期間，資料庫中恰好新增了這個 key 的資料，快取層在過期前仍然會返回空值。

2.  **布隆過濾器 (Bloom Filter)**:
    *   **原理**: 在快取層之前，部署一個布隆過濾器。布隆過濾器是一種空間效率極高機率型資料結構，用於判斷一個元素是否在一個集合中。
    *   **流程**:
        1.  將所有可能存在的資料 key 預先載入到布隆過濾器中。
        2.  當一個查詢請求到來時，先去布隆過濾器中查詢 key 是否存在。
        3.  如果布隆過濾器判斷 key **不存在**，則直接拒絕請求，根本不會查詢快取和資料庫。
        4.  如果布隆過濾器判斷 key **可能存在**，則繼續執行後續的快取查詢流程。
    *   **優點**: 空間效率和查詢效率都非常高，能在大資料量下有效過濾掉絕大多數不存在的 key。
    *   **缺點**:
        *   存在一定的誤判率 (False Positive)：布隆過濾器可能將一個不存在的 key 誤判為存在。但它絕不會將存在的 key 誤判為不存在 (No False Negative)。
        *   實現相對複雜，需要預先載入資料，且不方便處理 key 的刪除。

### 2. 快取擊穿 (Cache Breakdown)

#### 成因

快取擊穿指的是 **某一個熱點 Key (Hot Key) 突然失效**。這個 key 平時承載著極高的並發訪問量。當它過期的那一瞬間，所有針對這個 key 的請求都會同時穿過快取，直接打到後端資料庫上，如同在堤壩上鑿開一個洞，造成瞬間的巨大壓力。

**核心特徵**: 單一 **熱點資料** 過期，導致大量並發請求同時訪問資料庫。

#### 解決方案

1.  **互斥鎖 (Mutex Lock)**:
    *   **原理**: 在快取未命中後，不是所有執行緒都去查詢資料庫，而是只有第一個執行緒去查詢。該執行緒在查詢前會先獲取一個互斥鎖 (例如，使用 Redis 的 `SETNX` 指令)。
    *   **流程**:
        1.  快取未命中。
        2.  嘗試獲取鎖。
        3.  如果獲取鎖成功，則從資料庫加載資料，寫入快取，然後釋放鎖。
        4.  如果獲取鎖失敗，表示已有其他執行緒在處理，當前執行緒可以短暫休眠後重試 (此時可能快取已有資料)，或者直接返回一個臨時的空值。
    *   **優點**: 強一致性，能嚴格保證只有一個請求去重建快取，有效保護資料庫。
    *   **缺點**: 實現複雜，引入了鎖增加了系統的複雜性，且可能因為鎖等待而降低吞吐量。

2.  **熱點資料永不過期 (或邏輯過期)**:
    *   **原理**: 對於極度熱點的資料，不設定物理上的過期時間 (例如，`EXPIRE` 指令)。而是在 value 中儲存一個邏輯上的過期時間戳。
    *   **流程**:
        1.  當查詢到資料時，判斷其邏輯時間戳是否已過期。
        2.  如果未過期，直接返回資料。
        3.  如果已過期，則啟動一個背景執行緒去異步地更新快取中的資料，同時將當前的舊資料返回給客戶端。
    *   **優點**: 避免了擊穿的發生，且因為是異步更新，使用者請求的延遲很低。
    *   **缺點**: 需要額外的邏輯來管理和更新快取，存在資料不一致的窗口期。

### 3. 快取雪崩 (Cache Avalanche)

#### 成因

快取雪崩描述了兩種可能導致大規模快取失效的場景：

1.  **大量 Key 在同一時間集體失效**: 例如，在系統啟動時，所有快取的過期時間都被設定為相同的時長，導致在未來的某個時刻，這些快取集體失效，所有請求瞬間湧向資料庫。
2.  **Redis 伺服器本身宕機**: 如果 Redis 叢集發生大規模故障或直接宕機，所有快取功能失效，所有請求都會直接打到資料庫。

**核心特徵**: **大規模、範圍性** 的快取失效，導致系統性風險。

#### 解決方案

**針對場景一 (大量 Key 集體失效):**

1.  **過期時間隨機化**:
    *   **原理**: 在設定快取過期時間時，在基礎時間上增加一個隨機值 (例如，`EXPIRE key (3600 + rand(0, 300))`)。
    *   **效果**: 這樣可以讓 key 的過期時間點分散開，避免在同一時刻集體失效，從而將壓力均攤到一個時間段內。

**針對場景二 (Redis 宕機):**

2.  **高可用架構 (High Availability)**:
    *   **原理**: 部署高可用的 Redis 叢集，如 **Redis Sentinel (哨兵)** 或 **Redis Cluster**。
    *   **效果**: 當主節點宕機時，可以自動進行故障轉移，將從節點提升為新的主節點，從而保證快取服務的連續性。

3.  **服務降級與熔斷 (Degradation and Circuit Breaking)**:
    *   **原理**: 在應用層增加降級和熔斷機制。當檢測到資料庫壓力過大或 Redis 無法訪問時，可以暫時犧牲一部分非核心功能，直接返回一個預設的、兜底的資料，或者暫時關閉某些查詢功能，以保護核心服務和資料庫。
    *   **例如**: 在電商網站中，如果 Redis 故障，可以暫時不顯示「猜你喜歡」等個人化推薦，但保證商品瀏覽和下單的核心流程可用。

### 總結對照表

| 問題 | 成因 | 核心特徵 | 解決方案 |
| :--- | :--- | :--- | :--- |
| **快取穿透** | 查詢不存在的資料 | 點攻擊，資料在快取和DB中都沒有 | 快取空值、布隆過濾器 |
| **快取擊穿** | 單一熱點 Key 過期 | 線攻擊，高並發訪問單一熱點 | 互斥鎖、邏輯過期 |
| **快取雪崩** | 大量 Key 同時過期或 Redis 宕機 | 面攻擊，大規模快取失效 | 過期時間隨機化、高可用叢集、服務降級熔斷 |
