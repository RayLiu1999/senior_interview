# 請解釋 Redis 的記憶體淘汰策略 (Eviction Policies)

- **難度**: 8
- **重要程度**: 4
- **標籤**: `Redis`, `Memory Management`, `System Design`, `Performance`

## 問題詳述

當 Redis 的記憶體使用達到 `maxmemory` 上限時，會觸發記憶體淘汰機制以釋放空間。請詳細解釋 Redis 提供了哪些主要的記憶體淘汰策略，它們各自的運作原理是什麼，以及在不同場景下應該如何選擇。

## 核心理論與詳解

Redis 作為一個基於記憶體的資料庫，其記憶體是有限且寶貴的資源。通過設定 `maxmemory` 參數，我們可以限制 Redis 可使用的最大記憶體量。一旦實際使用的記憶體超過這個限制，Redis 就會根據預先設定的 **記憶體淘汰策略 (Eviction Policy)** 來刪除一部分 key，從而回收記憶體空間，保證服務的正常運行。這個策略可以通過 `maxmemory-policy` 參數進行配置。

### Redis 的主要淘汰策略

Redis 的淘汰策略大致可以分為兩類：**針對設定了過期時間 (TTL) 的 key** 和 **針對所有 key**。

#### 針對設定了過期時間的 Key (Volatile Keys)

1.  **`volatile-lru`**:
    *   **原理**: 在設定了過期時間的 key 中，選擇 **最近最少使用 (Least Recently Used)** 的 key 進行淘汰。
    *   **運作方式**: Redis 為每個 key 維護了一個時間戳，記錄其最後一次被訪問的時間。當需要淘汰時，它會從設定了 TTL 的 key 中找到時間戳最舊的那個並刪除。
    *   **適用場景**: 如果你的應用中，資料的使用頻率有明顯的熱點分佈，且你只想在可能過期的資料中進行淘汰，這是一個很好的選擇。

2.  **`volatile-lfu`** (Redis 4.0+):
    *   **原理**: 在設定了過期時間的 key 中，選擇 **最不經常使用 (Least Frequently Used)** 的 key 進行淘汰。
    *   **運作方式**: LFU 策略不僅考慮 key 的訪問時間，更關注其訪問頻率。它會追蹤每個 key 的訪問次數，並優先淘汰那些在一段時間內訪問次數最少的 key。
    *   **適用場景**: 當你更關心資料的歷史訪問頻率而不是最近一次的訪問時。例如，某些資料可能在短時間內被集中訪問一次，然後長時間不再使用 (LRU 可能會保留它)，而 LFU 會正確地將其淘汰。

3.  **`volatile-ttl`**:
    *   **原理**: 在設定了過期時間的 key 中，選擇 **剩餘存活時間 (Time-To-Live) 最短** 的 key 進行淘汰。
    *   **運作方式**: 直接比較 key 的剩餘 TTL，越是接近過期時間的 key 越優先被刪除。
    *   **適用場景**: 當你希望系統優先淘汰那些即將過期的資料，以騰出空間給新的、生命週期可能更長的資料時。

4.  **`volatile-random`**:
    *   **原理**: 在設定了過期時間的 key 中，**隨機選擇** 一個進行淘汰。
    *   **運作方式**: 完全隨機，沒有任何特定的演算法偏好。
    *   **適用場景**: 當你的應用中所有 key 的訪問機率都差不多，沒有明顯的熱點或優先級區分時。

#### 針對所有 Key (All Keys)

5.  **`allkeys-lru`**:
    *   **原理**: 在 **所有的 key** (無論是否設定過期時間) 中，選擇 **最近最少使用 (LRU)** 的 key 進行淘汰。
    *   **這是業界最常用的策略之一**，特別是當 Redis 純粹作為快取使用時。
    *   **適用場景**: 當你希望 Redis 能夠自動識別並保留熱點資料，淘汰冷資料，並且所有 key 的地位都平等時。這是通用快取場景下的首選。

6.  **`allkeys-lfu`** (Redis 4.0+):
    *   **原理**: 在 **所有的 key** 中，選擇 **最不經常使用 (LFU)** 的 key 進行淘汰。
    *   **適用場景**: 與 `volatile-lfu` 類似，但範圍擴展到所有 key。適用於需要根據訪問頻率來決定資料價值的場景。

7.  **`allkeys-random`**:
    *   **原理**: 在 **所有的 key** 中，**隨機選擇** 一個進行淘汰。
    *   **適用場景**: 與 `volatile-random` 類似，適用於資料沒有明顯優先級的場景。

#### 特殊策略

8.  **`noeviction`**:
    *   **原理**: **不進行任何淘汰**。這是 Redis 的預設策略。
    *   **運作方式**: 當記憶體達到 `maxmemory` 上限時，所有會導致記憶體增加的寫入指令 (如 `SET`, `LPUSH` 等) 都會返回錯誤。只有讀取指令和部分刪除指令可以正常執行。
    *   **適用場景**: 當 Redis 被用作主資料庫或訊息佇列，且不允許任何資料遺失時。在這種情況下，開發者需要自行管理記憶體，或者在收到錯誤時進行擴容。

### LRU 和 LFU 的近似實現

值得注意的是，Redis 實現的 LRU 和 LFU 都不是精確的演算法，而是 **近似的、抽樣的演算法**。

- **近似 LRU**: Redis 並不會遍歷所有的 key 來找到那個最完美的 LRU key。相反，它會隨機抽取一小部分 key (可通過 `maxmemory-samples` 參數配置，預設為 5)，然後從這批樣本中淘汰掉最符合 LRU 原則的那個。這種方式在效能和準確性之間取得了很好的平衡。增加樣本數量可以提高準確性，但會消耗更多 CPU。

- **近似 LFU**: LFU 的實現更為複雜，它為每個 key 維護一個包含訪問計數器和衰減時間的內部結構 (Probabilistic Counter)，以較低的記憶體成本來估算訪問頻率。

### 如何選擇淘汰策略？

選擇哪種策略高度依賴於你的應用場景：

- **通用快取場景**: 如果你將 Redis 用作後端資料庫的快取，**`allkeys-lru`** 通常是最佳選擇。它能很好地保留熱點資料，淘汰冷資料。
- **需要精確控制頻率**: 如果你的應用中，資料的價值與其歷史訪問頻率強相關，那麼 **`allkeys-lfu`** 或 **`volatile-lfu`** 會是更好的選擇。
- **資料有明確的生命週期**: 如果你能預知某些資料很快就會無用，可以給它們設定較短的 TTL，並使用 **`volatile-ttl`** 策略。
- **不允許任何資料被淘汰**: 如果 Redis 承載的是關鍵資料，不允許因為記憶體壓力而遺失，必須使用 **`noeviction`**，並做好記憶體監控和手動擴容。
- **資料無明顯優先級**: 如果所有資料的訪問模式都差不多，**`allkeys-random`** 或 **`volatile-random`** 是一個簡單高效的選擇。

在實際應用中，需要結合業務特點和監控資料來不斷調優 `maxmemory-policy` 和 `maxmemory-samples` 等參數，以達到最佳的快取效能和命中率。
