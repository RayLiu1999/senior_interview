# Redis Sentinel (哨兵) 和 Redis Cluster (叢集) 的架構與取捨是什麼？

- **難度**: 9
- **標籤**: `Redis`, `High Availability`, `Scalability`, `System Design`

## 問題詳述

為了實現 Redis 的高可用性和可擴展性，官方提供了兩種主流的解決方案：Redis Sentinel (哨兵) 和 Redis Cluster (叢集)。請詳細闡述這兩種方案的架構、運作原理、解決的核心問題，並深入比較它們之間的權衡取捨 (Trade-offs)。

## 核心理論與詳解

在生產環境中，單節點的 Redis 存在單點故障 (Single Point of Failure) 和擴展性瓶頸。Redis Sentinel 和 Redis Cluster 正是為了解決這些問題而設計的，但它們的目標和架構有著本質的區別。

- **Redis Sentinel**: 主要解決 **高可用性 (High Availability)** 問題，實現主從架構下的自動故障轉移。
- **Redis Cluster**: 同時解決 **高可用性** 和 **水平擴展 (Horizontal Scaling)** 問題，提供分散式資料分片的能力。

### Redis Sentinel (哨兵)

#### 架構與運作原理

Sentinel 是一個獨立的進程，它以監控者的角色存在。一個典型的 Sentinel 部署架構包括：

1.  **一個 Master 節點**: 負責處理所有寫入請求和部分讀取請求。
2.  **多個 Slave 節點**: 從 Master 節點異步複製資料，負責處理讀取請求，並作為 Master 的備份。
3.  **多個 Sentinel 進程**: 通常建議部署奇數個 (例如 3 個或 5 個) Sentinel 進程，以形成一個健壯的監控網路。這些 Sentinel 進程相互監控，同時也監控所有的 Master 和 Slave 節點。

**核心職責**:

1.  **監控 (Monitoring)**: Sentinel 持續地向 Redis 主從節點發送 `PING` 指令，檢查它們是否正常工作。
2.  **通知 (Notification)**: 當被監控的 Redis 節點出現問題時，Sentinel 可以通過 API 通知系統管理員或其他應用程式。
3.  **自動故障轉移 (Automatic Failover)**:
    *   當一個 Master 節點被多數 Sentinel 進程認定為 **主觀下線 (Subjective Down, SDOWN)** 後，它們會通過投票機制達成共識，將其標記為 **客觀下線 (Objective Down, ODOWN)**。
    *   Sentinel 領導者 (Leader) 會從剩餘的 Slave 節點中，按照一定的規則 (如優先級、複製偏移量、運行 ID) 選舉出一個新的 Master。
    *   Sentinel 會命令新的 Master 執行 `SLAVEOF no one`，並讓其他 Slave 節點去複製 (replicate) 新的 Master。
    *   最後，Sentinel 會更新內部配置，並通知客戶端新的 Master 地址。

#### 優點

1.  **實現高可用**: 提供了全自動的故障檢測和轉移機制，極大提升了 Redis 服務的可用性。
2.  **架構簡單**: 相對於 Cluster，主從複製 + 哨兵的架構更容易理解和部署。
3.  **客戶端友好**: 客戶端只需要連接到 Sentinel，由 Sentinel 提供當前 Master 的地址，應用程式無需關心主從切換的細節。

#### 缺點

1.  **沒有解決寫瓶頸**: 整個架構中仍然只有一個 Master 節點在處理寫請求。如果寫入壓力巨大，Master 會成為效能瓶頸。
2.  **資料容量受限**: 所有資料都必須儲存在單一的 Master 節點上，其記憶體容量限制了整個資料集的上限。
3.  **故障轉移有延遲**: 從檢測到 Master 故障到完成新 Master 的選舉和切換，存在一個時間窗口 (通常是數秒到數十秒)，在此期間寫服務是不可用的。
4.  **主從切換可能導致資料遺失**: 由於主從複製是異步的，如果在故障轉移時，新的 Master 尚未完全同步舊 Master 的所有資料，那麼這部分資料就會遺失。

### Redis Cluster (叢集)

#### 架構與運作原理

Redis Cluster 是一個去中心化 (Decentralized) 的分散式方案，它將資料 **分片 (Sharding)** 到多個節點上，每個節點都負責儲存一部分資料和維護叢集狀態。

1.  **資料分片 (Data Sharding)**:
    *   整個資料集被劃分為 **16384 個雜湊槽 (hash slots)**。
    *   叢集中的每個 Master 節點負責處理一部分雜湊槽。例如，在一個 3 主 3 從的叢集中，Master A 可能負責 0-5500，Master B 負責 5501-11000，Master C 負責 11001-16383。
    *   當客戶端要操作一個 key 時，它會使用 `CRC16(key) % 16384` 演算法計算出該 key 屬於哪個槽，然後將請求發送到負責該槽的 Master 節點。

2.  **高可用性**:
    *   Cluster 模式下，每個 Master 節點都可以擁有一個或多個 Slave 節點。
    *   當某個 Master 節點 (例如 Master A) 宕機時，其對應的 Slave 節點 (例如 Slave A1) 會被叢集中的其他節點投票選舉為新的 Master，接管原來 Master A 的雜湊槽，從而保證服務的連續性。這個過程類似於 Sentinel，但故障轉移是由整個叢集共同完成的，而不是由一個外部的 Sentinel 系統。

3.  **去中心化**:
    *   所有節點都通過 **Gossip 協議** 相互通信，交換彼此的狀態資訊 (如節點存活狀態、雜湊槽分配等)。
    *   沒有中心化的配置節點，任何一個節點都可以接收客戶端請求。如果請求的 key 不在當前節點負責的槽內，節點會返回一個 `MOVED` 或 `ASK` 重定向錯誤，告訴客戶端應該去哪個節點訪問。

#### 優點

1.  **高擴展性**: 通過增加 Master 節點，可以線性地擴展系統的寫入能力和儲存容量。
2.  **高可用性**: 內建了故障轉移機制，單個或少量節點的故障不會影響整個叢集的可用性。
3.  **去中心化架構**: 沒有單點故障，架構更健壯。

#### 缺點

1.  **實現複雜**: Cluster 的部署、維護和監控比 Sentinel 架構更複雜。
2.  **對批量操作支援不友好**: 如果要操作的多個 key 分布在不同的雜湊槽中 (例如 `MSET`, `MGET`)，Cluster 無法直接支援。需要使用 `Hash Tag` 等技術將相關的 key 強制分配到同一個槽中，或者由客戶端分別發起請求。
3.  **不完全支援交易**: Cluster 模式下的交易只能在單個節點內執行，不支援跨節點的原子交易。
4.  **資料遷移有成本**: 在擴容 (增加 Master) 或縮容 (減少 Master) 時，需要進行雜湊槽的遷移，這個過程會消耗系統資源並可能影響效能。

### 總結與權衡取捨

| 特性 | Redis Sentinel | Redis Cluster |
| :--- | :--- | :--- |
| **核心目標** | 高可用性 (HA) | 高可用性 (HA) + 水平擴展 |
| **架構模型** | 主從複製 + 外部監控 | 去中心化、多主多從 |
| **資料儲存** | 資料全量儲存在單一 Master | 資料分片到多個 Master |
| **寫入能力** | 單點寫入，有瓶頸 | 多點寫入，可線性擴展 |
| **儲存容量** | 受單機記憶體限制 | 可線性擴展 |
| **故障轉移** | 由 Sentinel 系統完成 | 由叢集內部節點投票完成 |
| **批量操作** | 支援所有批量操作 | 跨節點批量操作受限 (需用 Hash Tag) |
| **交易支援** | 支援 | 僅支援單節點交易 |
| **複雜度** | 相對簡單 | 複雜 |

#### 如何選擇？

- **如果你的應用資料量不大，且寫入壓力不是主要瓶頸，但對可用性有較高要求**:
  - **選擇 Redis Sentinel**。它能以相對簡單的架構滿足高可用需求，易於部署和維護。這是許多中小型專案的常見選擇。

- **如果你的應用面臨巨大的資料量、高並發寫入，或者預期未來會有快速的業務增長**:
  - **選擇 Redis Cluster**。它提供了水平擴展的能力，可以從根本上解決單點寫入瓶頸和記憶體容量限制的問題。雖然更複雜，但為未來的擴展性提供了保障。

總之，Sentinel 是 Redis 的「高可用」解決方案，而 Cluster 是 Redis 的「分散式」解決方案。選擇哪一個，取決於你的核心痛點是 **可用性** 還是 **擴展性**。
