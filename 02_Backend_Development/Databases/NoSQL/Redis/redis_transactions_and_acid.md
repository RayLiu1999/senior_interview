# Redis 的交易 (Transaction) 如何運作？它滿足 ACID 嗎？

- **難度**: 6
- **標籤**: `Redis`, `Transaction`, `ACID`, `System Design`

## 問題詳述

請解釋 Redis 中的交易 (Transaction) 是如何透過 `MULTI`, `EXEC`, `WATCH` 等指令實現的。並深入分析 Redis 交易在多大程度上滿足資料庫領域公認的 ACID (原子性、一致性、隔離性、持久性) 特性。

## 核心理論與詳解

Redis 的交易功能允許將一組指令打包在一起，然後依序地、不間斷地執行，執行期間不會被其他客戶端的請求打斷。這提供了一種實現基本原子操作的方式，但它與傳統關聯式資料庫 (RDBMS) 的交易在概念和保證上有很大不同。

### Redis 交易的實現機制

Redis 交易主要涉及三個核心指令：`MULTI`, `EXEC`, `DISCARD`。

1.  **`MULTI`**: 用於標記一個交易區塊的開始。當客戶端發送 `MULTI` 指令後，後續的所有指令都會被放入一個佇列中，而不會立即執行。伺服器會對這些指令進行排隊，並回覆 `QUEUED`。

2.  **`EXEC`**: 用於觸發交易的執行。當客戶端發送 `EXEC` 指令時，Redis 會開始依序執行佇列中的所有指令。所有指令的執行結果會作為一個整體返回給客戶端。

3.  **`DISCARD`**: 用於取消交易。如果在 `MULTI` 和 `EXEC` 之間發送 `DISCARD`，佇列中的所有指令都會被清空，交易被取消。

```go
// 程式碼範例 (使用 Go 的 go-redis 客戶端)
package main

import (
    "context"
    "fmt"
    "github.com/go-redis/redis/v8"
)

func main() {
    ctx := context.Background()
    rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})

    // 使用 TxPipeline 執行交易
    pipe := rdb.TxPipeline()
    
    // 將指令放入佇列
    incr := pipe.Incr(ctx, "counter")
    pipe.Expire(ctx, "counter", time.Minute)

    // 執行交易
    _, err := pipe.Exec(ctx)
    if err != nil {
        // 如果 EXEC 本身失敗 (例如 WATCH 的鍵被修改)，這裡會捕捉到錯誤
        fmt.Println("Transaction failed:", err)
        return
    }

    // 獲取交易中指令的結果
    fmt.Println("New counter value:", incr.Val())
}
```

### `WATCH`：樂觀鎖的實現

僅有 `MULTI` 和 `EXEC` 無法解決並發衝突問題。例如，當一個交易需要基於某個 key 的當前值做決策時，如果在 `MULTI` 和 `EXEC` 之間，這個 key 的值被其他客戶端修改了，交易的結果可能就不符合預期。

`WATCH` 指令就是為了解決這個問題而設計的，它提供了一種 **檢查並設定 (Check-And-Set, CAS)** 的行為，實現了樂觀鎖。

- **運作原理**:
  1.  在 `MULTI` 之前，客戶端可以 `WATCH` 一個或多個 key。
  2.  當客戶端執行 `EXEC` 時，Redis 會檢查被 `WATCH` 的 key 是否從 `WATCH` 指令執行後到 `EXEC` 執行前被任何其他客戶端修改過。
  3.  如果 **沒有被修改**，交易正常執行。
  4.  如果 **至少有一個 key 被修改**，整個交易將被取消，`EXEC` 會返回一個 `nil` 回應，表示交易失敗。
  5.  無論交易成功或失敗，`WATCH` 的效果都會在 `EXEC` 或 `DISCARD` 之後被取消。

開發者通常需要在應用程式層捕獲交易失敗的情況，並進行重試。

### Redis 交易與 ACID 特性分析

現在我們來分析 Redis 交易在多大程度上滿足 ACID。

#### A - 原子性 (Atomicity)

Redis 的交易 **部分滿足** 原子性。

- **滿足的方面**: Redis 保證被 `MULTI` 和 `EXEC` 包裹的指令集要麼 **全部被執行**，要麼 **一個都不執行** (例如因 `WATCH` 失敗而取消)。它將指令打包作為一個不可分割的單元來執行。
- **不滿足的方面 (核心差異)**: Redis 交易 **不支援回滾 (Rollback)**。如果在 `EXEC` 執行期間，佇列中的某個指令發生錯誤 (例如，對一個 String 類型的 key 執行 List 操作)，Redis 不會回滾已經成功執行的指令。它會繼續執行後續的指令，並在最終的返回結果中標示出哪個指令失敗了。

**結論**: Redis 的原子性是「執行層面的原子性」，而非「邏輯層面的原子性」。它保證了指令執行的連續性，但不保證指令執行的邏輯正確性。

#### C - 一致性 (Consistency)

Redis 的交易 **滿足** 一致性。

- 一致性指的是交易前後，資料庫的完整性約束沒有被破壞。
- 如果一個交易成功執行 (`EXEC` 成功)，資料庫會從一個一致的狀態轉移到另一個一致的狀態。
- 如果交易因 `WATCH` 失敗或指令語法錯誤而失敗，資料庫狀態不會改變。
- 如果交易中的指令在執行時出錯 (運行時錯誤)，只有失敗的指令不會生效，但資料庫的狀態依然是可預測和一致的，不會出現資料損壞。

#### I - 隔離性 (Isolation)

Redis 的交易 **滿足** 隔離性。

- 由於 Redis 的單執行緒模型，一個交易在 `EXEC` 執行期間，其內部的所有指令會被連續執行，中間不會插入任何其他客戶端的指令。
- 這意味著 Redis 的交易天然就是 **序列化 (Serializable)** 的，達到了最高的隔離級別。一個交易的執行對於其他客戶端來說是完全隔離的。

#### D - 持久性 (Durability)

Redis 交易的持久性 **取決於 Redis 的持久化配置**。

- Redis 交易本身 **不直接提供** 持久性保證。`EXEC` 成功返回僅表示指令已在記憶體中成功執行。
- **如果沒有開啟任何持久化**: 持久性為零。伺服器崩潰將導致所有資料遺失。
- **使用 RDB 持久化**: 持久性較弱。如果 `EXEC` 執行後，在下一次 RDB 快照生成前伺服器崩潰，交易的結果將會遺失。
- **使用 AOF 持久化**:
  - `appendfsync = no`: 持久性依賴作業系統，仍然有遺失資料的風險。
  - `appendfsync = everysec` (預設): 持久性較強，最多可能遺失 1 秒的資料。
  - `appendfsync = always`: 持久性最強。每個指令都會同步到磁碟，`EXEC` 成功後可以認為交易結果是持久的。但這會嚴重影響效能。

### 總結

| ACID 特性 | Redis 交易的滿足程度 | 備註 |
| :--- | :--- | :--- |
| **原子性 (A)** | **部分滿足** | 指令打包執行，但執行時錯誤不回滾。 |
| **一致性 (C)** | **滿足** | 交易前後資料庫狀態保持一致。 |
| **隔離性 (I)** | **滿足** | 單執行緒模型保證了序列化隔離級別。 |
| **持久性 (D)** | **依賴配置** | 持久性由 RDB/AOF 配置決定，而非交易本身。 |

總而言之，Redis 提供的是一種輕量級的、樂觀鎖模式的交易。它在隔離性和執行原子性上表現出色，但在錯誤回滾和持久性方面與傳統 RDBMS 有本質區別。在設計應用時，必須清楚地認識到這些限制，並在需要時 (如 `WATCH` 失敗) 於應用程式層面實現重試邏輯。
