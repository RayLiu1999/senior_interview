# MongoDB vs. SQL Databases

- **難度**: 4
- **重要性**: 5
- **標籤**: `MongoDB`, `SQL`, `NoSQL`, `Data Model`

## 問題詳述

請比較 MongoDB (作為 NoSQL 的代表) 與傳統 SQL 資料庫 (如 MySQL, PostgreSQL) 的核心差異。請從以下幾個方面進行闡述：

1.  資料模型 (Data Model)
2.  資料綱要 (Schema)
3.  查詢語言 (Query Language)
4.  擴展性 (Scalability)
5.  交易 (Transactions)

## 核心理論與詳解

MongoDB 和 SQL 資料庫代表了兩種截然不同的資料庫設計哲學。SQL 資料庫基於 Edgar F. Codd 的關聯式模型，強調資料的結構化、正規化和一致性。而 MongoDB 則是一種文件導向的 NoSQL 資料庫，專為靈活性、擴展性和開發速度而設計。

---

### 1. 資料模型 (Data Model)

-   **SQL 資料庫**:
    -   採用**關聯式模型 (Relational Model)**。資料被組織在二維的**表格 (Tables)** 中，表格由**行 (Rows)** 和**欄 (Columns)** 組成。
    -   資料之間的關係是透過**外鍵 (Foreign Keys)** 來定義和維護的。例如，一個 `orders` 表可以透過 `customer_id` 外鍵關聯到 `customers` 表。
    -   為了減少資料冗餘，通常會進行**正規化 (Normalization)**，將資料拆分到多個獨立的表中。查詢時，需要使用 `JOIN` 操作將這些表重新組合。

-   **MongoDB**:
    -   採用**文件模型 (Document Model)**。資料被儲存在類似 JSON 的 **BSON (Binary JSON)** 格式的**文件 (Documents)** 中。
    -   文件是自我包含的，可以有複雜的巢狀結構，例如陣列和子文件。相關的資料通常會被**嵌入 (Embed)** 在同一個文件中。
    -   例如，一個客戶的訂單可以直接作為一個陣列嵌入在該客戶的文件中，從而避免了 `JOIN` 操作。這種模型更貼近物件導向程式設計中的物件。

### 2. 資料綱要 (Schema)

-   **SQL 資料庫**:
    -   **綱要固定 (Schema-on-Write)**。在寫入資料之前，必須先嚴格定義好表格的結構，包括每個欄位的名稱和資料類型。
    -   如果需要修改綱要（例如新增一個欄位），通常需要執行 `ALTER TABLE` 操作，這在大型表格上可能是個耗時且有風險的操作。
    -   **優點**: 保證了資料的一致性和完整性。
    -   **缺點**: 缺乏靈活性，不適合快速迭代或需求多變的應用。

-   **MongoDB**:
    -   **綱要動態 (Schema-on-Read)**。一個集合 (Collection，相當於 SQL 的表格) 中的文件**不需要**有相同的結構。你可以隨時在文件中新增或刪除欄位，而無需預先定義。
    -   資料的結構和意義是在應用程式讀取和解析資料時才被賦予的。
    -   **優點**: 極大的靈活性，非常適合敏捷開發、原型設計和處理非結構化/半結構化資料。
    -   **缺點**: 資料一致性的保證責任轉移到了應用程式層面。如果管理不當，可能導致資料品質參差不齊。

### 3. 查詢語言 (Query Language)

-   **SQL 資料庫**:
    -   使用**結構化查詢語言 (SQL)**，這是一種功能強大、標準化的宣告式語言。
    -   SQL 在處理複雜的關聯查詢、聚合和資料分析方面非常成熟和高效。例如，`JOIN`, `GROUP BY`, `HAVING` 等操作。

-   **MongoDB**:
    -   使用 **MongoDB 查詢語言 (MQL)**，這是一種基於 JSON 的查詢語法。
    -   MQL 的語法直觀，對於開發人員來說很容易上手，因為它類似於在程式語言中操作物件。
    -   對於複雜的資料處理，MongoDB 提供了**聚合框架 (Aggregation Framework)**，它透過一個管線 (Pipeline) 的概念來對資料進行多階段的轉換和處理，功能上可以對應 SQL 的 `GROUP BY` 和其他複雜查詢。

### 4. 擴展性 (Scalability)

-   **SQL 資料庫**:
    -   傳統上更傾向於**垂直擴展 (Vertical Scaling / Scale-Up)**，即透過增加單一伺服器的硬體資源（如 CPU、RAM、SSD）來提升效能。
    -   雖然也可以實現水平擴展（例如透過讀寫分離、分庫分表），但通常實作起來更複雜，需要應用程式層或中間件的深度參與。

-   **MongoDB**:
    -   從設計之初就為**水平擴展 (Horizontal Scaling / Scale-Out)** 而生。
    -   透過**分片 (Sharding)** 機制，可以將一個大型集合的資料自動分散到多個伺服器（分片）上。整個分片叢集對應用程式來說是透明的。
    -   這使得 MongoDB 能夠處理海量的資料和極高的讀寫負載，而無需依賴昂貴的單體伺服器。

### 5. 交易 (Transactions)

-   **SQL 資料庫**:
    -   提供強大的 **ACID 交易**支援，能夠保證多個操作的**原子性 (Atomicity)**、**一致性 (Consistency)**、**隔離性 (Isolation)** 和**持久性 (Durability)**。
    -   這是金融系統等對資料一致性要求極高的應用的基石。

-   **MongoDB**:
    -   在早期版本中，MongoDB 只提供**單一文件層級的原子性**。這對於許多使用嵌入式模型的應用來說已經足夠。
    -   從 4.0 版本開始，MongoDB 引入了對**多文件 ACID 交易**的支援，使其能夠處理需要跨多個文件（甚至多個集合）保持一致性的複雜業務邏輯。
    -   儘管如此，在 NoSQL 的世界裡，過度依賴複雜交易通常被視為一種反模式 (anti-pattern)，因為它可能會犧牲掉一部分效能和擴展性優勢。

### 總結對比

| 特性 | SQL 資料庫 (例如 MySQL) | MongoDB |
| :--- | :--- | :--- |
| **資料模型** | 關聯式 (表格、行、欄) | 文件導向 (集合、BSON 文件) |
| **綱要** | 固定 (Schema-on-Write) | 動態 (Schema-on-Read) |
| **查詢語言** | SQL | MQL (JSON-like) |
| **擴展性** | 傾向垂直擴展 | 設計用於水平擴展 (分片) |
| **交易** | 強大的多行 ACID 交易 | 預設單文件原子性，支援多文件 ACID 交易 |
| **最佳場景** | 結構化資料、複雜查詢、資料一致性要求高的應用 | 非結構化/半結構化資料、快速迭代、高擴展性需求 |
