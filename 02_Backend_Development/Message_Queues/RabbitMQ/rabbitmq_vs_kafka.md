# RabbitMQ vs. Kafka：如何選擇？

- **難度**: 8
- **重要性**: 5
- **標籤**: `RabbitMQ`, `Kafka`, `Message Queue`, `System Design`

## 問題詳述

RabbitMQ 和 Apache Kafka 都是非常流行的訊息系統，但它們在架構和設計哲學上有著根本的不同。請比較這兩個系統的核心差異，並闡述在哪些場景下應該優先選擇 RabbitMQ，在哪些場景下又該選擇 Kafka？

## 核心理論與詳解

選擇 RabbitMQ 還是 Kafka，是系統設計中一個經典的權衡問題。它們的選擇主要取決於你的核心業務需求：你需要一個靈活的**訊息代理 (Broker)** 還是一個高吞吐量的**分散式日誌系統 (Distributed Log)**？

| 特性 | RabbitMQ | Apache Kafka |
| :--- | :--- | :--- |
| **核心模型** | 智慧代理 (Smart Broker) / 傻瓜消費者 (Dumb Consumer) | 傻瓜代理 (Dumb Broker) / 智慧消費者 (Smart Consumer) |
| **設計哲學** | 傳統訊息佇列，遵循 AMQP 等協議 | 分散式、持久化的日誌串流平台 |
| **訊息消費** | Broker 將訊息**推送 (Push)** 給消費者 | 消費者從 Broker **拉取 (Pull)** 訊息 |
| **訊息保留** | 訊息被消費並確認後即被**刪除** | 訊息基於**時間或大小**策略被保留，可重複消費 |
| **吞吐量** | 中等到高（數萬/秒） | 非常高（數十萬到百萬/秒） |
| **路由能力** | 非常強大和靈活（Direct, Fanout, Topic, Headers） | 較弱，基於 Topic 和 Partition |
| **消費者狀態** | Broker 追蹤消費者狀態和訊息確認 | 消費者自行追蹤位移 (Offset) |
| **協議** | AMQP, MQTT, STOMP 等 | 自訂的二進制協議 (over TCP) |

### RabbitMQ: 智慧代理模型

RabbitMQ 是一個功能齊全的訊息代理，它負責追蹤每則訊息的狀態，並將訊息「推送」給消費者。

- **優勢**:
  1. **複雜的路由邏輯**: 擁有四種交換機類型，可以實現非常精細和複雜的訊息路由策略。這是 RabbitMQ 最大的優勢之一。
  2. **靈活的通訊模式**: 完美支援點對點、請求/回應、發布/訂閱等多種通訊模式。
  3. **低延遲**: 對於需要快速傳遞和處理的單則訊息，RabbitMQ 通常能提供更低的端到端延遲。
  4. **成熟的協議支援**: 支援 AMQP, MQTT, STOMP 等多種標準化協議，使其能與各種系統和語言輕鬆整合。
  5. **消費者負載均衡**: Broker 會自動將訊息以輪詢方式分發給多個消費者，實現簡單的負載均衡。

- **劣勢**:
  1. **吞吐量瓶頸**: 由於 Broker 需要追蹤每則訊息的狀態，在高吞吐量場景下，其效能會受到限制。
  2. **訊息刪除機制**: 訊息一旦被消費和確認，就會從佇列中刪除。這使得「重複消費」歷史訊息變得困難。
  3. **擴展性**: 雖然支援叢集，但其擴展性和容錯性相較於 Kafka 的原生分散式設計要複雜一些。

#### 選擇 RabbitMQ 的場景

- **需要複雜的訊息路由**: 當你的業務需要將訊息根據多種規則發送到不同的處理單元時。
- **需要支援多種訊息傳遞模式**: 例如，你需要實現 RPC (遠端程序呼叫) 模式。
- **對單則訊息的處理延遲要求高**: 在金融交易、即時通訊等場景。
- **需要與現有的、基於標準協議的系統整合**。
- **系統的整體訊息量不是極端巨大**。

### Apache Kafka: 分散式日誌模型

Kafka 的核心是一個**不可變的、僅追加的日誌 (Immutable, Append-only Log)**。Broker 本身非常「傻」，它不追蹤哪些訊息被誰消費了。這個責任轉移給了消費者。

- **優勢**:
  1. **極高的吞吐量**: Kafka 為處理大規模即時數據流而生。其循序讀寫磁碟和零拷貝等技術使其能夠達到驚人的吞吐量。
  2. **持久化與可重複消費**: 訊息被持久化儲存在磁碟上，並且可以根據設定的策略保留很長時間。任何消費者都可以從任意位移 (Offset) 開始重複消費歷史數據。
  3. **優秀的擴展性和容錯性**: Kafka 的 Topic 被分為多個 Partition，這些 Partition 可以分佈在不同的 Broker 上，提供了原生的水平擴展和高可用性。
  4. **串流處理生態**: Kafka Streams 和 ksqlDB 等工具使其成為構建複雜串流處理應用程式的理想平台。

- **劣勢**:
  1. **路由能力較弱**: Kafka 的路由非常簡單，只能將訊息發送到指定的 Topic 和 Partition。它沒有 RabbitMQ 那樣靈活的交換機。
  2. **延遲相對較高**: 由於其批次處理和拉取模型，對於單則訊息的端到端延遲通常比 RabbitMQ 要高。
  3. **消費者複雜性**: 消費者需要自行管理消費的位移，這增加了客戶端開發的複雜性（儘管現代的客戶端函式庫已經簡化了這一點）。

#### 選擇 Kafka 的場景

- **大規模數據串流和日誌聚合**: 當你需要收集和處理來自大量來源的日誌、指標、IoT 數據時。
- **事件溯源 (Event Sourcing)**: 當你需要一個不可變的事件日誌來記錄系統的所有狀態變更時。
- **串流處理應用**: 當你需要對即時數據進行複雜的分析、轉換和聚合時。
- **需要重複消費歷史數據**: 當多個下游系統需要以不同的方式和速度消費同一份數據時。
- **追求極致的系統吞ut量**。

## 總結

- **選擇 RabbitMQ** 如果你需要一個傳統、可靠、功能豐富的訊息佇列，特別是當你的應用場景包含複雜的路由邏輯時。它是一個**戰術性**的選擇，用於解決服務間的解耦和非同步通訊。

- **選擇 Kafka** 如果你的核心是處理大規模的即時數據流，並希望將其作為整個數據架構的中心。它是一個**戰略性**的選擇，通常被用作企業級的「數據中樞 (Data Hub)」。

簡單來說：**RabbitMQ 是為了「訊息傳遞 (Messaging)」而生，而 Kafka 是為了「數據串流 (Streaming)」而生。** 雖然它們在某些功能上有所重疊，但其設計初衷和最佳應用場景有著本質的區別。
