# NATS 與 Kafka、RabbitMQ 的比較

- **難度**: 6
- **重要程度**: 4
- **標籤**: `NATS`, `Kafka`, `RabbitMQ`, `Message Queue`

## 問題詳述

NATS、Apache Kafka 和 RabbitMQ 是訊息傳遞領域三個非常流行但設計哲學截然不同的系統。請從架構、效能、持久化、使用場景等方面，詳細比較這三者的主要區別。

## 核心理論與詳解

選擇合適的訊息系統對系統架構至關重要。下面我們從幾個關鍵維度來比較 NATS、Kafka 和 RabbitMQ。

### 核心架構與模型

- **RabbitMQ**:
  - **模型**: 實現了 AMQP (Advanced Message Queuing Protocol) 協議的傳統訊息代理 (Broker)。
  - **架構**: 核心是 **Exchange (交換機)** 和 **Queue (佇列)**。生產者將訊息發送到 Exchange，Exchange 根據路由規則 (Routing Key) 將訊息分發到一個或多個綁定的 Queue。消費者從 Queue 中拉取訊息。
  - **特點**: 提供了非常靈活的路由拓撲（Direct, Fanout, Topic, Headers），但架構相對複雜。

- **Apache Kafka**:
  - **模型**: 分散式、分區、可重播的 **提交日誌 (Commit Log)**。
  - **架構**: 核心是 **Topic (主題)**，Topic 被分成多個 **Partition (分區)**。生產者將訊息寫入特定分區，消費者以群組 (Consumer Group) 的形式從分區中按順序讀取。每個分區對於一個消費者群組來說，只能由一個消費者實例消費。
  - **特點**: 為大規模資料串流和高吞吐量而設計。其日誌模型天然支援訊息重播。

- **NATS**:
  - **模型**: 高效能的 **發布-訂閱 (Pub-Sub)** 系統，帶有可選的持久化層 (JetStream)。
  - **架構**:
    - **Core NATS**: 極簡的 Pub-Sub，訊息在伺服器端是短暫的 (ephemeral)。
    - **NATS JetStream**: 在 Core NATS 之上增加了 **Stream (串流)** 和 **Consumer (消費者)** 的概念，實現了類似 Kafka 的日誌持久化。
  - **特點**: 設計極簡，追求極致效能和易用性。將短暫訊息和持久化串流融合在一個系統中。

### 效能與吞吐量

- **NATS**:
  - **效能**: 通常是三者中 **延遲最低、吞吐量最高** 的（尤其是在 Core NATS 模式下）。其伺服器和協議都為效能做了極致優化。
  - **優勢**: 非常適合需要快速響應的即時通訊場景。

- **Kafka**:
  - **效能**: **高吞吐量** 是其核心優勢。通過分區的水平擴展和批次處理，Kafka 可以處理極大規模的資料流（每秒數十萬甚至百萬條訊息）。
  - **延遲**: 延遲通常高於 NATS，因為它為持久化和磁碟寫入做了優化。

- **RabbitMQ**:
  - **效能**: 吞吐量和延遲通常介於 NATS 和 Kafka 之間（取決於具體配置）。對於複雜的路由邏輯，效能開銷會更大。
  - **瓶頸**: Broker 本身可能成為效能瓶頸，需要通過 federation 或 shovel 等機制進行擴展。

### 持久化與傳遞保證

- **RabbitMQ**:
  - **持久化**: 支援訊息持久化。可以將訊息標記為持久的，這樣即使 Broker 重啟，訊息也不會丟失。
  - **傳遞保證**: 支援「最多一次」、「至少一次」和「恰好一次」（通過發布者確認和消費者確認機制）。

- **Kafka**:
  - **持久化**: **所有訊息都是持久化的**。訊息被寫入磁碟上的日誌檔案中，並根據配置的保留策略（時間或大小）進行保留。
  - **傳遞保證**: 提供「最多一次」、「至少一次」和「恰好一次」（通過冪等生產者和事務）。

- **NATS**:
  - **持久化**: **雙模式**。
    - **Core NATS**: 不持久化，提供「最多一次」保證。
    - **JetStream**: 提供持久化，支援「至少一次」和「恰好一次」保證。
  - **靈活性**: 可以在同一個系統中根據需求選擇是否需要持久化。

### 使用場景

- **RabbitMQ**:
  - **適用場景**:
    - **複雜的訊息路由**: 當你需要根據多種規則將訊息發送到不同的佇列時。
    - **傳統的企業應用整合 (EAI)**: 在不同的應用程式之間可靠地傳遞任務和資料。
    - **需要延遲任務或重試機制的系統**: 可以通過 Dead Letter Exchange (死信交換機) 輕鬆實現。
  - **關鍵詞**: 靈活路由、任務佇列、AMQP。

- **Kafka**:
  - **適用場景**:
    - **大規模日誌聚合**: 從大量伺服器收集日誌資料。
    - **事件溯源 (Event Sourcing)**: 將應用程式的所有狀態變更記錄為不可變的事件流。
    - **流處理與即時分析**: 與 Flink, Spark Streaming 等流處理框架結合，進行即時資料分析。
    - **資料管道 (Data Pipeline)**: 在不同資料儲存和系統之間可靠地同步資料。
  - **關鍵詞**: 大資料、日誌串流、高吞TP量、訊息重播。

- **NATS**:
  - **適用場景**:
    - **微服務通訊骨幹**: 作為服務之間高速、低延遲的通訊層（服務發現、請求-回覆、事件廣播）。
    - **物聯網 (IoT) 和邊緣計算**: 在大量設備之間進行高效的遙測資料傳輸和命令控制。
    - **需要混合傳遞保證的系統**: 同時使用 Core NATS 進行即時狀態更新，使用 JetStream 處理關鍵業務事件。
    - **雲端原生應用**: 其簡單、易於部署和自動發現的特性非常適合在 Kubernetes 等環境中運行。
  - **關鍵詞**: 簡潔、高效能、低延遲、雲端原生。

### 總結比較表

| 特性 | RabbitMQ | Apache Kafka | NATS |
| :--- | :--- | :--- | :--- |
| **核心模型** | 智慧 Broker / 訊息佇列 | 分散式提交日誌 | Pub-Sub + 可選日誌 |
| **路由** | 非常靈活 (Exchange) | 基於 Topic-Partition | 基於 Subject (支援通配符) |
| **吞吐量** | 中等 | 非常高 | 極高 (Core NATS) / 高 (JetStream) |
| **延遲** | 較低 | 中等 | 極低 (Core NATS) / 較低 (JetStream) |
| **持久化** | 可選 | 總是持久化 | 雙模式 (JetStream 持久化) |
| **訊息重播** | 不直接支援 | 核心功能 | JetStream 支援 |
| **複雜性** | 較高 | 高 | 低 |
| **最佳場景** | 複雜路由、任務佇列 | 大資料串流、日誌聚合 | 微服務、IoT、高效能通訊 |

**結論**:

- **RabbitMQ** 是一個成熟、功能豐富的「瑞士軍刀」，適用於需要複雜路由的傳統企業應用。
- **Kafka** 是一個為處理海量資料串流而生的「巨獸」，是構建現代資料管道和事件驅動架構的基石。
- **NATS** 則是一個輕量、極速的「神經系統」，專為現代雲端原生和邊緣計算應用設計，兼具簡單性和強大功能。
