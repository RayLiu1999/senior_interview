# 快取策略與常見問題

- **難度**: 8
- **重要性**: 5
- **標籤**: `Caching`, `System Design`, `Performance`, `Reliability`

## 問題詳述

請解釋什麼是快取通讀 (Read-Through)、快取穿透 (Cache Penetration)、快取擊穿 (Cache Breakdown) 和快取雪崩 (Cache Avalanche)。並說明針對這些問題的典型解決方案。

## 核心理論與詳解

快取是提升系統效能、降低延遲和減少後端負載的關鍵技術。然而，不當的快取策略會引發一系列問題。理解這些模式和問題對於建立高效能、高可靠的系統至關重要。

### 快取讀取/寫入策略

#### 1. 快取通讀 (Read-Through)

- **運作方式**:
  1. 應用程式向快取請求數據。
  2. 如果快取命中 (Cache Hit)，則直接返回數據。
  3. 如果快取未命中 (Cache Miss)，**則由快取服務自己負責**從資料來源（如資料庫）加載數據。
  4. 快取服務將加載到的數據放入快取中，並返回給應用程式。
- **核心思想**: 應用程式只與快取互動，將數據加載邏輯封裝在快取層。這通常需要一個支援 Read-Through 功能的快取提供者。
- **優點**: 應用程式邏輯簡單，只需與快取打交道。
- **缺點**: 不是所有快取服務都支援，實現上可能更耦合。

#### 2. 旁路快取 (Cache-Aside)

這是最常見的快取策略，與 Read-Through 相似，但數據加載邏輯由**應用程式**控制。

- **讀取流程**:
  1. 應用程式先從快取讀取數據。
  2. 如果快取命中，直接返回。
  3. 如果快取未命中，應用程式從資料庫讀取數據。
  4. 應用程式將數據寫入快取，然後返回。
- **寫入流程 (常見的有 Write-Through 和 Write-Back)**:
  - **Write-Through (寫入穿透)**: 先更新資料庫，然後**同步**更新快取。保證了數據一致性，但寫入延遲較高。
  - **Write-Back (寫入回寫)**: 只更新快取，並將快取塊標記為「髒」(dirty)。然後在未來某個時間點（如被逐出時）異步地將數據寫回資料庫。寫入速度快，但有數據丟失的風險。

### 快取三大經典問題

#### 1. 快取穿透 (Cache Penetration)

- **現象**: 攻擊者或惡意使用者**持續請求一個在資料庫中根本不存在的數據**。
  - 由於快取中沒有這個數據（因為它根本不存在），每次請求都會穿過快取，直接打到資料庫上。
  - 大量此類請求會導致資料庫壓力劇增，甚至崩潰。
- **核心原因**: 請求的數據是**不存在的**。
- **解決方案**:
  - **快取空值 (Cache Null Values)**: 當資料庫查詢不到數據時，在快取中儲存一個特殊的「空值」（例如一個 `null` 或一個約定的字串），並設定一個較短的過期時間（如 1-5 分鐘）。這樣，後續對同一個不存在的 key 的請求就會直接命中快取的空值，而不會再查詢資料庫。
  - **布隆過濾器 (Bloom Filter)**: 在快取層前放置一個布隆過濾器。布隆過濾器是一種空間效率極高的数据結構，用於判斷一個元素**是否可能存在**於一個集合中。
    1. 將所有可能存在的數據的 key 都存入布隆過濾器。
    2. 當請求到來時，先查詢布隆過濾器。
    3. 如果布隆過濾器判斷 key 不存在，則直接拒絕請求，根本不會去查快取和資料庫。
    4. 如果判斷 key 可能存在，再繼續後續的快取查詢流程。
    - **優點**: 空間效率高，能有效過濾絕大多數不存在的 key。
    - **缺點**: 有一定的誤判率（會將不存在的 key 誤判為存在，但絕不會將存在的 key 誤判為不存在），且實現較複雜。

#### 2. 快取擊穿 (Cache Breakdown / Hotspot Invalidated)

- **現象**: 某一個**熱點數據 (Hotspot Key)** 過期了。
  - 在這個數據過期的瞬間，大量指向該數據的併發請求會同時到達。
  - 由於快取已失效，這些併發請求會全部穿透快取，直接打到資料庫上，導致資料庫瞬間壓力大增。
- **核心原因**: 單一**熱點數據**過期，引發大量併發請求同時重建快取。
- **解決方案**:
  - **互斥鎖 (Mutex Lock)**: 當快取未命中時，不是所有請求都去查資料庫。而是先獲取一個互斥鎖，只有第一個獲取到鎖的線程/進程去查詢資料庫並重建快取。其他線程/進程則等待，直到鎖被釋放。
    - **實現**: 可以使用 Redis 的 `SETNX` 或 ZooKeeper 的分散式鎖。
    - **優點**: 簡單有效，保證只有一個請求重建快取。
    - **缺點**: 引入了鎖的開銷，可能會降低吞吐量。需要處理鎖超時等問題。
  - **熱點數據永不過期 (或邏輯過期)**:
    - 對於極度熱點的數據，可以考慮不設定物理過期時間。
    - 而是將過期時間資訊儲存在 value 中。當應用程式讀取到數據時，檢查其內部時間戳是否已過期。如果過期，則由一個**異步的後台線程**去更新快取，而當前的請求仍然返回舊的（但可用的）數據。
    - **優點**: 避免了併發重建的衝擊，提供了極高的可用性。
    - **缺點**: 數據可能不是最新的，實現複雜。

#### 3. 快取雪崩 (Cache Avalanche)

- **現象**: 在某個時間點，**大量快取數據同時失效**，或者**快取服務本身發生故障**。
  - 這會導致大量的請求無法命中快取，瞬間全部湧向資料庫，如同「雪崩」一樣，可能導致資料庫被壓垮。
- **核心原因**:
  1. **大量數據同時過期**: 例如，在系統啟動時，將大量數據同時載入快取，並設定了相同的過期時間。
  2. **快取服務宕機**: Redis 或 Memcached 叢集整體不可用。
- **解決方案**:
  - **針對「同時過期」**:
    - **隨機化過期時間**: 在基礎過期時間上增加一個隨機值（例如，`expire_time = base_time + random(0, 300)` 秒）。這樣可以將過期時間打散，避免在同一時刻集中失效。
  - **針對「快取服務宕機」**:
    - **高可用快取叢集**: 搭建 Redis Sentinel 或 Redis Cluster，確保快取服務的高可用性。
    - **服務降級與熔斷**: 當快取服務不可用時，啟用降級策略。例如，暫時關閉非核心功能，或者直接返回一個預設的、靜態的頁面/數據，而不是去衝擊資料庫。使用熔斷器（如 Hystrix, Sentinel）來監控對資料庫的訪問，當壓力過大時自動熔斷，阻止更多請求。
    - **多級快取**: 使用本地快取（如 Guava Cache, Caffeine）作為一級快取，遠程快取（如 Redis）作為二級快取。即使遠程快取崩潰，本地快取仍能支撐一部分請求。

### 總結

| 問題 | 現象 | 核心原因 | 解決方案 |
| :--- | :--- | :--- | :--- |
| **快取穿透** | 請求不存在的數據 | 數據不存在 | 快取空值、布隆過濾器 |
| **快取擊穿** | 單一熱點數據過期 | 單一熱點 Key 失效 | 互斥鎖、熱點數據永不過期 |
| **快取雪崩** | 大量數據同時過期或快取宕機 | 大量 Key 同時失效或快取服務故障 | 隨機化過期時間、高可用叢集、服務降級/熔斷 |
